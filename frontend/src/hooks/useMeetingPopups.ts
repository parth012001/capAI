import { useMemo, useRef, useEffect, useCallback } from 'react';
import { useDrafts } from './useDrafts';
import type { AutoGeneratedDraft } from '../types/draft';

/**
 * Meeting context from backend (matches our Phase 1 implementation)
 */
export interface MeetingContext {
  meetingType: 'accept' | 'conflict_calendly' | 'vague_calendly' | 'alternatives' | 'more_info';
  originalRequest: string;
  proposedTime?: string;
  hasConflict: boolean;
  schedulingLink?: string;
  suggestedTimes?: Array<{
    start: string;
    end: string;
    formatted: string;
    confidence: number;
  }>;
}

/**
 * Meeting draft with enhanced typing
 */
export interface MeetingDraft extends AutoGeneratedDraft {
  type?: 'meeting_response';
  meetingContext?: MeetingContext;
}

/**
 * Popup state for meeting draft
 */
export interface MeetingPopupState {
  id: number;
  draft: MeetingDraft;
  isVisible: boolean;
  shownAt: Date;
}

/**
 * Hook to detect and manage meeting response popups
 * Leverages existing useDrafts() polling system with smart filtering
 */
export function useMeetingPopups() {
  const { data: draftsData, isLoading, error, refetch } = useDrafts();
  const shownPopupsRef = useRef<Set<number>>(new Set());
  const activePopupRef = useRef<number | null>(null);

  // Filter meeting drafts that need popup approval
  const meetingDrafts = useMemo(() => {
    if (!draftsData?.drafts) return [];

    return draftsData.drafts.filter((draft): draft is MeetingDraft => {
      // Primary detection: relationship type column (this is reliable)
      const isMeetingResponse = draft.relationshipType === 'meeting_response';

      // Check if it needs user action
      const needsUserAction = draft.status === 'pending';

      // Meeting response with pending status should show popup
      if (!isMeetingResponse || !needsUserAction) return false;

      return needsUserAction;
    });
  }, [draftsData?.drafts]);

  // Find drafts that need popups (not yet shown)
  const draftsNeedingPopups = useMemo(() => {
    return meetingDrafts.filter(draft => {
      return !shownPopupsRef.current.has(draft.id) && activePopupRef.current !== draft.id;
    });
  }, [meetingDrafts]);

  // Get the next draft to show popup for
  const nextPopupDraft = useMemo(() => {
    if (draftsNeedingPopups.length === 0) return null;

    // Show the most recent draft first
    return draftsNeedingPopups.sort((a, b) =>
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    )[0];
  }, [draftsNeedingPopups]);

  // Mark popup as shown
  const markPopupShown = useCallback((draftId: number) => {
    shownPopupsRef.current.add(draftId);
    if (activePopupRef.current === draftId) {
      activePopupRef.current = null;
    }
  }, []);

  // Set active popup
  const setActivePopup = useCallback((draftId: number | null) => {
    activePopupRef.current = draftId;
  }, []);

  // Reset shown popups (useful for testing or manual refresh)
  const resetShownPopups = useCallback(() => {
    shownPopupsRef.current.clear();
    activePopupRef.current = null;
  }, []);

  // Auto-trigger popup for new meeting drafts
  useEffect(() => {
    if (nextPopupDraft && activePopupRef.current === null) {
      setActivePopup(nextPopupDraft.id);
      console.log('ðŸŽ¯ [MEETING POPUP] New meeting draft detected:', {
        draftId: nextPopupDraft.id,
        subject: nextPopupDraft.subject,
        from: nextPopupDraft.originalEmail?.from,
        source: nextPopupDraft.contextUsed?.source
      });
    }
  }, [nextPopupDraft, setActivePopup]);

  // Extract meeting context from draft
  const getMeetingContext = useCallback((draft: MeetingDraft): MeetingContext | null => {
    const context = draft.contextUsed;
    if (!context?.meetingRequest) return null;

    // Map from our backend context structure
    const meetingRequest = context.meetingRequest;

    // Determine meeting type from action taken
    let meetingType: MeetingContext['meetingType'] = 'accept';
    if (context.actionTaken) {
      switch (context.actionTaken) {
        case 'accepted': meetingType = 'accept'; break;
        case 'suggested_scheduling_link_conflict': meetingType = 'conflict_calendly'; break;
        case 'suggested_scheduling_link_vague': meetingType = 'vague_calendly'; break;
        case 'suggested_alternatives': meetingType = 'alternatives'; break;
        case 'requested_more_info': meetingType = 'more_info'; break;
      }
    }

    return {
      meetingType,
      originalRequest: meetingRequest.subject || context.originalEmail?.subject || 'Meeting request',
      proposedTime: meetingRequest.preferredDates?.[0],
      hasConflict: context.actionTaken?.includes('conflict') || false,
      schedulingLink: context.schedulingLink,
      suggestedTimes: meetingRequest.suggestedTimes || []
    };
  }, []);

  return {
    // Core data
    meetingDrafts,
    nextPopupDraft,
    draftsNeedingPopups,

    // Active popup management
    activePopupId: activePopupRef.current,
    setActivePopup,
    markPopupShown,

    // Utilities
    resetShownPopups,
    getMeetingContext,

    // Polling state (from useDrafts)
    isLoading,
    error,
    refetch,

    // Statistics
    totalMeetingDrafts: meetingDrafts.length,
    pendingPopups: draftsNeedingPopups.length,
    shownPopupsCount: shownPopupsRef.current.size,
  };
}

/**
 * Simplified hook that just tells you if there's a meeting popup to show
 */
export function useHasMeetingPopup() {
  const { nextPopupDraft, isLoading } = useMeetingPopups();

  return {
    hasPopup: !isLoading && nextPopupDraft !== null,
    draftId: nextPopupDraft?.id || null
  };
}