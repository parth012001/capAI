import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';

// Load environment variables FIRST before any other imports that use them
dotenv.config();

// Production imports
import { env, features, initializeEnvironment } from './config/environment';

// Initialize environment configuration after dotenv is loaded
initializeEnvironment();
import { logger } from './utils/logger';
import { logger as pinoLogger, sanitizeUserId } from './utils/pino-logger';
import { monitoring, monitoringMiddleware } from './utils/monitoring';
import { redis } from './utils/redis';
import {
  securityHeaders,
  requestLogging,
  errorHandler,
  healthCheckBypass,
  authRateLimit,
  apiRateLimit,
  shutdownSecurity
} from './middleware/security';
import healthRoutes from './routes/health';
import { testConnection, initializeDatabase, pool, closePool } from './database/connection';
import { GmailService } from './services/gmail';
import { EmailModel } from './models/Email';
import { AIService } from './services/ai';
import { DraftModel } from './models/Draft';
import { ContextService } from './services/context';
import { ContextModel } from './models/Context';
import { ResponseService } from './services/response';
import { LearningService } from './services/learning';
import { CalendarService } from './services/calendar';
import { CalendarModel } from './models/Calendar';
import { MeetingDetectionService } from './services/meetingDetection';
import { AutoSchedulingService } from './services/autoScheduling';
import { MeetingPipelineService } from './services/meetingPipeline';
import { MeetingConfirmationService } from './services/meetingConfirmation';
import { AutoGeneratedDraftModel } from './models/AutoGeneratedDraft';
import { PromotionalEmailModel } from './models/PromotionalEmail';
import { TokenStorageService } from './services/tokenStorage';
import { UserProfileService } from './services/userProfile';
import { IntelligentEmailRouter } from './services/intelligentEmailRouter';
import { WebhookRenewalService } from './services/webhookRenewal';
import { WebhookTestingSuite } from './services/webhookTesting';
import { semanticSearchService } from './services/semanticSearchService';
import { voiceService } from './services/voiceService';
import multer from 'multer';
import { google } from 'googleapis';
import { authMiddleware, getUserId } from './middleware/auth';
import authRoutes from './routes/auth';
import composioWebhooksRouter from './routes/composio-webhooks';

const app = express();
const port = env.PORT;

// Production middleware - order matters!
app.use(requestLogging);
app.use(healthCheckBypass);
app.use(monitoringMiddleware());
app.use(express.json({ limit: '10mb' }));

// Enable CORS for frontend (conditionally)
if (features.enableCORS) {
  const allowedOrigins = [
    'http://localhost:5173', // Local development
    'https://cap-ai-puce.vercel.app', // Original Vercel deployment
    'https://www.getcaptainapp.com', // Production domain
    env.FRONTEND_URL // Custom frontend URL from env
  ].filter(Boolean); // Remove undefined/null values

  app.use(cors({
    origin: (origin, callback) => {
      // Allow requests with no origin (mobile apps, Postman, etc.)
      if (!origin) return callback(null, true);

      if (allowedOrigins.includes(origin)) {
        callback(null, true);
      } else {
        callback(new Error(`Origin ${origin} not allowed by CORS`));
      }
    },
    credentials: true
  }));
}

// Configure multer for audio file uploads (voice features)
// Store files in memory as Buffer for processing
const audioUpload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 25 * 1024 * 1024, // 25 MB limit (Whisper API limit)
  },
  fileFilter: (req, file, cb) => {
    // Only allow audio formats supported by Whisper
    const allowedMimeTypes = [
      'audio/mpeg', 'audio/mp3', 'audio/wav', 'audio/webm',
      'audio/mp4', 'audio/m4a', 'audio/ogg', 'audio/flac'
    ];

    if (allowedMimeTypes.includes(file.mimetype) || file.mimetype.startsWith('audio/')) {
      cb(null, true);
    } else {
      cb(new Error(`Unsupported audio format: ${file.mimetype}. Supported formats: mp3, wav, webm, mp4, m4a, ogg, flac`));
    }
  }
});

// Global instances
let gmailService: GmailService;
let emailModel: EmailModel;
let aiService: AIService;
let draftModel: DraftModel;
let contextService: ContextService;
let contextModel: ContextModel;
let responseService: ResponseService;
let learningService: LearningService;
let calendarService: CalendarService;
let calendarModel: CalendarModel;
let meetingDetectionService: MeetingDetectionService;
let autoSchedulingService: AutoSchedulingService;
let meetingPipelineService: MeetingPipelineService;
let meetingConfirmationService: MeetingConfirmationService;
let autoGeneratedDraftModel: AutoGeneratedDraftModel;
let promotionalEmailModel: PromotionalEmailModel;
let tokenStorageService: TokenStorageService;
let intelligentEmailRouter: IntelligentEmailRouter;
let webhookRenewalService: WebhookRenewalService;
let webhookTestingSuite: WebhookTestingSuite;

// Initialize services
async function initializeServices() {
  logger.info('ðŸš€ Initializing Chief AI Email Assistant', {
    environment: env.NODE_ENV,
    port: env.PORT,
    version: '0.1.0'
  });

  // Test database connection
  const dbConnected = await testConnection();
  if (!dbConnected) {
    logger.error('âŒ Cannot connect to database. Please check your DATABASE_URL configuration');
    throw new Error('Database connection failed. Check DATABASE_URL environment variable.');
  }

  // Initialize database schema
  await initializeDatabase();

  // Initialize services
  gmailService = new GmailService();
  emailModel = new EmailModel();
  aiService = new AIService();
  draftModel = new DraftModel();
  contextService = new ContextService();
  contextModel = new ContextModel();
  responseService = new ResponseService(aiService, contextService, gmailService);
  learningService = new LearningService(aiService);
  calendarService = new CalendarService();
  calendarModel = new CalendarModel();
  meetingDetectionService = new MeetingDetectionService();
  autoSchedulingService = new AutoSchedulingService();
  meetingPipelineService = new MeetingPipelineService(responseService);
  meetingConfirmationService = new MeetingConfirmationService();
  autoGeneratedDraftModel = new AutoGeneratedDraftModel();
  promotionalEmailModel = new PromotionalEmailModel();
  tokenStorageService = new TokenStorageService();
  intelligentEmailRouter = new IntelligentEmailRouter(responseService);
  webhookRenewalService = new WebhookRenewalService();
  webhookTestingSuite = new WebhookTestingSuite();

  logger.info('âœ… All services initialized successfully');
  
  // Start webhook renewal service
  webhookRenewalService.startRenewalService();
}

// Health check routes (no auth required)
app.use('/', healthRoutes);

// Auth routes with rate limiting
app.use('/api/auth', authRateLimit, authRoutes);

// Composio webhook routes (feature flag controlled)
if (features.useComposio) {
  app.use('/', composioWebhooksRouter);
  console.log('âœ… Composio webhook routes enabled');
}

// ============================================================
// COMPOSIO OAUTH ROUTES (NEW - Feature Flag Controlled)
// ============================================================

// Composio OAuth signup
app.get('/auth/composio/signup', async (req, res) => {
  try {
    if (!features.useComposio) {
      return res.status(400).json({ error: 'Composio integration not enabled' });
    }

    const { ComposioAuthService } = await import('./services/composio/auth');
    const composioAuth = new ComposioAuthService();

    const frontendUrl = env.FRONTEND_URL || 'http://localhost:5173';
    const redirectUrl = `${frontendUrl}/auth/composio/callback`;

    const authUrl = await composioAuth.getOAuthUrl(redirectUrl, 'signup');

    console.log('ðŸ†• [COMPOSIO] Sign up flow initiated');
    res.json({ authUrl, intent: 'signup', provider: 'composio' });
  } catch (error) {
    console.error('âŒ [COMPOSIO] Sign up flow failed:', error);
    res.status(500).json({ error: 'Failed to initiate Composio signup' });
  }
});

// Composio OAuth signin
app.get('/auth/composio/signin', async (req, res) => {
  try {
    if (!features.useComposio) {
      return res.status(400).json({ error: 'Composio integration not enabled' });
    }

    const { ComposioAuthService } = await import('./services/composio/auth');
    const composioAuth = new ComposioAuthService();

    const frontendUrl = env.FRONTEND_URL || 'http://localhost:5173';
    const redirectUrl = `${frontendUrl}/auth/composio/callback`;

    const authUrl = await composioAuth.getOAuthUrl(redirectUrl, 'signin');

    console.log('ðŸ” [COMPOSIO] Sign in flow initiated');
    res.json({ authUrl, intent: 'signin', provider: 'composio' });
  } catch (error) {
    console.error('âŒ [COMPOSIO] Sign in flow failed:', error);
    res.status(500).json({ error: 'Failed to initiate Composio signin' });
  }
});

// Composio OAuth callback
app.get('/auth/composio/callback', async (req, res) => {
  const frontendUrl = env.FRONTEND_URL || 'http://localhost:5173';

  try {
    if (!features.useComposio) {
      return res.redirect(`${frontendUrl}/auth/callback?error=composio_disabled`);
    }

    const { connectedAccountId, state } = req.query;

    if (!connectedAccountId) {
      return res.redirect(`${frontendUrl}/auth/callback?error=no_connected_account&provider=composio`);
    }

    console.log('ðŸ”„ [COMPOSIO] Processing OAuth callback...');

    const { ComposioAuthService } = await import('./services/composio/auth');
    const composioAuth = new ComposioAuthService();

    // Process OAuth callback - wait for connection to complete
    const authResult = await composioAuth.processOAuthCallback(
      connectedAccountId as string,
      state as string
    );

    console.log(`âœ… [COMPOSIO] Authentication successful for ${authResult.email}`);
    console.log(`ðŸ“Š [COMPOSIO] Entity ID: ${authResult.entityId}`);
    console.log(`ðŸ”— [COMPOSIO] Connected apps: ${authResult.connectedApps.join(', ')}`);

    // Check if this is a new user (for onboarding)
    const tokenStorage = new TokenStorageService();
    const userData = await tokenStorage.getUserTokens(authResult.userId);
    const isNewUser = !userData || !userData.onboardingCompleted;

    // Generate JWT token for frontend authentication
    const jwtToken = authMiddleware.generateToken(authResult.userId, authResult.email);

    // Return JWT token with onboarding status
    const authData = Buffer.from(JSON.stringify({
      jwt_token: jwtToken,
      user_id: authResult.userId,
      email: authResult.email,
      is_new_user: isNewUser,
      needs_onboarding: isNewUser,
      provider: 'composio',
      entity_id: authResult.entityId
    })).toString('base64');

    // Redirect to frontend with JWT token
    res.redirect(`${frontendUrl}/auth/callback?success=true&tokens=${encodeURIComponent(authData)}&provider=composio`);
  } catch (error) {
    console.error('âŒ [COMPOSIO] OAuth callback failed:', error);
    res.redirect(`${frontendUrl}/auth/callback?error=auth_failed&provider=composio`);
  }
});

// ============================================================
// LEGACY OAUTH ROUTES (Keep for rollback)
// ============================================================

// OAuth routes (separate from API auth routes)
app.get('/auth', (req, res) => {
  // âœ… SECURITY FIX: No userId yet (pre-OAuth), safe to use global gmailService for URL generation only
  const authUrl = gmailService.getAuthUrl();
  console.log('ðŸ” Visit this URL to authorize the app:');
  console.log(authUrl);
  res.json({ authUrl });
});

// Intent-based auth endpoints for proper sign up/sign in flow
app.get('/auth/signup', (req, res) => {
  // âœ… SECURITY FIX: No userId yet (pre-OAuth), safe to use global gmailService for URL generation only
  const authUrl = gmailService.getAuthUrl('signup');
  console.log('ðŸ†• Sign up flow initiated');
  res.json({ authUrl, intent: 'signup' });
});

app.get('/auth/signin', (req, res) => {
  // âœ… SECURITY FIX: No userId yet (pre-OAuth), safe to use global gmailService for URL generation only
  const authUrl = gmailService.getAuthUrl('signin');
  console.log('ðŸ” Sign in flow initiated');
  res.json({ authUrl, intent: 'signin' });
});

app.get('/auth/callback', async (req, res) => {
  const frontendUrl = env.FRONTEND_URL || (env.NODE_ENV === 'development' ? 'http://localhost:5173' : 'https://cap-ai-puce.vercel.app');

  try {
    const { code, state } = req.query;

    if (!code) {
      // Redirect to frontend with error
      return res.redirect(`${frontendUrl}/auth/callback?error=no_code`);
    }

    // Extract intent from state parameter
    let intent = null;
    if (state) {
      try {
        const stateData = JSON.parse(state as string);
        intent = stateData.intent;
        console.log(`ðŸŽ¯ OAuth callback with intent: ${intent}`);
      } catch (error) {
        console.log('âš ï¸ Could not parse state parameter, continuing without intent');
      }
    }

    // âœ… SECURITY FIX: Use temporary service instance for OAuth token exchange
    // Note: We don't have a userId yet, so we use the global gmailService temporarily
    // This is safe because setTokens() doesn't use mutable user state
    const tokens = await gmailService.setTokens(code as string);
    console.log('âœ… Authorization successful!');

    // Get user Gmail address and validate intent
    try {
      const gmail = google.gmail({ version: 'v1', auth: gmailService.oauth2Client });
      const userProfile = await gmail.users.getProfile({ userId: 'me' });
      const gmailAddress = userProfile.data.emailAddress;
      
      if (gmailAddress && tokens.refresh_token) {
        // ðŸ” INTENT VALIDATION - Check user existence vs intent
        const existingUser = await tokenStorageService.getUserByEmail(gmailAddress);
        
        if (intent === 'signin' && !existingUser) {
          console.log(`âŒ Sign in failed: User ${gmailAddress} does not exist`);
          return res.redirect(`${frontendUrl}/auth/callback?error=user_not_found&email=${encodeURIComponent(gmailAddress)}`);
        }

        if (intent === 'signup' && existingUser) {
          console.log(`âŒ Sign up failed: User ${gmailAddress} already exists`);
          return res.redirect(`${frontendUrl}/auth/callback?error=user_exists&email=${encodeURIComponent(gmailAddress)}`);
        }
        
        console.log(`âœ… Intent validation passed for ${intent || 'no-intent'}: ${gmailAddress}`);
        
        // Determine if this is a new user (for onboarding flow)
        const isNewUser = !existingUser;
        // Save tokens to database for persistent 24/7 access
        const userId = await tokenStorageService.saveUserTokens(gmailAddress, {
          accessToken: tokens.access_token || '',
          refreshToken: tokens.refresh_token,
          expiresAt: new Date(Date.now() + 3600 * 1000) // 1 hour
        });
        
        console.log(`ðŸ’¾ Tokens saved to database for 24/7 operation. User ID: ${userId}`);
        console.log(`ðŸ“§ Gmail address: ${gmailAddress}`);
        
        // ðŸš€ AUTOMATIC WEBHOOK SETUP - Set up Gmail webhook for real-time processing
        try {
          console.log(`ðŸ”” Setting up automatic webhook subscription for ${gmailAddress}...`);

          // âœ… SECURITY FIX: Create isolated service container for this user
          const { ServiceFactory } = await import('./utils/serviceFactory');
          const services = ServiceFactory.createForUser(userId);
          const userGmailService = await services.getGmailService();

          // Set up webhook subscription
          const watchResponse = await userGmailService.setupWebhook();

          console.log(`âœ… Automatic webhook setup successful for ${gmailAddress}`);
          console.log(`ðŸ“Š Webhook expires: ${new Date(parseInt(watchResponse.expiration)).toISOString()}`);
        } catch (webhookError) {
          console.error(`âš ï¸ Failed to set up automatic webhook for ${gmailAddress}:`, webhookError);
          // Don't fail the entire OAuth process if webhook setup fails
          // User can still use the system, just without real-time processing
        }
        
        // Generate JWT token for frontend authentication
        const jwtToken = authMiddleware.generateToken(userId, gmailAddress);
        
        // Return JWT token with onboarding status
        const authData = Buffer.from(JSON.stringify({
          jwt_token: jwtToken,
          user_id: userId,
          email: gmailAddress,
          is_new_user: isNewUser,
          needs_onboarding: isNewUser || !existingUser?.onboardingCompleted
        })).toString('base64');
        
        // Redirect to frontend with JWT token and onboarding info
        res.redirect(`${frontendUrl}/auth/callback?success=true&tokens=${encodeURIComponent(authData)}`);
      } else {
        throw new Error('Missing Gmail address or refresh token');
      }
    } catch (error) {
      console.error('âš ï¸ Failed to complete user setup:', error);
      res.redirect(`${frontendUrl}/auth/callback?error=auth_failed`);
    }
  } catch (error) {
    console.error('âŒ Authorization failed:', error);
    // Redirect to frontend with error
    res.redirect(`${frontendUrl}/auth/callback?error=auth_failed`);
  }
});

// Testing endpoint to set tokens directly
// âš ï¸ DEPRECATED: This endpoint uses global gmailService and should not be used in production
// TODO: Remove this endpoint or refactor to require userId for testing
app.post('/auth/set-tokens', async (req, res) => {
  try {
    const { accessToken, refreshToken } = req.body;
    if (!accessToken || !refreshToken) {
      return res.status(400).json({ error: 'Both accessToken and refreshToken are required' });
    }

    // âš ï¸ SECURITY ISSUE: Using global singleton - only safe for single-user testing
    await gmailService.setStoredTokens(accessToken, refreshToken);
    console.log('âœ… OAuth tokens set successfully (TESTING ONLY - NOT SAFE FOR MULTI-USER)');
    res.json({ message: 'Tokens set successfully for testing' });
  } catch (error) {
    console.error('âŒ Error setting tokens:', error);
    res.status(500).json({ error: 'Failed to set tokens' });
  }
});

// Add authentication middleware to all protected routes
// User Profile endpoints
app.get('/api/user/scheduling-link', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const userProfileService = new UserProfileService(pool);

    const schedulingLink = await userProfileService.getSchedulingLink(userId);

    res.json({ schedulingLink });
  } catch (error) {
    console.error('âŒ Error getting scheduling link:', error);
    res.status(500).json({ error: 'Failed to get scheduling link' });
  }
});

app.put('/api/user/scheduling-link', authMiddleware.authenticate, async (req, res) => {
  try {
    console.log('ðŸ”— PUT /api/user/scheduling-link called');
    const userId = getUserId(req);
    const { schedulingLink } = req.body;
    console.log(`ðŸ”— User ${userId.substring(0, 8)}: Updating scheduling link to: ${schedulingLink}`);

    if (!schedulingLink || typeof schedulingLink !== 'string') {
      console.log('ðŸ”— âŒ Invalid scheduling link provided');
      return res.status(400).json({ error: 'Valid scheduling link is required' });
    }

    // Validate the scheduling link
    const { SchedulingLinkValidator } = await import('./utils/schedulingLinkValidator');
    const validationResult = SchedulingLinkValidator.validateSchedulingLinkQuick(schedulingLink);
    console.log(`ðŸ”— Validation result:`, validationResult);

    if (!validationResult.isValid) {
      console.log(`ðŸ”— âŒ Validation failed: ${validationResult.error}`);
      return res.status(400).json({ error: validationResult.error });
    }

    const userProfileService = new UserProfileService(pool);
    const success = await userProfileService.updateSchedulingLink(userId, schedulingLink, true);

    if (success) {
      console.log(`âœ… Updated scheduling link for user ${userId.substring(0, 8)}: ${validationResult.platform}`);
      res.json({
        success: true,
        platform: validationResult.platform,
        message: 'Scheduling link updated successfully'
      });
    } else {
      res.status(500).json({ error: 'Failed to update scheduling link' });
    }
  } catch (error) {
    console.error('âŒ Error updating scheduling link:', error);
    res.status(500).json({ error: 'Failed to update scheduling link' });
  }
});

app.delete('/api/user/scheduling-link', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const userProfileService = new UserProfileService(pool);

    const success = await userProfileService.updateSchedulingLink(userId, '', false);

    if (success) {
      console.log(`âœ… Removed scheduling link for user ${userId.substring(0, 8)}`);
      res.json({
        success: true,
        message: 'Scheduling link removed successfully'
      });
    } else {
      res.status(500).json({ error: 'Failed to remove scheduling link' });
    }
  } catch (error) {
    console.error('âŒ Error removing scheduling link:', error);
    res.status(500).json({ error: 'Failed to remove scheduling link' });
  }
});

// Email routes - require authentication
app.get('/emails/fetch', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    console.log(`ðŸ“§ Fetching emails for user: ${userId.substring(0, 8)}...`);

    // âœ… SECURITY FIX: Use isolated service container
    const { ServiceFactory } = await import('./utils/serviceFactory');
    const services = await ServiceFactory.createFromRequest(req);
    const gmail = await services.getGmailService();

    const emails = await gmail.getRecentEmails(20);
    console.log(`âœ… Retrieved ${emails.length} emails from Gmail`);

    // Parse and save emails with user context, then process for meetings
    let savedCount = 0;
    let meetingProcessingResults: any[] = [];
    
    for (const email of emails) {
      try {
        const parsedEmail = gmail.parseEmail(email);
        
        // Check if email already exists for this user
        const exists = await emailModel.emailExists(parsedEmail.id, userId);
        let emailDbId: number | undefined;
        
        if (!exists) {
          const savedEmail = await emailModel.saveEmail(parsedEmail, userId);
          emailDbId = savedEmail;
          savedCount++;
          
          // ðŸš€ PHASE 3: Process new emails through intelligent router
          if (emailDbId) {
            try {
              console.log(`ðŸ§  [MANUAL FETCH] Routing email ${parsedEmail.id} through intelligent router...`);
              const routingResult = await intelligentEmailRouter.routeEmail(
                parsedEmail, 
                userId, 
                emailDbId
              );
              
              // Convert routing result to meeting pipeline format for backward compatibility
              if (routingResult.meetingResult) {
                meetingProcessingResults.push(routingResult.meetingResult);
              } else {
                // Create a compatible result for non-meeting emails
                meetingProcessingResults.push({
                  emailId: parsedEmail.id,
                  userId,
                  isMeetingRequest: false,
                  confidence: routingResult.routingDecision.confidence,
                  processingTime: routingResult.totalProcessingTime,
                  status: routingResult.status === 'success' ? 'processed' : 'error',
                  reason: `Intelligent router: ${routingResult.routingDecision.reasoning}`
                });
              }
              
              console.log(`âœ… [MANUAL FETCH] Email routed to ${routingResult.routingDecision.route.toUpperCase()} pipeline`);
              
            } catch (routingError) {
              console.error(`âŒ [INTELLIGENT ROUTER] Error processing email ${parsedEmail.id}:`, routingError);
            }
          }
        }
      } catch (error) {
        console.error(`Error processing email ${email.id}:`, error);
      }
    }

    console.log(`âœ… Saved ${savedCount} new emails to database for user ${userId.substring(0, 8)}...`);
    
    // Log meeting detection results
    const meetingsDetected = meetingProcessingResults.filter(r => r.isMeetingRequest).length;
    if (meetingProcessingResults.length > 0) {
      console.log(`ðŸ” [MEETING PIPELINE] Processed ${meetingProcessingResults.length} emails, found ${meetingsDetected} meeting requests`);
    }
    
    const stats = await emailModel.getEmailStats(userId);
    
    res.json({
      message: 'Emails fetched successfully',
      retrieved: emails.length,
      saved: savedCount,
      meetingDetection: {
        processed: meetingProcessingResults.length,
        meetingsFound: meetingsDetected,
        successRate: meetingProcessingResults.length > 0 
          ? Math.round((meetingsDetected / meetingProcessingResults.length) * 100) 
          : 0
      },
      stats,
      userId: userId.substring(0, 8) + '...'
    });
  } catch (error) {
    console.error('âŒ Error fetching emails:', error);
    res.status(500).json({ error: 'Failed to fetch emails' });
  }
});

app.get('/emails', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const emails = await emailModel.getRecentEmails(20, userId);
    const stats = await emailModel.getEmailStats(userId);

    res.json({
      emails: emails.map(email => ({
        id: email.id,
        subject: email.subject,
        from: email.from_email,
        date: email.received_at,
        isRead: email.is_read,
        preview: email.body?.substring(0, 150) + '...',
      })),
      stats
    });
  } catch (error) {
    console.error('âŒ Error retrieving emails:', error);
    res.status(500).json({ error: 'Failed to retrieve emails' });
  }
});

// Semantic Search API endpoint
app.get('/emails/search', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const { q, limit, threshold, mode } = req.query;

    // Validate query parameter
    if (!q || typeof q !== 'string' || q.trim().length === 0) {
      return res.status(400).json({
        error: 'Missing or invalid query parameter',
        message: 'Please provide a non-empty "q" query parameter'
      });
    }

    const query = q.trim();

    // Validate limit
    const searchLimit = limit ? parseInt(limit as string) : 20;
    if (isNaN(searchLimit) || searchLimit < 1 || searchLimit > 100) {
      return res.status(400).json({
        error: 'Invalid limit parameter',
        message: 'Limit must be between 1 and 100'
      });
    }

    // Validate threshold
    const searchThreshold = threshold ? parseFloat(threshold as string) : 0.8;
    if (isNaN(searchThreshold) || searchThreshold < 0 || searchThreshold > 1) {
      return res.status(400).json({
        error: 'Invalid threshold parameter',
        message: 'Threshold must be between 0 and 1'
      });
    }

    console.log(`ðŸ” Search request: "${query}" (user: ${userId}, limit: ${searchLimit}, threshold: ${searchThreshold})`);

    // Check embedding coverage first
    const stats = await semanticSearchService.getSearchStats(userId);

    if (stats.emailsWithEmbeddings === 0) {
      return res.status(503).json({
        error: 'Search not ready',
        message: 'No emails have been indexed yet. Please run the embedding backfill script first.',
        stats
      });
    }

    // Perform search
    const startTime = Date.now();
    let results;

    if (mode === 'semantic') {
      // Semantic-only mode
      results = await semanticSearchService.semanticSearch(query, {
        userId,
        limit: searchLimit,
        threshold: searchThreshold
      });
    } else {
      // Hybrid mode (default)
      results = await semanticSearchService.search(query, {
        userId,
        limit: searchLimit,
        threshold: searchThreshold
      });
    }

    const queryTime = Date.now() - startTime;

    res.json({
      query,
      results: results.map(r => ({
        id: r.id,
        gmail_id: r.gmail_id,
        subject: r.subject,
        from: r.from_email,
        to: r.to_email,
        body_preview: r.body,
        received_at: r.received_at,
        relevance_score: r.relevance_score,
        match_type: r.match_type,
        match_explanation: semanticSearchService.explainMatch(r)
      })),
      metadata: {
        total_results: results.length,
        query_time_ms: queryTime,
        threshold_used: searchThreshold,
        search_mode: mode || 'hybrid',
        ...stats
      }
    });

  } catch (error: any) {
    console.error('âŒ Search error:', error);
    res.status(500).json({
      error: 'Search failed',
      message: error.message
    });
  }
});

// Search stats endpoint (for debugging)
app.get('/emails/search/stats', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const stats = await semanticSearchService.getSearchStats(userId);

    res.json({
      ...stats,
      ready: stats.emailsWithEmbeddings > 0,
      message: stats.emailsWithEmbeddings === 0
        ? 'Run embedding backfill to enable search'
        : `Search ready with ${stats.emailsWithEmbeddings} indexed emails`
    });
  } catch (error: any) {
    console.error('âŒ Stats error:', error);
    res.status(500).json({ error: 'Failed to get stats' });
  }
});

// ============================================================================
// Voice AI API Endpoints
// ============================================================================

/**
 * POST /voice/transcribe
 * Upload audio file and get transcription (Speech-to-Text)
 *
 * Body: multipart/form-data with 'audio' file field
 * Supported formats: mp3, wav, webm, mp4, m4a, ogg, flac
 * Max size: 25 MB
 */
app.post('/voice/transcribe', authMiddleware.authenticate, audioUpload.single('audio'), async (req, res) => {
  try {
    const userId = getUserId(req);

    if (!req.file) {
      return res.status(400).json({
        error: 'Missing audio file',
        message: 'Please upload an audio file in the "audio" field'
      });
    }

    console.log(`ðŸŽ¤ [VOICE API] Transcription request from user: ${userId}`);
    console.log(`ðŸ“ [VOICE API] File: ${req.file.originalname}, Size: ${(req.file.size / 1024).toFixed(2)} KB`);

    // Call voice service
    const result = await voiceService.speechToText(
      req.file.buffer,
      req.file.originalname,
      {
        language: req.body.language, // Optional: 'en', 'es', etc.
        temperature: req.body.temperature ? parseFloat(req.body.temperature) : 0,
      }
    );

    res.json({
      success: true,
      transcription: result.text,
      language: result.language,
      metadata: {
        filename: req.file.originalname,
        fileSize: req.file.size,
        duration: result.duration,
      }
    });

  } catch (error: any) {
    console.error('âŒ [VOICE API] Transcription error:', error);

    res.status(500).json({
      error: 'Transcription failed',
      message: error.message || 'Failed to transcribe audio'
    });
  }
});

/**
 * POST /voice/speak
 * Convert text to speech (Text-to-Speech)
 *
 * Body: JSON with 'text' field
 * Optional: voice, speed, model, format
 * Returns: Audio file (mp3 by default)
 */
app.post('/voice/speak', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const { text, voice, speed, model, format } = req.body;

    if (!text || typeof text !== 'string' || text.trim().length === 0) {
      return res.status(400).json({
        error: 'Missing text',
        message: 'Please provide a non-empty "text" field'
      });
    }

    console.log(`ðŸ”Š [VOICE API] Text-to-speech request from user: ${userId}`);
    console.log(`ðŸ“ [VOICE API] Text length: ${text.length} characters`);

    // Call voice service
    const audioBuffer = await voiceService.textToSpeech(text, {
      voice: voice || 'nova',
      speed: speed ? parseFloat(speed) : 1.0,
      model: model || 'tts-1',
      response_format: format || 'mp3',
    });

    // Set appropriate headers for audio response
    const contentType = format === 'wav' ? 'audio/wav' :
                       format === 'ogg' ? 'audio/ogg' :
                       format === 'flac' ? 'audio/flac' :
                       'audio/mpeg'; // mp3 default

    res.set({
      'Content-Type': contentType,
      'Content-Length': audioBuffer.length,
      'Content-Disposition': `attachment; filename="speech.${format || 'mp3'}"`,
    });

    res.send(audioBuffer);

  } catch (error: any) {
    console.error('âŒ [VOICE API] Text-to-speech error:', error);

    res.status(500).json({
      error: 'Text-to-speech failed',
      message: error.message || 'Failed to generate speech'
    });
  }
});

/**
 * POST /voice/search
 * Voice-powered semantic search (Full pipeline: Speech â†’ Search â†’ Speech)
 *
 * Body: multipart/form-data with 'audio' file field
 * Returns: JSON with transcription, search results, and response audio
 */
app.post('/voice/search', authMiddleware.authenticate, audioUpload.single('audio'), async (req, res) => {
  try {
    const userId = getUserId(req);

    if (!req.file) {
      return res.status(400).json({
        error: 'Missing audio file',
        message: 'Please upload an audio file in the "audio" field'
      });
    }

    console.log(`ðŸŽ¯ [VOICE API] Voice search request from user: ${userId}`);
    console.log(`ðŸ“ [VOICE API] File: ${req.file.originalname}`);

    // Execute full voice query pipeline
    const result = await voiceService.processVoiceQuery(
      req.file.buffer,
      req.file.originalname,
      // Inject semantic search function
      async (query: string) => {
        const searchResults = await semanticSearchService.search(query, {
          userId,
          limit: 10,
          threshold: 0.4,
        });

        return {
          results: searchResults.map(r => ({
            id: r.id,
            gmail_id: r.gmail_id,
            subject: r.subject,
            from: r.from_email,
            body_preview: r.body.substring(0, 200),
            relevance_score: r.relevance_score,
            match_type: r.match_type,
          })),
        };
      }
    );

    // Return JSON response with audio as base64
    res.json({
      success: true,
      query: result.transcribedQuery,
      enhancedQuery: result.enhancedQuery, // Show what was actually searched
      responseText: result.responseText,
      searchResults: result.searchResults,
      audioResponse: result.responseAudio.toString('base64'), // Base64 encoded audio
      metadata: {
        filename: req.file.originalname,
        fileSize: req.file.size,
        audioFormat: 'mp3',
      }
    });

  } catch (error: any) {
    console.error('âŒ [VOICE API] Voice search error:', error);

    res.status(500).json({
      error: 'Voice search failed',
      message: error.message || 'Failed to process voice search'
    });
  }
});

/**
 * GET /voice/health
 * Check voice service health status
 */
app.get('/voice/health', authMiddleware.authenticate, async (req, res) => {
  try {
    const health = await voiceService.getHealthStatus();

    res.json({
      ...health,
      endpoints: {
        transcribe: '/voice/transcribe',
        speak: '/voice/speak',
        search: '/voice/search',
      }
    });
  } catch (error: any) {
    res.status(500).json({
      status: 'unhealthy',
      error: error.message
    });
  }
});

// ============================================================================
// Promotional Emails API endpoints

// Meeting Pipeline API Endpoints
app.get('/meetings', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const { status, urgency, meetingType, limit = 20, offset = 0 } = req.query;
    const statusFilter = status as "pending" | "scheduled" | "declined" | "cancelled" | undefined;
    const urgencyFilter = urgency as "high" | "medium" | "low" | undefined;
    const meetingTypeFilter = meetingType as "urgent" | "regular" | "flexible" | "recurring" | undefined;
    const limitNum = parseInt(typeof limit === "string" ? limit : "20");
    const offsetNum = parseInt(typeof offset === "string" ? offset : "0");
    
    console.log(`ðŸ“‹ Fetching meeting requests for user: ${userId.substring(0, 8)}...`);
    
    const meetings = await meetingPipelineService.getMeetingRequests(userId, {
      status: statusFilter,
      urgency: urgencyFilter,
      meetingType: meetingTypeFilter,
      limit: limitNum,
      offset: offsetNum
    });
    
    const stats = await meetingPipelineService.getMeetingStats(userId);
    
    console.log(`âœ… Retrieved ${meetings.length} meeting requests`);
    
    res.json({
      message: 'Meeting requests fetched successfully',
      meetings,
      stats,
      pagination: {
        limit: limitNum,
        offset: offsetNum,
        total: stats.total
      }
    });
  } catch (error) {
    console.error('âŒ Error fetching meeting requests:', error);
    res.status(500).json({ error: 'Failed to fetch meeting requests' });
  }
});

app.get('/meetings/stats', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    
    const stats = await meetingPipelineService.getMeetingStats(userId);
    
    res.json({
      message: 'Meeting statistics fetched successfully',
      stats
    });
  } catch (error) {
    console.error('âŒ Error fetching meeting stats:', error);
    res.status(500).json({ error: 'Failed to fetch meeting statistics' });
  }
});

app.get('/meetings/pipeline/health', authMiddleware.authenticate, async (req, res) => {
  try {
    const health = await meetingPipelineService.healthCheck();
    
    res.json({
      message: 'Meeting pipeline health check',
      health,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('âŒ Error checking meeting pipeline health:', error);
    res.status(500).json({ error: 'Meeting pipeline health check failed' });
  }
});

app.post('/meetings/:id/status', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const meetingId = parseInt(req.params.id);
    const { status } = req.body;
    
    if (!['pending', 'scheduled', 'declined', 'cancelled'].includes(status)) {
      return res.status(400).json({ error: 'Invalid status. Must be: pending, scheduled, declined, or cancelled' });
    }
    
    console.log(`ðŸ“ Updating meeting ${meetingId} status to: ${status}`);
    
    // Update meeting status in database
    const result = await pool.query(
      'UPDATE meeting_requests SET status = $1, updated_at = NOW() WHERE id = $2 AND user_id = $3 RETURNING *',
      [status, meetingId, userId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Meeting request not found' });
    }
    
    console.log(`âœ… Meeting status updated successfully`);
    
    res.json({
      message: 'Meeting status updated successfully',
      meeting: result.rows[0]
    });
  } catch (error) {
    console.error('âŒ Error updating meeting status:', error);
    res.status(500).json({ error: 'Failed to update meeting status' });
  }
});


app.get('/promotional-emails', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const { is_read, classification_reason, from_email, limit = 50, offset = 0 } = req.query;

    const filters = {
      is_read: is_read ? is_read === 'true' : undefined,
      classification_reason: classification_reason as string,
      from_email: from_email as string,
      limit: parseInt(limit as string),
      offset: parseInt(offset as string)
    };

    const emails = await promotionalEmailModel.getPromotionalEmailsForUser(userId, filters);
    const stats = await promotionalEmailModel.getPromotionalEmailStats(userId);

    res.json({
      emails: emails.map(email => ({
        id: email.id,
        subject: email.subject,
        from_email: email.from_email,
        date: email.received_at,
        is_read: email.is_read,
        classification_reason: email.classification_reason,
        preview: email.body?.substring(0, 150) + '...',
      })),
      stats,
      filters
    });
  } catch (error) {
    console.error('âŒ Error retrieving promotional emails:', error);
    res.status(500).json({ error: 'Failed to retrieve promotional emails' });
  }
});

app.post('/promotional-emails/:id/mark-read', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const { id } = req.params;
    const emailId = parseInt(id);

    if (isNaN(emailId)) {
      return res.status(400).json({ error: 'Invalid email ID' });
    }

    const success = await promotionalEmailModel.markAsRead(emailId, userId);
    
    if (success) {
      res.json({ success: true, message: 'Email marked as read' });
    } else {
      res.status(404).json({ error: 'Email not found or already processed' });
    }
  } catch (error) {
    console.error('âŒ Error marking promotional email as read:', error);
    res.status(500).json({ error: 'Failed to mark email as read' });
  }
});

app.delete('/promotional-emails/:id', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const { id } = req.params;
    const emailId = parseInt(id);

    if (isNaN(emailId)) {
      return res.status(400).json({ error: 'Invalid email ID' });
    }

    const success = await promotionalEmailModel.deletePromotionalEmail(emailId, userId);
    
    if (success) {
      res.json({ success: true, message: 'Email deleted successfully' });
    } else {
      res.status(404).json({ error: 'Email not found or already deleted' });
    }
  } catch (error) {
    console.error('âŒ Error deleting promotional email:', error);
    res.status(500).json({ error: 'Failed to delete email' });
  }
});

app.get('/promotional-emails/stats', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const stats = await promotionalEmailModel.getPromotionalEmailStats(userId);
    
    res.json({ stats });
  } catch (error) {
    console.error('âŒ Error retrieving promotional email stats:', error);
    res.status(500).json({ error: 'Failed to retrieve promotional email statistics' });
  }
});

// Phase 2.1: Real Email Analysis endpoints
app.post('/ai/analyze-tone-real', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    console.log(`ðŸ§  Analyzing tone from real sent emails for user: ${userId.substring(0, 8)}...`);

    // âœ… SECURITY FIX: Use isolated service container
    const { ServiceFactory } = await import('./utils/serviceFactory');
    const services = await ServiceFactory.createFromRequest(req);
    const gmail = await services.getGmailService();

    // Fetch real sent emails from Gmail with user context validation
    const sentEmails = await gmail.getSentEmailsForUser(userId, 50);
    console.log(`ðŸ“¤ Retrieved ${sentEmails.length} sent emails from Gmail`);

    // Filter emails for tone analysis
    const filteredEmails = gmail.filterSentEmailsForToneAnalysis(sentEmails);

    if (filteredEmails.length === 0) {
      return res.status(400).json({
        error: 'No suitable emails found for tone analysis',
        suggestion: 'Try sending more emails or check if your sent folder has content'
      });
    }

    // Convert to format expected by AI service
    const emailsForAnalysis = filteredEmails.map(email => {
      const parsed = gmail.parseEmail(email);
      return {
        subject: parsed.subject,
        body: parsed.body
      };
    });
    
    // Perform real tone analysis
    const toneAnalysis = await aiService.analyzeToneFromRealEmails(emailsForAnalysis);
    
    // Save to database with real data flag
    const savedProfileId = await draftModel.saveToneProfile({
      profile_text: toneAnalysis.profile,
      confidence_score: toneAnalysis.confidence,
      email_samples_analyzed: emailsForAnalysis.length,
      insights: toneAnalysis.insights,
      is_real_data: true
    });
    
    res.json({
      message: 'Real tone analysis completed successfully',
      profileId: savedProfileId,
      samplesAnalyzed: emailsForAnalysis.length,
      totalSentEmails: sentEmails.length,
      filteredEmails: filteredEmails.length,
      confidence: toneAnalysis.confidence,
      toneProfilePreview: toneAnalysis.profile.substring(0, 300) + '...',
      insights: toneAnalysis.insights.substring(0, 200) + '...'
    });
  } catch (error) {
    console.error('âŒ Error analyzing real tone:', error);
    res.status(500).json({ error: 'Failed to analyze tone from real emails' });
  }
});

// Keep the old mock version for fallback
app.post('/ai/analyze-tone', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    console.log(`ðŸ§  Analyzing tone from mock emails (fallback) for user: ${userId.substring(0, 8)}...`);
    
    const mockSentEmails = [
      { subject: 'Re: Meeting tomorrow', body: 'Hi John, That works perfectly for me. I\'ll see you at 3pm in the conference room. Thanks!' },
      { subject: 'Thank you', body: 'Hi Sarah, Thank you so much for your help with the project. I really appreciate your time and expertise.' },
      { subject: 'Quick question', body: 'Hey team, Just wanted to check if we\'re still on track for the deadline. Let me know if you need any help!' }
    ];
    
    const toneProfile = await aiService.analyzeToneFromEmails(mockSentEmails);
    
    const savedProfileId = await draftModel.saveToneProfile({
      profile_text: toneProfile,
      confidence_score: 70, // Lower confidence for mock data
      email_samples_analyzed: mockSentEmails.length,
      insights: 'Based on mock email samples - use real analysis for better results',
      is_real_data: false
    });
    
    res.json({
      message: 'Tone analysis completed (using mock data)',
      profileId: savedProfileId,
      samplesAnalyzed: mockSentEmails.length,
      confidence: 70,
      toneProfile: toneProfile.substring(0, 200) + '...',
      warning: 'This used mock data. Use /ai/analyze-tone-real for authentic results'
    });
  } catch (error) {
    console.error('âŒ Error analyzing tone:', error);
    res.status(500).json({ error: 'Failed to analyze tone' });
  }
});

// Tone profile management endpoints
app.get('/tone-profiles', authMiddleware.authenticate, async (req, res) => {
  try {
    const profiles = await draftModel.getToneProfileHistory(5);
    
    res.json({
      profiles: profiles.map(profile => ({
        id: profile.id,
        isRealData: profile.is_real_data,
        confidence: profile.confidence_score,
        emailSamples: profile.email_samples_analyzed,
        createdAt: profile.created_at,
        profilePreview: profile.profile_text.substring(0, 200) + '...',
        insightsPreview: profile.insights?.substring(0, 100) + '...' || 'No insights available'
      })),
      total: profiles.length,
      latestReal: profiles.find(p => p.is_real_data) || null
    });
  } catch (error) {
    console.error('âŒ Error fetching tone profiles:', error);
    res.status(500).json({ error: 'Failed to fetch tone profiles' });
  }
});

app.get('/tone-profiles/:id', async (req, res) => {
  try {
    const profileId = parseInt(req.params.id);
    const profiles = await draftModel.getToneProfileHistory(20);
    const profile = profiles.find(p => p.id === profileId);
    
    if (!profile) {
      return res.status(404).json({ error: 'Tone profile not found' });
    }
    
    res.json(profile);
  } catch (error) {
    console.error('âŒ Error fetching tone profile:', error);
    res.status(500).json({ error: 'Failed to fetch tone profile' });
  }
});

app.post('/ai/refresh-tone', authMiddleware.authenticate, async (req, res) => {
  try {
    const { forceRefresh } = req.body;
    const userId = getUserId(req);
    
    // Check if we have a recent real tone profile (within last 7 days)
    const existingProfile = await draftModel.getLatestRealToneProfile();
    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    
    if (!forceRefresh && existingProfile && existingProfile.created_at > sevenDaysAgo) {
      return res.json({
        message: 'Recent tone profile already exists',
        profileId: existingProfile.id,
        createdAt: existingProfile.created_at,
        confidence: existingProfile.confidence_score,
        samplesAnalyzed: existingProfile.email_samples_analyzed,
        suggestion: 'Use forceRefresh: true to create a new profile anyway'
      });
    }
    
    console.log('ðŸ”„ Refreshing tone analysis with latest sent emails...');

    // âœ… SECURITY FIX: Use isolated service container
    const { ServiceFactory } = await import('./utils/serviceFactory');
    const services = await ServiceFactory.createFromRequest(req);
    const gmail = await services.getGmailService();

    // Fetch and analyze fresh sent emails with user context validation
    const sentEmails = await gmail.getSentEmailsForUser(userId, 50);
    const filteredEmails = gmail.filterSentEmailsForToneAnalysis(sentEmails);

    if (filteredEmails.length < 5) {
      return res.status(400).json({
        error: 'Insufficient emails for tone analysis',
        found: filteredEmails.length,
        minimum: 5,
        suggestion: 'Send more emails and try again later'
      });
    }

    const emailsForAnalysis = filteredEmails.map(email => {
      const parsed = gmail.parseEmail(email);
      return {
        subject: parsed.subject,
        body: parsed.body
      };
    });
    
    const toneAnalysis = await aiService.analyzeToneFromRealEmails(emailsForAnalysis);
    
    const savedProfileId = await draftModel.saveToneProfile({
      profile_text: toneAnalysis.profile,
      confidence_score: toneAnalysis.confidence,
      email_samples_analyzed: emailsForAnalysis.length,
      insights: toneAnalysis.insights,
      is_real_data: true
    });
    
    res.json({
      message: 'Tone profile refreshed successfully',
      profileId: savedProfileId,
      previousProfile: existingProfile?.id || null,
      samplesAnalyzed: emailsForAnalysis.length,
      confidence: toneAnalysis.confidence,
      improvementNotes: existingProfile ? 
        `Updated from ${existingProfile.email_samples_analyzed} to ${emailsForAnalysis.length} email samples` :
        'First real tone profile created'
    });
  } catch (error) {
    console.error('âŒ Error refreshing tone:', error);
    res.status(500).json({ error: 'Failed to refresh tone profile' });
  }
});

app.post('/ai/categorize-emails', authMiddleware.authenticate, async (req, res) => {
  try {
    console.log('ðŸ·ï¸ Categorizing recent emails...');
    
    const emails = await emailModel.getRecentEmails(10);
    let categorizedCount = 0;
    
    for (const email of emails) {
      if (!email.category) {
        const category = await aiService.categorizeEmail(
          email.subject || '',
          email.body || '',
          email.from_email
        );
        
        // Update email with category
        await emailModel.updateEmail(email.id, { category });
        categorizedCount++;
      }
    }
    
    res.json({
      message: 'Email categorization completed',
      categorized: categorizedCount,
      total: emails.length
    });
  } catch (error) {
    console.error('âŒ Error categorizing emails:', error);
    res.status(500).json({ error: 'Failed to categorize emails' });
  }
});

app.post('/ai/generate-drafts', authMiddleware.authenticate, async (req, res) => {
  try {
    console.log('âœ¨ Generating drafts for recent emails...');
    
    // Get recent unread emails without drafts
    const emails = await emailModel.getRecentEmails(5);
    const unprocessedEmails = emails.filter(email => !email.has_draft && !email.is_read);
    
    if (unprocessedEmails.length === 0) {
      return res.json({
        message: 'No unprocessed emails found',
        generated: 0
      });
    }
    
    // Get the latest tone profile
    const toneProfile = await draftModel.getLatestToneProfile();
    if (!toneProfile) {
      return res.status(400).json({ 
        error: 'No tone profile found. Please run tone analysis first.' 
      });
    }
    
    let generatedCount = 0;
    const drafts = [];
    
    for (const email of unprocessedEmails.slice(0, 3)) { // Limit to 3 for testing
      try {
        // Categorize email if not already categorized
        const category = email.category || await aiService.categorizeEmail(
          email.subject || '',
          email.body || '',
          email.from_email
        );
        
        // Generate draft
        const draft = await aiService.generateDraft(
          {
            subject: email.subject || '',
            body: email.body || '',
            from: email.from_email
          },
          category,
          toneProfile.profile_text
        );
        
        // Score the draft
        const qualityScore = await aiService.scoreDraft(
          draft.body,
          email.body || '',
          category
        );
        
        // Save draft to database
        const draftId = await draftModel.saveDraft({
          email_id: email.id,
          subject: draft.subject,
          body: draft.body,
          category,
          confidence_score: draft.confidence,
          quality_score: qualityScore
        });
        
        drafts.push({
          id: draftId,
          emailSubject: email.subject,
          category,
          confidence: draft.confidence,
          qualityScore
        });
        
        generatedCount++;
      } catch (error) {
        console.error(`Error processing email ${email.id}:`, error);
      }
    }
    
    res.json({
      message: 'Draft generation completed',
      generated: generatedCount,
      drafts
    });
  } catch (error) {
    console.error('âŒ Error generating drafts:', error);
    res.status(500).json({ error: 'Failed to generate drafts' });
  }
});

// Legacy endpoint - protected for security (consider deprecating in favor of /auto-drafts)
app.get('/drafts', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);

    // Get pending drafts with user filtering via email join
    const query = `
      SELECT d.*, e.subject as original_subject, e.from_email
      FROM drafts d
      JOIN emails e ON d.email_id = e.id
      WHERE d.status IN ('pending', 'pending_user_action')
        AND e.user_id = $1
      ORDER BY d.created_at DESC
      LIMIT 20
    `;

    const result = await pool.query(query, [userId]);
    const drafts = result.rows;

    res.json({
      drafts: drafts.map(draft => ({
        id: draft.id,
        originalSubject: draft.original_subject,
        draftSubject: draft.subject,
        from: draft.from_email,
        category: draft.category,
        confidence: draft.confidence_score,
        qualityScore: draft.quality_score,
        status: draft.status,
        createdAt: draft.created_at,
        preview: draft.body.substring(0, 150) + '...'
      })),
      total: drafts.length
    });
  } catch (error) {
    console.error('âŒ Error fetching drafts:', error);
    res.status(500).json({ error: 'Failed to fetch drafts' });
  }
});

// Legacy endpoint - protected with user isolation (consider deprecating in favor of /auto-drafts/:id)
app.get('/drafts/:id', authMiddleware.authenticate, async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    const userId = getUserId(req);

    // Get draft by ID with user verification via email join
    const query = `
      SELECT d.* FROM drafts d
      JOIN emails e ON d.email_id = e.id
      WHERE d.id = $1 AND e.user_id = $2
    `;
    const result = await pool.query(query, [draftId, userId]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Draft not found or access denied' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error('âŒ Error fetching draft:', error);
    res.status(500).json({ error: 'Failed to fetch draft' });
  }
});

// ðŸš€ Phase 1: Auto-Generated Draft Management API Endpoints

// GET /auto-drafts - List all auto-generated drafts with pagination (USER-FILTERED)
app.get('/auto-drafts', authMiddleware.authenticate, async (req, res) => {
  try {
    console.log('ðŸ”„ Fetching auto-drafts with email data...');
    const limit = parseInt(req.query.limit as string) || 20;
    const status = req.query.status as string;
    const userId = req.userId; // Get user ID from auth middleware

    if (!userId) {
      return res.status(401).json({ error: 'User authentication required' });
    }

    let drafts;
    if (status === 'pending') {
      drafts = await autoGeneratedDraftModel.getPendingDraftsWithEmails(limit, userId);
    } else {
      // For now, just get pending drafts with email data for the specific user
      drafts = await autoGeneratedDraftModel.getPendingDraftsWithEmails(limit, userId);
    }

    res.json({
      message: 'Auto-generated drafts retrieved successfully',
      drafts: drafts.map(draft => ({
        id: draft.id,
        draftId: draft.draft_id,
        originalEmailId: draft.original_email_id,
        subject: draft.subject,
        body: draft.body,
        tone: draft.tone,
        urgencyLevel: draft.urgency_level,
        contextUsed: draft.context_used,
        relationshipType: draft.relationship_type,
        status: draft.status,
        createdAt: draft.created_at,
        processingTime: draft.processing_time_ms ? `${draft.processing_time_ms}ms` : null,
        // Include original email data
        originalEmail: {
          subject: draft.original_subject,
          from: draft.original_from,
          date: draft.original_date,
          isRead: draft.original_is_read,
          preview: draft.original_preview,
          gmailId: draft.original_gmail_id,
          body: draft.original_preview // Use the full preview as body for frontend
        }
      })),
      total: drafts.length,
      userId: userId.substring(0, 8) + '...' // For debugging
    });
  } catch (error) {
    console.error('âŒ Error fetching auto-generated drafts:', error);
    res.status(500).json({ error: 'Failed to fetch auto-generated drafts' });
  }
});

// GET /auto-drafts/:id - Get specific auto-generated draft with metadata (USER-FILTERED)
app.get('/auto-drafts/:id', authMiddleware.authenticate, async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    const userId = req.userId;
    
    if (!userId) {
      return res.status(401).json({ error: 'User authentication required' });
    }
    
    const draft = await autoGeneratedDraftModel.getDraftById(draftId);
    
    if (!draft) {
      return res.status(404).json({ error: 'Auto-generated draft not found' });
    }
    
    // CRITICAL: Verify the draft belongs to the authenticated user
    if (draft.user_id !== userId) {
      return res.status(403).json({ error: 'Access denied: Draft belongs to another user' });
    }

    res.json({
      message: 'Auto-generated draft retrieved successfully',
      draft: {
        id: draft.id,
        draftId: draft.draft_id,
        originalEmailId: draft.original_email_id,
        subject: draft.subject,
        body: draft.body,
        tone: draft.tone,
        urgencyLevel: draft.urgency_level,
        contextUsed: draft.context_used,
        relationshipType: draft.relationship_type,
        status: draft.status,
        createdAt: draft.created_at,
        reviewedAt: draft.reviewed_at,
        sentAt: draft.sent_at,
        userEdited: draft.user_edited,
        editCount: draft.edit_count,
        processingTime: draft.processing_time_ms
      }
    });
  } catch (error) {
    console.error('âŒ Error fetching auto-generated draft:', error);
    res.status(500).json({ error: 'Failed to fetch auto-generated draft' });
  }
});

// PUT /auto-drafts/:id - Edit draft content (triggers learning system)
app.put('/auto-drafts/:id', authMiddleware.authenticate, async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    const { subject, body, status } = req.body;
    const userId = req.userId;
    
    if (!userId) {
      return res.status(401).json({ error: 'User authentication required' });
    }
    
    const existingDraft = await autoGeneratedDraftModel.getDraftById(draftId);
    if (!existingDraft) {
      return res.status(404).json({ error: 'Auto-generated draft not found' });
    }
    
    // CRITICAL: Verify the draft belongs to the authenticated user
    if (existingDraft.user_id !== userId) {
      return res.status(403).json({ error: 'Access denied: Draft belongs to another user' });
    }

    // Store original content for learning analysis
    const originalSubject = existingDraft.subject || '';
    const originalBody = existingDraft.body || '';
    const newSubject = subject || existingDraft.subject;
    const newBody = body || existingDraft.body;
    
    // Check if content actually changed
    const subjectChanged = subject && subject !== existingDraft.subject;
    const bodyChanged = body && body !== existingDraft.body;
    const contentChanged = subjectChanged || bodyChanged;

    // Update the draft content in the database
    const updateQuery = `
      UPDATE auto_generated_drafts 
      SET subject = $1, body = $2, user_edited = true, edit_count = edit_count + 1
      WHERE id = $3
    `;
    await pool.query(updateQuery, [newSubject, newBody, draftId]);

    // Update status if provided
    if (status && status !== existingDraft.status) {
      await autoGeneratedDraftModel.updateDraftStatus(draftId, status);
    }

    // ðŸ§  NEW: Trigger Learning Analysis (NON-BLOCKING)
    if (contentChanged) {
      // Run learning analysis asynchronously to not block the response
      setImmediate(async () => {
        try {
          console.log(`ðŸ§  Triggering learning analysis for draft ${draftId}...`);
          
          const originalContent = `Subject: ${originalSubject}\n\nBody: ${originalBody}`;
          const editedContent = `Subject: ${newSubject}\n\nBody: ${newBody}`;
          
          console.log(`ðŸ“ Original content length: ${originalContent.length} chars`);
          console.log(`âœï¸  Edited content length: ${editedContent.length} chars`);
          
          // Call the learning service to analyze the edit
          const analysisResult = await learningService.analyzeEdit(
            draftId.toString(), 
            originalContent, 
            editedContent,
            req.userId
          );
          
          console.log(`âœ… Learning analysis completed for draft ${draftId}:`);
          console.log(`   - Edit Type: ${analysisResult.editType}`);
          console.log(`   - Edit Percentage: ${analysisResult.editPercentage}%`);
          console.log(`   - Success Score: ${analysisResult.successScore}`);
          console.log(`   - Learning Insight: ${analysisResult.learningInsight}`);
          
        } catch (learningError) {
          // Learning failure should NOT affect the edit operation
          console.error('âš ï¸ Learning analysis failed (edit still succeeded):', learningError);
          console.error('   This is non-critical - user edit was saved successfully');
        }
      });
    } else {
      console.log(`â„¹ï¸ No content changes detected for draft ${draftId} - skipping learning analysis`);
    }

    // Return success response immediately (don't wait for learning)
    res.json({
      message: 'Auto-generated draft updated successfully',
      draftId: draftId,
      changes: {
        subjectChanged,
        bodyChanged,
        statusChanged: status && status !== existingDraft.status
      },
      learningTriggered: contentChanged // Let frontend know if learning was triggered
    });
  } catch (error) {
    console.error('âŒ Error updating auto-generated draft:', error);
    res.status(500).json({ error: 'Failed to update auto-generated draft' });
  }
});

// POST /auto-drafts/:id/send - Send draft as actual email
app.post('/auto-drafts/:id/send', authMiddleware.authenticate, async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    const userId = getUserId(req);
    
    // Get draft with original email data to determine recipient
    const draftWithEmail = await autoGeneratedDraftModel.getDraftByIdWithEmail(draftId);
    
    if (!draftWithEmail) {
      return res.status(404).json({ error: 'Auto-generated draft not found' });
    }

    if (draftWithEmail.status === 'sent') {
      return res.status(400).json({ error: 'Draft has already been sent' });
    }

    console.log(`ðŸ“¤ Sending draft ${draftId} via Gmail API...`);
    console.log(`ðŸ“§ To: ${draftWithEmail.original_from}`);
    console.log(`ðŸ“ Subject: ${draftWithEmail.subject}`);

    // âœ… SECURITY FIX: Use isolated service container
    const { ServiceFactory } = await import('./utils/serviceFactory');
    const services = await ServiceFactory.createFromRequest(req);
    const gmail = await services.getGmailService();

    // Send email via Gmail API with user context validation
    console.log(`ðŸ§µ [THREADING DEBUG] About to send email with threadId: ${draftWithEmail.original_thread_id ? draftWithEmail.original_thread_id : 'NULL/UNDEFINED'}`);
    const sendResult = await gmail.sendEmailForUser(
      userId,
      draftWithEmail.original_from, // Send to the original sender (reply)
      draftWithEmail.subject,
      draftWithEmail.body,
      draftWithEmail.original_thread_id // Include thread ID for proper threading
    );

    // Update draft status to sent
    await autoGeneratedDraftModel.updateDraftStatus(draftId, 'sent');

    // Check if this is a meeting response draft and handle calendar booking
    let calendarEventId = null;
    let calendarBooked = false;

    // NEW: Check for new draft-first meeting system
    if (draftWithEmail.relationship_type === 'meeting_response' && draftWithEmail.context_used) {
      try {
        const context = draftWithEmail.context_used;
        const actionTaken = context.actionTaken;

        console.log(`ðŸ“… Processing meeting response (${actionTaken}) for draft ${draftId}...`);

        // Only create calendar event for accepted meetings
        if (actionTaken === 'accepted' && context.meetingRequest?.preferredDates?.[0]) {
          const proposedTime = context.meetingRequest.preferredDates[0];
          const meetingTitle = context.originalEmail?.subject || 'Meeting';
          const senderEmail = context.originalEmail?.from;

          console.log(`ðŸ“… Creating calendar event for accepted meeting: ${meetingTitle}`);
          console.log(`ðŸ• Time: ${proposedTime}`);
          console.log(`ðŸ‘¤ With: ${senderEmail}`);

          // Create calendar event directly using calendar service
          try {
            // Initialize calendar service for this user (same way as meeting confirmation service)
            const { CalendarService } = await import('./services/calendar');
            const calendarService = new CalendarService();

            // Get user credentials and initialize calendar service
            const credentials = await tokenStorageService.getDecryptedCredentials(userId);
            if (!credentials) {
              throw new Error('No OAuth credentials found for user');
            }

            await calendarService.setStoredTokens(credentials.accessToken, credentials.refreshToken);

            // CRITICAL: Initialize calendar service with user timezone
            await calendarService.initializeForUser(userId);

            // Create calendar event with proper structure
            // Minimal validation - just check time exists and is parseable
            console.log(`ðŸ“… [VALIDATION] Checking proposed time: "${proposedTime}"`);

            if (!proposedTime || proposedTime === 'null' || proposedTime === 'undefined') {
              throw new Error('No meeting time found in email. Please specify a time.');
            }

            const startTime = new Date(proposedTime);

            // Only check if date is valid (not blocking any specific hours - people meet at all times)
            if (isNaN(startTime.getTime())) {
              throw new Error(`Could not parse meeting time: "${proposedTime}". Please check the time format.`);
            }

            console.log(`âœ… [VALIDATION] Meeting time is valid: ${startTime.toISOString()}`);
            const durationMinutes = Math.min(context.meetingRequest.duration || 60, 120); // Cap at 2 hours max
            console.log(`ðŸ“… [CALENDAR DEBUG] Duration calculation:`, {
              originalDuration: context.meetingRequest.duration,
              fallbackDuration: 60,
              maxCap: 120,
              finalDuration: durationMinutes,
              startTime: startTime.toISOString(),
              durationMs: durationMinutes * 60000
            });
            const endTime = new Date(startTime.getTime() + durationMinutes * 60000);

            const calendarEvent = {
              summary: meetingTitle,
              description: `Meeting confirmed via Chief AI Assistant\n\nOriginal request: ${context.meetingRequest.subject || 'Meeting request'}`,
              start: {
                dateTime: startTime.toISOString(),
                timeZone: 'America/Los_Angeles' // PST timezone to match existing system
              },
              end: {
                dateTime: endTime.toISOString(),
                timeZone: 'America/Los_Angeles' // PST timezone to match existing system
              },
              attendees: senderEmail ? [{ email: senderEmail }] : []
            };

            const eventResult = await calendarService.createCalendarEvent(calendarEvent);

            calendarEventId = eventResult.id;
            calendarBooked = true;
            console.log(`âœ… Calendar event created directly: ${calendarEventId}`);

          } catch (calendarError) {
            console.warn('âš ï¸ Failed to create calendar event (continuing with email send):', calendarError);
            // Don't fail the entire operation if calendar booking fails
          }
        } else {
          console.log(`ðŸ“ Meeting response type: ${actionTaken} - no calendar event needed`);
        }

      } catch (meetingError) {
        console.warn('âš ï¸ Failed to process meeting response (continuing with email send):', meetingError);
      }
    }

    // LEGACY: Support old meeting confirmation system for backward compatibility
    let meetingConfirmationId = null;
    if (draftWithEmail.context_used && draftWithEmail.context_used.meetingRequest && draftWithEmail.context_used.meetingRequest.id) {
      try {
        const meetingRequestId = draftWithEmail.context_used.meetingRequest.id;
        const selectedTimeSlot = draftWithEmail.context_used.meetingRequest.selectedTimeSlot;

        console.log(`ðŸ“… [LEGACY] Creating meeting confirmation for draft ${draftId}...`);

        const confirmation = await meetingConfirmationService.createMeetingConfirmation(
          `draft_${draftId}_${Date.now()}`,
          meetingRequestId,
          userId,
          selectedTimeSlot
        );

        meetingConfirmationId = confirmation.id;
        console.log(`âœ… [LEGACY] Meeting confirmation created: ${meetingConfirmationId}`);

      } catch (confirmationError) {
        console.warn('âš ï¸ Failed to create legacy meeting confirmation:', confirmationError);
      }
    }

    console.log(`âœ… Draft ${draftId} sent successfully via Gmail API`);
    console.log(`ðŸ“§ Gmail Message ID: ${sendResult.messageId}`);

    res.json({
      message: 'Auto-generated draft sent successfully via Gmail',
      draftId: draftId,
      subject: draftWithEmail.subject,
      sentAt: new Date(),
      gmailMessageId: sendResult.messageId,
      gmailThreadId: sendResult.threadId,
      // NEW: Calendar booking information
      calendarBooked: calendarBooked,
      calendarEventId: calendarEventId,
      // LEGACY: Meeting confirmation for old system
      meetingConfirmationId: meetingConfirmationId
    });
  } catch (error) {
    console.error('âŒ Error sending auto-generated draft:', error);
    
    // If Gmail API fails, still update status but mark as error
    try {
      const draftId = parseInt(req.params.id);
      await autoGeneratedDraftModel.updateDraftStatus(draftId, 'sent');
      console.log(`âš ï¸ Draft ${draftId} marked as sent despite Gmail API error`);
    } catch (updateError) {
      console.error('âŒ Error updating draft status after send failure:', updateError);
    }
    
    res.status(500).json({ 
      error: 'Failed to send auto-generated draft',
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

// POST /auto-drafts/:id/decline - Generate decline response for meeting
app.post('/auto-drafts/:id/decline', authMiddleware.authenticate, async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    const userId = getUserId(req);
    const { reason } = req.body;

    // Validate reason input
    if (!reason || typeof reason !== 'string' || reason.trim().length < 5) {
      return res.status(400).json({
        error: 'Decline reason is required (minimum 5 characters)'
      });
    }

    console.log(`ðŸš« [DECLINE] User ${userId} declining draft ${draftId}: "${reason.substring(0, 50)}..."`);

    // Get existing draft with original email context
    const existingDraft = await autoGeneratedDraftModel.getDraftByIdWithEmail(draftId);

    if (!existingDraft) {
      return res.status(404).json({ error: 'Draft not found' });
    }

    // Validate user owns this draft
    if (existingDraft.user_id !== userId) {
      return res.status(403).json({ error: 'Unauthorized to decline this draft' });
    }

    // Validate this is a meeting response
    if (existingDraft.relationship_type !== 'meeting_response') {
      return res.status(400).json({
        error: 'Can only decline meeting response drafts'
      });
    }

    // Extract meeting context
    const context = existingDraft.context_used;
    if (!context?.meetingRequest || !context?.originalEmail) {
      return res.status(400).json({
        error: 'Missing meeting context in draft'
      });
    }

    console.log(`ðŸ“§ [DECLINE] Original meeting from: ${context.originalEmail.from}`);
    console.log(`ðŸ“… [DECLINE] Meeting type: ${context.meetingRequest.type}`);

    // Get user's communication tone
    const getUserTone = async (userId: string): Promise<'professional' | 'casual' | 'friendly'> => {
      try {
        const result = await pool.query(`
          SELECT pattern_value, recommendation
          FROM learning_insights
          WHERE pattern_type = 'tone'
          AND user_id = $1
          AND confidence > 60
          ORDER BY success_rate DESC, created_at DESC
          LIMIT 1
        `, [userId]);

        if (result.rows.length > 0) {
          const toneData = result.rows[0];
          const patternValue = toneData.pattern_value?.toLowerCase() || '';
          const recommendation = toneData.recommendation?.toLowerCase() || '';

          if (patternValue.includes('casual') || recommendation.includes('casual')) return 'casual';
          if (patternValue.includes('friendly') || recommendation.includes('friendly')) return 'friendly';
          if (patternValue.includes('professional') || recommendation.includes('professional')) return 'professional';
        }

        return 'professional';
      } catch (error) {
        console.error('âŒ Error getting user tone:', error);
        return 'professional';
      }
    };

    const userTone = await getUserTone(userId);
    console.log(`ðŸŽ¨ [DECLINE] Using tone: ${userTone}`);

    // Get user's name for signature
    const getUserName = async (userId: string): Promise<string> => {
      try {
        const result = await pool.query(`
          SELECT first_name, last_name, full_name
          FROM user_gmail_tokens
          WHERE user_id = $1
        `, [userId]);

        if (result.rows.length > 0) {
          const userData = result.rows[0];
          // Use full_name if available, otherwise first_name, otherwise empty
          return userData.full_name || userData.first_name || '';
        }

        return '';
      } catch (error) {
        console.error('âŒ Error getting user name:', error);
        return '';
      }
    };

    const userName = await getUserName(userId);
    console.log(`ðŸ‘¤ [DECLINE] User name: ${userName || '(not set)'}`);

    // Build decline request for AI service
    const declineRequest: any = {
      action: 'decline',
      meetingRequest: context.meetingRequest,
      email: {
        id: context.originalEmail.gmailId || '',
        subject: context.originalEmail.subject || '',
        from: context.originalEmail.from || '',
        threadId: context.originalEmail.threadId || '',
        body: context.originalEmail.body || '',
        date: new Date(),
        to: '',
        snippet: ''
      },
      context: {
        senderRelationship: 'new_contact',
        isAvailable: false,
        userTone: userTone,
        meetingType: context.meetingRequest.type || 'regular',
        urgencyLevel: context.meetingRequest.urgency || 'medium'
      },
      declineReason: reason.trim(),
      userName: userName || undefined // Pass user's name to AI (or undefined if not set)
    };

    // Generate decline response using AI service (with fallback)
    const { MeetingAIContentService } = await import('./services/meetingAIContent');
    const aiContentService = new MeetingAIContentService(aiService);

    console.log(`ðŸ¤– [DECLINE] Generating AI decline response...`);
    const declineResponse = await aiContentService.generateEnhancedContent(declineRequest);

    let finalResponseText = declineResponse.responseText;
    let wasAIGenerated = declineResponse.aiGenerated;

    // Template fallback if AI fails
    if (declineResponse.fallbackUsed || !finalResponseText || finalResponseText.length < 20) {
      console.warn('âš ï¸ [DECLINE] AI generation failed, using template fallback');

      const generateDeclineTemplate = (tone: string, reason: string, name: string): string => {
        const greeting = tone === 'casual' ? 'Hi,' : 'Hello,';
        const closing = tone === 'casual' ? 'Best,' : 'Best regards,';

        return `${greeting}

Thank you for your meeting invitation. Unfortunately, I won't be able to make it as ${reason.toLowerCase()}.

I appreciate you thinking of me, and I hope we can connect another time.

${closing}${name ? '\n' + name : ''}`;
      };

      finalResponseText = generateDeclineTemplate(userTone, reason, userName);
      wasAIGenerated = false;
      console.log(`ðŸ“ [DECLINE] Using template fallback (${finalResponseText.length} chars)`);
    } else {
      console.log(`âœ… [DECLINE] AI generated response (${finalResponseText.length} chars, confidence: ${declineResponse.confidence})`);
    }

    // Safety: Remove any placeholder text if AI still included it
    if (userName) {
      finalResponseText = finalResponseText
        .replace(/\[Your [Nn]ame\]/g, userName)
        .replace(/\[your [Nn]ame\]/g, userName);

      // Log if we had to do replacement (means AI didn't follow instructions)
      if (finalResponseText.includes('[Your') || finalResponseText.includes('[your')) {
        console.warn('âš ï¸ [DECLINE] AI included placeholder despite instructions - replaced with actual name');
      }
    } else {
      // If no userName, just remove the placeholder entirely
      finalResponseText = finalResponseText
        .replace(/\[Your [Nn]ame\]\n?/g, '')
        .replace(/\[your [Nn]ame\]\n?/g, '');
    }

    // Create new decline draft
    let newDraftId: number;

    const updatedContext = {
      ...context,
      actionTaken: 'declined',
      declineReason: reason,
      previousDraftId: draftId,
      source: 'user_decline_request',
      aiGenerated: wasAIGenerated
    };

    const newDraftQuery = `
      INSERT INTO auto_generated_drafts (
        draft_id, original_email_id, subject, body, tone, urgency_level,
        context_used, relationship_type, status, user_id, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
      RETURNING id
    `;

    // Mark the old draft as superseded before creating new one
    await pool.query(
      `UPDATE auto_generated_drafts SET status = $1 WHERE id = $2`,
      ['superseded', draftId]
    );
    console.log(`ðŸ”„ [DECLINE] Marked old draft ${draftId} as superseded`);

    const result = await pool.query(newDraftQuery, [
      `decline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      existingDraft.original_email_id,
      existingDraft.subject,
      finalResponseText,
      userTone,
      existingDraft.urgency_level,
      JSON.stringify(updatedContext),
      'meeting_response',
      'pending',
      userId
    ]);

    newDraftId = result.rows[0].id;
    console.log(`âœ… [DECLINE] New decline draft created: ${newDraftId}`);

    res.json({
      message: 'Decline response generated successfully',
      newDraftId: newDraftId,
      responseText: finalResponseText,
      aiGenerated: wasAIGenerated
    });

  } catch (error) {
    console.error('âŒ [DECLINE] Error generating decline response:', error);
    res.status(500).json({
      error: 'Failed to generate decline response',
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

// DELETE /auto-drafts/:id - Delete unwanted draft (USER-PROTECTED)
app.delete('/auto-drafts/:id', authMiddleware.authenticate, async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    const userId = req.userId;

    // Verify authentication
    if (!userId) {
      return res.status(401).json({ error: 'User authentication required' });
    }

    const existingDraft = await autoGeneratedDraftModel.getDraftById(draftId);
    if (!existingDraft) {
      return res.status(404).json({ error: 'Auto-generated draft not found' });
    }

    // CRITICAL: Verify the draft belongs to the authenticated user
    if (existingDraft.user_id !== userId) {
      return res.status(403).json({ error: 'Access denied: Draft belongs to another user' });
    }

    await autoGeneratedDraftModel.updateDraftStatus(draftId, 'deleted');

    res.json({
      message: 'Auto-generated draft deleted successfully',
      draftId: draftId
    });
  } catch (error) {
    console.error('âŒ Error deleting auto-generated draft:', error);
    res.status(500).json({ error: 'Failed to delete auto-generated draft' });
  }
});

// POST /auto-drafts/:id/approve - Approve draft without changes (USER-PROTECTED)
app.post('/auto-drafts/:id/approve', authMiddleware.authenticate, async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    const userId = req.userId;

    // Verify authentication
    if (!userId) {
      return res.status(401).json({ error: 'User authentication required' });
    }

    const draft = await autoGeneratedDraftModel.getDraftById(draftId);

    if (!draft) {
      return res.status(404).json({ error: 'Auto-generated draft not found' });
    }

    // CRITICAL: Verify the draft belongs to the authenticated user
    if (draft.user_id !== userId) {
      return res.status(403).json({ error: 'Access denied: Draft belongs to another user' });
    }

    await autoGeneratedDraftModel.updateDraftStatus(draftId, 'reviewed');

    res.json({
      message: 'Auto-generated draft approved successfully',
      draftId: draftId,
      approvedAt: new Date()
    });
  } catch (error) {
    console.error('âŒ Error approving auto-generated draft:', error);
    res.status(500).json({ error: 'Failed to approve auto-generated draft' });
  }
});

// CLI testing function
export async function testPhase1() {
  console.log('\nðŸ§ª PHASE 1 TEST: Email Reading & Parsing\n');
  
  try {
    await initializeServices();
    
    console.log('ðŸ“Š Current email stats:');
    const stats = await emailModel.getEmailStats();
    console.log(`   Total emails in database: ${stats.total}`);
    console.log(`   Unread emails: ${stats.unread}`);
    
    console.log('\nðŸ“§ Recent emails in database:');
    const recentEmails = await emailModel.getRecentEmails(5);
    
    recentEmails.forEach((email, index) => {
      console.log(`\n${index + 1}. ${email.is_read ? 'âœ…' : 'ðŸ”´'} ${email.subject}`);
      console.log(`   From: ${email.from_email}`);
      console.log(`   Date: ${email.received_at.toLocaleDateString()}`);
      console.log(`   Preview: ${email.body?.substring(0, 100)}...`);
    });

    console.log('\nâœ… Phase 1 test completed successfully!');
    console.log('\nNext steps:');
    console.log('1. Start the server: npm run dev');
    console.log('2. Visit: http://localhost:3000/auth');
    console.log('3. Complete OAuth flow');
    console.log('4. Fetch emails: http://localhost:3000/emails/fetch');
    console.log('5. View emails: http://localhost:3000/emails');
    
  } catch (error) {
    console.error('âŒ Phase 1 test failed:', error);
  }
}

// Start server
if (require.main === module) {
  // Check if running as test
  if (process.argv[2] === 'test') {
    testPhase1().then(() => process.exit(0));
  } else {
    // Email parsing health monitoring
    app.get('/health/email-parsing', async (req, res) => {
      try {
        const failedEmails = (global as any).failedEmails || [];
        const recentFailures = failedEmails.slice(-10);
        
        res.json({
          status: failedEmails.length === 0 ? 'healthy' : 'issues_detected',
          totalFailures: failedEmails.length,
          recentFailures,
          recommendations: failedEmails.length > 0 ? [
            'Check Gmail API permissions',
            'Verify email structure in Gmail',
            'Consider manual inspection of failed emails'
          ] : []
        });
      } catch (error) {
        console.error('Health check error:', error);
        res.status(500).json({ error: 'Health check failed' });
      }
    });

    // Clear failed emails log
    app.post('/health/clear-failures', (req, res) => {
      (global as any).failedEmails = [];
      res.json({ message: 'Failed emails log cleared' });
    });

    // Schema management endpoint (temporary for fixing issues)
    // âš ï¸ PROTECTED: Requires authentication - can drop/recreate database schema
    app.post('/admin/reset-context-schema', authMiddleware.authenticate, async (req, res) => {
      try {
        const fs = require('fs');
        const path = require('path');
        
        console.log('ðŸ”§ Resetting context intelligence schema...');
        
        // Read and execute the fix script
        const fixScriptPath = path.join(__dirname, '../scripts/database/fix_schema.sql');
        if (fs.existsSync(fixScriptPath)) {
          const fixScript = fs.readFileSync(fixScriptPath, 'utf8');
          await pool.query(fixScript);
          console.log('âœ… Old schema dropped successfully');
        }
        
        // Re-apply the corrected Phase 2.2 schema
        const schemaPath = path.join(__dirname, '../scripts/database/phase2_2_schema.sql');
        const schema = fs.readFileSync(schemaPath, 'utf8');
        await pool.query(schema);
        console.log('âœ… New schema applied successfully');
        
        res.json({ 
          message: 'Context intelligence schema reset successfully',
          status: 'success'
        });
      } catch (error) {
        console.error('âŒ Schema reset failed:', error);
        res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
      }
    });

    // Apply Phase 2.3 schema (temporary endpoint)
    // âš ï¸ PROTECTED: Requires authentication - modifies database schema
    app.post('/admin/apply-phase23-schema', authMiddleware.authenticate, async (req, res) => {
      try {
        const fs = require('fs');
        const path = require('path');
        
        console.log('ðŸ”§ Applying Phase 2.3 schema...');
        
        // Apply the simplified Phase 2.3 schema
        const schemaPath = path.join(__dirname, '../scripts/database/create_phase23_tables.sql');
        if (fs.existsSync(schemaPath)) {
          const schema = fs.readFileSync(schemaPath, 'utf8');
          await pool.query(schema);
          console.log('âœ… Phase 2.3 schema applied successfully');
        }
        
        res.json({ 
          message: 'Phase 2.3 schema applied successfully',
          status: 'success'
        });
      } catch (error) {
        console.error('âŒ Phase 2.3 schema application failed:', error);
        res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
      }
    });

    // Fix missing context_used column
    // âš ï¸ PROTECTED: Requires authentication - alters database columns
    app.post('/admin/fix-context-column', authMiddleware.authenticate, async (req, res) => {
      try {
        const fs = require('fs');
        const path = require('path');
        
        console.log('ðŸ”§ Adding missing context_used column...');
        
        const schemaPath = path.join(__dirname, '../scripts/database/add_context_used_column.sql');
        if (fs.existsSync(schemaPath)) {
          const schema = fs.readFileSync(schemaPath, 'utf8');
          await pool.query(schema);
          console.log('âœ… Context_used column added successfully');
        }
        
        res.json({ 
          message: 'Context_used column added successfully',
          status: 'success'
        });
      } catch (error) {
        console.error('âŒ Column addition failed:', error);
        res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
      }
    });

    // Manual email inspection tool
    // âš ï¸ SECURITY ISSUE: Unauthenticated debug endpoint using global singleton
    // TODO: Add authentication or remove this endpoint before production
    app.get('/debug/email/:emailId', async (req, res) => {
      try {
        const { emailId } = req.params;

        // âš ï¸ SECURITY ISSUE: Using global singleton - only safe for single-user testing
        // Get raw email data by re-fetching (since gmail is private)
        const sentEmails = await gmailService.getSentEmails(1);
        const foundEmail = sentEmails.find(e => e.id === emailId);
        
        if (!foundEmail) {
          return res.status(404).json({ error: 'Email not found' });
        }
        
        const parsed = gmailService.parseEmail(foundEmail);
        
        res.json({
          emailId,
          rawStructure: {
            hasDirectBody: !!foundEmail.payload.body?.data,
            partsCount: foundEmail.payload.parts?.length || 0,
            mimeTypes: foundEmail.payload.parts?.map((p: any) => p.mimeType) || [],
          },
          parsedResult: {
            bodyLength: parsed.body.length,
            subject: parsed.subject,
            from: parsed.from,
            bodyPreview: parsed.body.substring(0, 200) + (parsed.body.length > 200 ? '...' : '')
          },
          failedAttempts: (global as any).failedEmails?.find((f: any) => f.id === emailId)?.attempts || []
        });
      } catch (error) {
        console.error('Email debug error:', error);
        res.status(500).json({ error: 'Failed to debug email' });
      }
    });

    // Manual schema application endpoint
    // âš ï¸ PROTECTED: Requires authentication - modifies database schema
    app.post('/admin/apply-phase2-2-schema', authMiddleware.authenticate, async (req, res) => {
      try {
        const fs = require('fs');
        const path = require('path');
        
        const phase2_2SchemaPath = path.join(__dirname, '../scripts/database/phase2_2_schema.sql');
        const phase2_2Schema = fs.readFileSync(phase2_2SchemaPath, 'utf8');
        await pool.query(phase2_2Schema);
        
        res.json({ 
          message: 'Phase 2.2 schema applied successfully',
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        console.error('âŒ Error applying Phase 2.2 schema:', error);
        res.status(500).json({ 
          error: 'Failed to apply schema',
          message: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // âš ï¸ PROTECTED: Requires authentication - modifies database schema
    app.post('/admin/apply-phase3-calendar-schema', authMiddleware.authenticate, async (req, res) => {
      try {
        const fs = require('fs');
        const path = require('path');
        
        console.log('ðŸ“… Applying Phase 3 Calendar Intelligence schema...');
        
        const phase3SchemaPath = path.join(__dirname, '../scripts/database/phase3_calendar_schema.sql');
        const phase3Schema = fs.readFileSync(phase3SchemaPath, 'utf8');
        await pool.query(phase3Schema);
        
        console.log('âœ… Phase 3 Calendar schema applied successfully');
        
        res.json({ 
          message: 'Phase 3 Calendar Intelligence schema applied successfully',
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        console.error('âŒ Error applying Phase 3 Calendar schema:', error);
        res.status(500).json({ 
          error: 'Failed to apply Phase 3 Calendar schema',
          message: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // Add webhook_processed flag migration
    // âš ï¸ PROTECTED: Requires authentication - alters database structure
    app.post('/admin/add-webhook-processed-flag', authMiddleware.authenticate, async (req, res) => {
      try {
        const fs = require('fs');
        const path = require('path');
        
        console.log('ðŸ”§ Adding webhook_processed flag to emails table...');
        
        const migrationPath = path.join(__dirname, '../scripts/database/add_webhook_processed_flag.sql');
        const migration = fs.readFileSync(migrationPath, 'utf8');
        
        await pool.query(migration);
        
        console.log('âœ… webhook_processed flag added successfully');
        res.json({ 
          message: 'webhook_processed flag added successfully',
          timestamp: new Date()
        });
      } catch (error) {
        console.error('âŒ Error adding webhook_processed flag:', error);
        res.status(500).json({ 
          error: 'Failed to add webhook_processed flag',
          message: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // Phase 2.2: Deep Context Intelligence endpoints
    app.post('/context/analyze-emails', async (req, res) => {
      try {
        console.log('ðŸ§  Starting deep context analysis on emails...');
        
        // Get emails that need context analysis
        const emailsToAnalyze = await contextModel.getEmailsNeedingContextAnalysis(10);
        console.log(`ðŸ“§ Found ${emailsToAnalyze.length} emails needing context analysis`);

        let processedCount = 0;
        const results = [];

        for (const email of emailsToAnalyze) {
          try {
            // Convert database email to ParsedEmail format
            const parsedEmail = {
              id: email.id.toString(),
              threadId: email.thread_id,
              subject: email.subject,
              from: email.from_email,
              to: email.to_email || '',
              date: new Date(email.received_at),
              body: email.body,
              isRead: email.is_read
            };
            
            // Analyze sender intelligence
            const senderProfile = await contextService.analyzeSender(parsedEmail);
            
            // Group emails by thread for context analysis (MUST be done BEFORE extracting entities)
            const threadEmails = emailsToAnalyze.filter(e => e.thread_id === email.thread_id);
            const parsedThreadEmails = threadEmails.map(e => ({
              id: e.id.toString(),
              threadId: e.thread_id,
              subject: e.subject,
              from: e.from_email,
              to: e.to_email || '',
              date: new Date(e.received_at),
              body: e.body,
              isRead: e.is_read
            }));
            
            const threadContext = await contextService.analyzeThreadContext(parsedThreadEmails);
            
            // Extract entities (AFTER thread context is created to satisfy foreign key)
            const entities = await contextService.extractEntities(parsedEmail);

            // Mark as analyzed
            await contextModel.markEmailContextAnalyzed(email.id);
            
            processedCount++;
            results.push({
              emailId: email.id,
              senderProfile: senderProfile.display_name || senderProfile.email_address,
              entitiesFound: entities.length,
              threadContext: threadContext ? threadContext.context_summary : null
            });

          } catch (error) {
            console.error(`âŒ Error processing email ${email.id}:`, error);
            results.push({
              emailId: email.id,
              error: error instanceof Error ? error.message : 'Unknown error'
            });
          }
        }

        res.json({
          message: `Context analysis completed`,
          emailsProcessed: processedCount,
          totalEmails: emailsToAnalyze.length,
          results
        });

      } catch (error) {
        console.error('âŒ Error in context analysis:', error);
        res.status(500).json({ error: 'Context analysis failed' });
      }
    });

    app.get('/context/stats', async (req, res) => {
      try {
        const stats = await contextModel.getContextStats();
        res.json({
          message: 'Context intelligence statistics',
          stats
        });
      } catch (error) {
        console.error('âŒ Error getting context stats:', error);
        res.status(500).json({ error: 'Failed to get context stats' });
      }
    });

    app.get('/context/threads', async (req, res) => {
      try {
        const threads = await contextModel.getThreadAnalytics();
        res.json({
          message: 'Email thread analytics',
          threads
        });
      } catch (error) {
        console.error('âŒ Error getting thread analytics:', error);
        res.status(500).json({ error: 'Failed to get thread analytics' });
      }
    });

    app.get('/context/senders', async (req, res) => {
      try {
        const senders = await contextModel.getSenderInsights();
        res.json({
          message: 'Sender relationship insights',
          senders
        });
      } catch (error) {
        console.error('âŒ Error getting sender insights:', error);
        res.status(500).json({ error: 'Failed to get sender insights' });
      }
    });

    app.get('/context/entities', async (req, res) => {
      try {
        const entities = await contextModel.getEntityInsights();
        res.json({
          message: 'Entity extraction insights',
          entities
        });
      } catch (error) {
        console.error('âŒ Error getting entity insights:', error);
        res.status(500).json({ error: 'Failed to get entity insights' });
      }
    });

    app.get('/context/thread/:threadId', async (req, res) => {
      try {
        const { threadId } = req.params;
        const threadContext = await contextModel.getThreadFullContext(threadId);
        
        if (!threadContext) {
          return res.status(404).json({ error: 'Thread not found' });
        }

        res.json({
          message: 'Full thread context',
          threadId,
          context: threadContext
        });
      } catch (error) {
        console.error('âŒ Error getting thread context:', error);
        res.status(500).json({ error: 'Failed to get thread context' });
      }
    });

    app.get('/context/health', async (req, res) => {
      try {
        const health = await contextModel.contextHealthCheck();
        res.json({
          message: 'Context intelligence health check',
          health
        });
      } catch (error) {
        console.error('âŒ Error checking context health:', error);
        res.status(500).json({ error: 'Failed to check context health' });
      }
    });

    // Phase 2.3: Smart Response Generation endpoints
    app.post('/response/generate-smart', authMiddleware.authenticate, async (req, res) => {
      try {
        const { emailId, recipientEmail, originalSubject, originalBody, customInstructions } = req.body;
        const userId = getUserId(req);
        
        if (!recipientEmail || !originalSubject || !originalBody) {
          return res.status(400).json({ 
            error: 'Missing required fields: recipientEmail, originalSubject, originalBody' 
          });
        }

        console.log(`ðŸ¤– Generating smart response for ${recipientEmail}...`);
        
        const responseRequest = {
          emailId: emailId || null,
          recipientEmail,
          originalSubject,
          originalBody,
          responseType: 'reply' as const,
          customInstructions,
          userId: userId // âœ… Add userId for proper user isolation
        };

        const smartResponse = await responseService.generateSmartResponse(responseRequest);
        
        res.json({
          message: 'Smart response generated successfully',
          response: smartResponse
        });

      } catch (error) {
        console.error('âŒ Error generating smart response:', error);
        res.status(500).json({ error: 'Failed to generate smart response' });
      }
    });

    app.get('/response/templates', async (req, res) => {
      try {
        const { relationshipType, urgencyLevel, templateType } = req.query;
        
        let query = 'SELECT * FROM response_templates WHERE is_active = true';
        const params: any[] = [];
        let paramCount = 1;

        if (relationshipType) {
          query += ` AND relationship_context = $${paramCount}`;
          params.push(relationshipType);
          paramCount++;
        }
        
        if (urgencyLevel) {
          query += ` AND urgency_context = $${paramCount}`;
          params.push(urgencyLevel);
          paramCount++;
        }
        
        if (templateType) {
          query += ` AND template_type = $${paramCount}`;
          params.push(templateType);
          paramCount++;
        }
        
        query += ' ORDER BY success_rate DESC, usage_count DESC';
        
        const result = await pool.query(query, params);
        
        res.json({
          message: 'Response templates retrieved',
          templates: result.rows
        });

      } catch (error) {
        console.error('âŒ Error fetching templates:', error);
        res.status(500).json({ error: 'Failed to fetch templates' });
      }
    });

    app.get('/response/stats', async (req, res) => {
      try {
        const statsQuery = `
          SELECT 
            COUNT(*) as total_generated,
            COUNT(*) FILTER (WHERE was_sent = true) as total_sent,
            COUNT(*) FILTER (WHERE user_edited = true) as total_edited,
            AVG(confidence) as avg_confidence,
            AVG(edit_percentage) FILTER (WHERE user_edited = true) as avg_edit_percentage,
            AVG(user_rating) FILTER (WHERE user_rating IS NOT NULL) as avg_user_rating
          FROM generated_responses
          WHERE generated_at >= CURRENT_DATE - INTERVAL '30 days';
        `;
        
        const recentStatsQuery = `
          SELECT 
            urgency_level,
            relationship_type,
            COUNT(*) as count,
            AVG(confidence) as avg_confidence
          FROM generated_responses 
          WHERE generated_at >= CURRENT_DATE - INTERVAL '7 days'
          GROUP BY urgency_level, relationship_type
          ORDER BY count DESC;
        `;

        const [stats, recentStats] = await Promise.all([
          pool.query(statsQuery),
          pool.query(recentStatsQuery)
        ]);

        res.json({
          message: 'Response generation statistics',
          stats: stats.rows[0],
          recentBreakdown: recentStats.rows
        });

      } catch (error) {
        console.error('âŒ Error fetching response stats:', error);
        res.status(500).json({ error: 'Failed to fetch response stats' });
      }
    });

    app.post('/response/feedback', async (req, res) => {
      try {
        const { responseId, wasEdited, editPercentage, wasSent, userRating } = req.body;
        
        if (!responseId) {
          return res.status(400).json({ error: 'Missing required field: responseId' });
        }

        const updateQuery = `
          UPDATE generated_responses 
          SET 
            user_edited = COALESCE($2, user_edited),
            edit_percentage = COALESCE($3, edit_percentage),
            was_sent = COALESCE($4, was_sent),
            user_rating = COALESCE($5, user_rating),
            edited_at = CASE WHEN $2 = true THEN CURRENT_TIMESTAMP ELSE edited_at END,
            sent_at = CASE WHEN $4 = true THEN CURRENT_TIMESTAMP ELSE sent_at END,
            rated_at = CASE WHEN $5 IS NOT NULL THEN CURRENT_TIMESTAMP ELSE rated_at END
          WHERE response_id = $1
          RETURNING *;
        `;

        const result = await pool.query(updateQuery, [
          responseId,
          wasEdited,
          editPercentage,
          wasSent,
          userRating
        ]);

        if (result.rows.length === 0) {
          return res.status(404).json({ error: 'Response not found' });
        }

        res.json({
          message: 'Feedback recorded successfully',
          response: result.rows[0]
        });

      } catch (error) {
        console.error('âŒ Error recording feedback:', error);
        res.status(500).json({ error: 'Failed to record feedback' });
      }
    });

    app.get('/response/recent', async (req, res) => {
      try {
        const { limit = 20 } = req.query;
        
        const query = `
          SELECT * FROM generated_responses 
          ORDER BY generated_at DESC 
          LIMIT $1;
        `;
        
        const result = await pool.query(query, [limit]);
        
        res.json({
          message: 'Recent responses retrieved',
          responses: result.rows
        });

      } catch (error) {
        console.error('âŒ Error fetching recent responses:', error);
        res.status(500).json({ error: 'Failed to fetch recent responses' });
      }
    });

    // Phase 2.4: Learning & Feedback System endpoints
    app.post('/learning/analyze-edit', authMiddleware.authenticate, async (req, res) => {
      try {
        const { responseId, originalText, editedText } = req.body;
        
        if (!responseId || !originalText || !editedText) {
          return res.status(400).json({ 
            error: 'Missing required fields: responseId, originalText, editedText' 
          });
        }

        console.log(`ðŸ” Analyzing edit for response ${responseId}...`);
        
        const analysis = await learningService.analyzeEdit(responseId, originalText, editedText, req.userId);
        
        res.json({
          message: 'Edit analysis completed',
          analysis
        });

      } catch (error) {
        console.error('âŒ Error analyzing edit:', error);
        res.status(500).json({ error: 'Failed to analyze edit' });
      }
    });

    app.get('/learning/success-metrics', authMiddleware.authenticate, async (req, res) => {
      try {
        const { days = 7 } = req.query;
        const daysNumber = parseInt(days as string);
        
        console.log(`ðŸ“Š Calculating success metrics for ${daysNumber} days...`);
        
        const metrics = await learningService.calculateSuccessMetrics(daysNumber, true, req.userId);
        
        res.json({
          message: 'Success metrics calculated',
          period: `${daysNumber} days`,
          metrics
        });

      } catch (error) {
        console.error('âŒ Error calculating success metrics:', error);
        res.status(500).json({ error: 'Failed to calculate success metrics' });
      }
    });

    app.get('/learning/insights', authMiddleware.authenticate, async (req, res) => {
      try {
        const { days = 30 } = req.query;
        const daysNumber = parseInt(days as string);
        
        console.log(`ðŸ§  Generating learning insights for ${daysNumber} days...`);
        
        const insights = await learningService.generateLearningInsights(daysNumber, req.userId);
        
        res.json({
          message: 'Learning insights generated',
          period: `${daysNumber} days`,
          insights,
          count: insights.length
        });

      } catch (error) {
        console.error('âŒ Error generating insights:', error);
        res.status(500).json({ error: 'Failed to generate learning insights' });
      }
    });

    // NOTE: Tone adjustment feature removed - learning insights now integrated directly into response generation

    app.get('/learning/performance-trend', authMiddleware.authenticate, async (req, res) => {
      try {
        const { weeks = 4 } = req.query;
        const weeksNumber = parseInt(weeks as string);
        
        console.log(`ðŸ“ˆ Calculating performance trend for ${weeksNumber} weeks...`);
        
        const trend = await learningService.getPerformanceTrend(weeksNumber, req.userId);
        
        res.json({
          message: 'Performance trend calculated',
          period: `${weeksNumber} weeks`,
          trend,
          dataPoints: trend.length
        });

      } catch (error) {
        console.error('âŒ Error calculating performance trend:', error);
        res.status(500).json({ error: 'Failed to calculate performance trend' });
      }
    });

    app.post('/learning/weekly-analysis', authMiddleware.authenticate, async (req, res) => {
      try {
        console.log('ðŸ“Š Running weekly performance analysis...');
        
        // Get comprehensive weekly data
        const [metrics, insights, trend] = await Promise.all([
          learningService.calculateSuccessMetrics(7, true, req.userId),
          learningService.generateLearningInsights(7, req.userId),
          learningService.getPerformanceTrend(2, req.userId)
        ]);
        
        // Generate weekly report
        const weeklyReport = {
          period: 'Last 7 days',
          successMetrics: metrics,
          keyInsights: insights,
          trendData: trend,
          recommendations: insights.map(i => i.recommendation),
          overallAssessment: metrics.overallSuccessRate >= 80 ? 'excellent' : 
                            metrics.overallSuccessRate >= 60 ? 'good' : 'needs_improvement'
        };
        
        res.json({
          message: 'Weekly analysis completed',
          report: weeklyReport
        });

      } catch (error) {
        console.error('âŒ Error running weekly analysis:', error);
        res.status(500).json({ error: 'Failed to run weekly analysis' });
      }
    });

    // ðŸ“… Phase 3: Calendar Intelligence endpoints

    // Calendar OAuth token sharing (uses same tokens as Gmail)
    app.post('/calendar/set-tokens', async (req, res) => {
      try {
        const { accessToken, refreshToken } = req.body;
        if (!accessToken || !refreshToken) {
          return res.status(400).json({ error: 'Both accessToken and refreshToken are required' });
        }
        
        await calendarService.setStoredTokens(accessToken, refreshToken);
        console.log('âœ… Calendar OAuth tokens set successfully');
        res.json({ message: 'Calendar tokens set successfully' });
      } catch (error) {
        console.error('âŒ Error setting calendar tokens:', error);
        res.status(500).json({ error: 'Failed to set calendar tokens' });
      }
    });

    // Get calendar events for date range (user-specific)
    app.get('/calendar/events', authMiddleware.authenticate, async (req, res) => {
      try {
        const { start, end, maxResults } = req.query;
        
        if (!start || !end) {
          return res.status(400).json({ error: 'start and end date parameters are required (ISO format)' });
        }

        const userId = req.userId;
        if (!userId) {
          return res.status(401).json({ error: 'User authentication required' });
        }

        console.log(`ðŸ“… Fetching calendar events for user ${userId} from ${start} to ${end}...`);
        
        // Initialize calendar service with user tokens
        const credentials = await tokenStorageService.getDecryptedCredentials(userId);
        if (!credentials) {
          return res.status(401).json({ error: 'Calendar access not authorized' });
        }

        await calendarService.setStoredTokens(credentials.accessToken, credentials.refreshToken);
        
        const events = await calendarService.getCalendarEvents(
          start as string, 
          end as string, 
          parseInt(maxResults as string) || 50
        );

        // Save events to database for caching/analysis
        if (events.length > 0) {
          await calendarModel.saveCalendarEvents(events);
        }

        res.json({
          message: `Retrieved ${events.length} calendar events`,
          events: events,
          dateRange: { start, end },
          user: userId
        });

      } catch (error) {
        console.error('âŒ Error fetching calendar events:', error);
        res.status(500).json({ error: 'Failed to fetch calendar events' });
      }
    });

    // Just-in-time availability check (user-specific)
    app.post('/calendar/check-availability', authMiddleware.authenticate, async (req, res) => {
      try {
        const { start, end } = req.body;
        
        if (!start || !end) {
          return res.status(400).json({ error: 'start and end datetime are required (ISO format)' });
        }

        const userId = req.userId;
        if (!userId) {
          return res.status(401).json({ error: 'User authentication required' });
        }

        console.log(`ðŸŽ¯ Checking availability for user ${userId}: ${start} to ${end}`);
        
        // Initialize calendar service with user tokens
        const credentials = await tokenStorageService.getDecryptedCredentials(userId);
        if (!credentials) {
          return res.status(401).json({ error: 'Calendar access not authorized' });
        }

        await calendarService.setStoredTokens(credentials.accessToken, credentials.refreshToken);
        
        const availability = await calendarService.checkAvailability(start, end);
        
        res.json({
          message: `Availability check: ${availability.isAvailable ? 'Available' : 'Conflicts found'}`,
          availability: availability,
          user: userId
        });

      } catch (error) {
        console.error('âŒ Error checking availability:', error);
        res.status(500).json({ error: 'Failed to check availability' });
      }
    });

    // Smart time slot suggestions
    app.post('/calendar/suggest-times', async (req, res) => {
      try {
        const { duration, date, workingHours, maxSuggestions } = req.body;
        
        if (!duration || !date) {
          return res.status(400).json({ error: 'duration (minutes) and date (YYYY-MM-DD) are required' });
        }

        console.log(`ðŸŽ¯ Suggesting time slots: ${duration} minutes on ${date}`);
        
        const suggestions = await calendarService.suggestTimeSlots(
          duration,
          date,
          workingHours || { start: '09:00', end: '17:00' },
          maxSuggestions || 3
        );
        
        res.json({
          message: `Generated ${suggestions.length} time slot suggestions`,
          suggestions: suggestions,
          requestedDuration: duration,
          requestedDate: date
        });

      } catch (error) {
        console.error('âŒ Error suggesting time slots:', error);
        res.status(500).json({ error: 'Failed to suggest time slots' });
      }
    });

    // Create calendar event
    app.post('/calendar/create-event', async (req, res) => {
      try {
        const { summary, description, start, end, attendees, location } = req.body;
        
        if (!summary || !start || !end) {
          return res.status(400).json({ error: 'summary, start, and end are required' });
        }

        const event = {
          summary,
          description,
          start: { dateTime: start },
          end: { dateTime: end },
          attendees: attendees?.map((email: string) => ({ email })),
          location
        };

        console.log(`ðŸ“… Creating calendar event: ${summary}`);
        
        const createdEvent = await calendarService.createCalendarEvent(event);
        
        // Save to database
        await calendarModel.saveCalendarEvent(createdEvent);
        
        res.json({
          message: 'Calendar event created successfully',
          event: createdEvent
        });

      } catch (error) {
        console.error('âŒ Error creating calendar event:', error);
        res.status(500).json({ error: 'Failed to create calendar event' });
      }
    });

    // Calendar preferences management
    app.get('/calendar/preferences', async (req, res) => {
      try {
        console.log('âš™ï¸ Fetching calendar preferences...');
        
        const preferences = await calendarModel.getUserPreferences();
        
        res.json({
          message: `Retrieved ${preferences.length} calendar preferences`,
          preferences: preferences
        });

      } catch (error) {
        console.error('âŒ Error fetching calendar preferences:', error);
        res.status(500).json({ error: 'Failed to fetch calendar preferences' });
      }
    });

    // Update calendar preference
    app.post('/calendar/preferences', async (req, res) => {
      try {
        const { preferenceType, preferenceValue } = req.body;
        
        if (!preferenceType || !preferenceValue) {
          return res.status(400).json({ error: 'preferenceType and preferenceValue are required' });
        }

        console.log(`âš™ï¸ Updating calendar preference: ${preferenceType}`);
        
        await calendarModel.updateUserPreference(preferenceType, preferenceValue);
        
        res.json({
          message: `Updated calendar preference: ${preferenceType}`,
          preferenceType: preferenceType,
          preferenceValue: preferenceValue
        });

      } catch (error) {
        console.error('âŒ Error updating calendar preference:', error);
        res.status(500).json({ error: 'Failed to update calendar preference' });
      }
    });

    // Calendar analytics and stats
    app.get('/calendar/stats', async (req, res) => {
      try {
        console.log('ðŸ“Š Fetching calendar statistics...');
        
        const stats = await calendarModel.getCalendarStats();
        
        res.json({
          message: 'Calendar statistics retrieved',
          stats: stats
        });

      } catch (error) {
        console.error('âŒ Error fetching calendar stats:', error);
        res.status(500).json({ error: 'Failed to fetch calendar stats' });
      }
    });

    // Calendar health check
    app.get('/calendar/health', async (req, res) => {
      try {
        console.log('ðŸ¥ Running calendar health check...');
        
        const [serviceHealth, modelHealth] = await Promise.all([
          calendarService.checkCalendarHealth(),
          calendarModel.calendarHealthCheck()
        ]);
        
        res.json({
          message: 'Calendar health check completed',
          service: serviceHealth,
          database: modelHealth
        });

      } catch (error) {
        console.error('âŒ Calendar health check failed:', error);
        res.status(500).json({ error: 'Calendar health check failed' });
      }
    });

    // ðŸ¤– Phase 3.2: Meeting Request Detection endpoints

    // Analyze specific email for meeting request
    app.post('/meetings/detect', async (req, res) => {
      try {
        const { emailId } = req.body;
        if (!emailId) {
          return res.status(400).json({ error: 'emailId is required' });
        }

        console.log(`ðŸ” Detecting meeting request in email ${emailId}...`);

        // Get email from database
        const emailResult = await pool.query('SELECT * FROM emails WHERE id = $1', [emailId]);
        if (emailResult.rows.length === 0) {
          return res.status(404).json({ error: 'Email not found' });
        }

        const email = emailResult.rows[0];
        const parsedEmail = {
          id: email.id.toString(),
          threadId: email.thread_id,
          subject: email.subject,
          from: email.from_email,
          to: email.to_email || '',
          date: email.received_at,
          body: email.body,
          isRead: email.is_read
        };

        // Detect meeting request
        const meetingRequest = await meetingDetectionService.detectMeetingRequest(parsedEmail);
        
        if (meetingRequest) {
          // Save to database
          const meetingRequestId = await calendarModel.saveMeetingRequest(meetingRequest);
          
          res.json({
            message: 'Meeting request detected successfully',
            meetingRequest: { ...meetingRequest, id: meetingRequestId }
          });
        } else {
          res.json({
            message: 'No meeting request detected in this email',
            meetingRequest: null
          });
        }

      } catch (error) {
        console.error('âŒ Error detecting meeting request:', error);
        res.status(500).json({ error: 'Failed to detect meeting request' });
      }
    });

    // Analyze all unprocessed emails for meeting requests
    app.post('/meetings/scan-emails', async (req, res) => {
      try {
        const { limit = 10 } = req.body;
        
        console.log(`ðŸ” Scanning recent emails for meeting requests (limit: ${limit})...`);

        // Get recent emails that haven't been scanned for meetings
        const emailsQuery = `
          SELECT * FROM emails 
          WHERE id NOT IN (SELECT DISTINCT email_id FROM meeting_requests WHERE email_id IS NOT NULL)
          ORDER BY received_at DESC 
          LIMIT $1
        `;
        
        const emailsResult = await pool.query(emailsQuery, [limit]);
        const emails = emailsResult.rows;

        if (emails.length === 0) {
          return res.json({
            message: 'No new emails to scan for meeting requests',
            meetingRequests: []
          });
        }

        const meetingRequests = [];
        let processed = 0;

        for (const email of emails) {
          try {
            const parsedEmail = {
              id: email.id.toString(),
              threadId: email.thread_id,
              subject: email.subject,
              from: email.from_email,
              to: email.to_email || '',
              date: email.received_at,
              body: email.body,
              isRead: email.is_read
            };

            const meetingRequest = await meetingDetectionService.detectMeetingRequest(parsedEmail);
            
            if (meetingRequest) {
              const meetingRequestId = await calendarModel.saveMeetingRequest(meetingRequest);
              meetingRequests.push({ ...meetingRequest, id: meetingRequestId });
            }
            
            processed++;

          } catch (error) {
            console.error(`âŒ Error processing email ${email.id}:`, error);
          }
        }

        res.json({
          message: `Meeting request scan completed`,
          emailsProcessed: processed,
          meetingRequestsFound: meetingRequests.length,
          meetingRequests
        });

      } catch (error) {
        console.error('âŒ Error scanning emails for meeting requests:', error);
        res.status(500).json({ error: 'Failed to scan emails for meeting requests' });
      }
    });

    // Get all meeting requests
    app.get('/meetings/requests', async (req, res) => {
      try {
        const { status, limit = 20 } = req.query;
        
        console.log('ðŸ“‹ Fetching meeting requests...');

        let query = `
          SELECT 
            mr.*,
            e.subject as email_subject,
            e.from_email,
            e.received_at as email_date
          FROM meeting_requests mr
          LEFT JOIN emails e ON mr.email_id = e.id
        `;
        
        const params: any[] = [];
        let paramCount = 1;

        if (status) {
          query += ` WHERE mr.status = $${paramCount}`;
          params.push(status);
          paramCount++;
        }

        query += ` ORDER BY mr.created_at DESC LIMIT $${paramCount}`;
        params.push(limit);

        const result = await pool.query(query, params);
        
        res.json({
          message: `Retrieved ${result.rows.length} meeting requests`,
          meetingRequests: result.rows
        });

      } catch (error) {
        console.error('âŒ Error fetching meeting requests:', error);
        res.status(500).json({ error: 'Failed to fetch meeting requests' });
      }
    });

    // Update meeting request status
    app.patch('/meetings/requests/:id', async (req, res) => {
      try {
        const { id } = req.params;
        const { status } = req.body;

        if (!['pending', 'scheduled', 'declined', 'cancelled'].includes(status)) {
          return res.status(400).json({ 
            error: 'Invalid status. Must be: pending, scheduled, declined, cancelled' 
          });
        }

        console.log(`ðŸ“ Updating meeting request ${id} status to ${status}...`);

        const result = await pool.query(
          'UPDATE meeting_requests SET status = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2 RETURNING *',
          [status, id]
        );

        if (result.rows.length === 0) {
          return res.status(404).json({ error: 'Meeting request not found' });
        }

        res.json({
          message: 'Meeting request status updated successfully',
          meetingRequest: result.rows[0]
        });

      } catch (error) {
        console.error('âŒ Error updating meeting request:', error);
        res.status(500).json({ error: 'Failed to update meeting request' });
      }
    });

    // Meeting detection service health check
    app.get('/meetings/health', async (req, res) => {
      try {
        console.log('ðŸ¥ Running meeting detection health check...');
        
        const health = await meetingDetectionService.healthCheck();
        
        // Get meeting request statistics
        const statsQuery = `
          SELECT 
            COUNT(*) as total_requests,
            COUNT(*) FILTER (WHERE status = 'pending') as pending_requests,
            COUNT(*) FILTER (WHERE status = 'scheduled') as scheduled_requests,
            COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') as recent_requests,
            AVG(detection_confidence) as avg_confidence
          FROM meeting_requests
        `;
        
        const statsResult = await pool.query(statsQuery);
        const stats = statsResult.rows[0];

        res.json({
          message: 'Meeting detection health check completed',
          service: health,
          statistics: {
            totalRequests: parseInt(stats.total_requests),
            pendingRequests: parseInt(stats.pending_requests),
            scheduledRequests: parseInt(stats.scheduled_requests),
            recentRequests: parseInt(stats.recent_requests),
            avgConfidence: parseFloat(stats.avg_confidence) || 0
          },
          lastUpdated: new Date()
        });

      } catch (error) {
        console.error('âŒ Meeting detection health check failed:', error);
        res.status(500).json({ error: 'Meeting detection health check failed' });
      }
    });

    // ===== MEETING CONFIRMATION ENDPOINTS =====

    // Get pending meeting confirmations for user
    app.get('/meetings/confirmations', authMiddleware.authenticate, async (req, res) => {
      try {
        const userId = req.userId;
        if (!userId) {
          return res.status(401).json({ error: 'User authentication required' });
        }

        console.log(`ðŸ“‹ Fetching pending meeting confirmations for user: ${userId}`);
        
        const confirmations = await meetingConfirmationService.getPendingConfirmations(userId);
        
        res.json({
          message: `Found ${confirmations.length} pending meeting confirmations`,
          confirmations: confirmations
        });

      } catch (error) {
        console.error('âŒ Error fetching meeting confirmations:', error);
        res.status(500).json({ error: 'Failed to fetch meeting confirmations' });
      }
    });

    // Confirm a meeting and create calendar event
    app.post('/meetings/confirmations/:id/confirm', authMiddleware.authenticate, async (req, res) => {
      try {
        const { id } = req.params;
        const { selectedTimeSlot } = req.body;
        
        const userId = req.userId;
        if (!userId) {
          return res.status(401).json({ error: 'User authentication required' });
        }

        console.log(`ðŸ“… Confirming meeting: ${id} for user: ${userId}`);
        
        const result = await meetingConfirmationService.confirmMeeting(
          id,
          userId,
          selectedTimeSlot
        );
        
        if (result.success) {
          res.json({
            message: 'Meeting confirmed and calendar event created successfully',
            calendarEventId: result.calendarEventId
          });
        } else {
          res.status(400).json({ 
            error: result.error || 'Failed to confirm meeting' 
          });
        }

      } catch (error) {
        console.error('âŒ Error confirming meeting:', error);
        res.status(500).json({ error: 'Failed to confirm meeting' });
      }
    });

    // Cancel a meeting confirmation
    app.post('/meetings/confirmations/:id/cancel', authMiddleware.authenticate, async (req, res) => {
      try {
        const { id } = req.params;
        
        const userId = req.userId;
        if (!userId) {
          return res.status(401).json({ error: 'User authentication required' });
        }

        console.log(`âŒ Cancelling meeting confirmation: ${id} for user: ${userId}`);
        
        const result = await meetingConfirmationService.cancelMeetingConfirmation(
          id,
          userId
        );
        
        if (result.success) {
          res.json({ message: 'Meeting confirmation cancelled successfully' });
        } else {
          res.status(400).json({ 
            error: result.error || 'Failed to cancel meeting confirmation' 
          });
        }

      } catch (error) {
        console.error('âŒ Error cancelling meeting confirmation:', error);
        res.status(500).json({ error: 'Failed to cancel meeting confirmation' });
      }
    });

    // Get alternative time suggestions for a meeting
    app.get('/meetings/confirmations/:id/suggestions', authMiddleware.authenticate, async (req, res) => {
      try {
        const { id } = req.params;
        const { duration = 60 } = req.query;
        
        const userId = req.userId;
        if (!userId) {
          return res.status(401).json({ error: 'User authentication required' });
        }

        // Get confirmation to find meeting request ID
        const confirmation = await meetingConfirmationService.getMeetingConfirmation(id, userId);
        if (!confirmation) {
          return res.status(404).json({ error: 'Meeting confirmation not found' });
        }

        console.log(`ðŸ“… Getting alternative time suggestions for meeting: ${id}`);
        
        const suggestions = await meetingConfirmationService.getAlternativeTimeSuggestions(
          confirmation.meetingRequestId,
          userId,
          parseInt(duration as string)
        );
        
        res.json({
          message: `Found ${suggestions.length} alternative time suggestions`,
          suggestions: suggestions
        });

      } catch (error) {
        console.error('âŒ Error getting alternative time suggestions:', error);
        res.status(500).json({ error: 'Failed to get alternative time suggestions' });
      }
    });

    // ============================================================================
    // PHASE 3.3: AUTO-SCHEDULING SYSTEM - Automated Meeting Scheduling
    // ============================================================================

    // Process meeting request for auto-scheduling
    app.post('/auto-scheduling/process-meeting', async (req, res) => {
      try {
        const { meetingRequestId } = req.body;
        
        if (!meetingRequestId) {
          return res.status(400).json({ error: 'Meeting request ID is required' });
        }

        console.log(`ðŸ¤– Processing meeting request ${meetingRequestId} for auto-scheduling...`);

        // Get meeting request from database
        const meetingQuery = 'SELECT * FROM meeting_requests WHERE id = $1';
        const meetingResult = await pool.query(meetingQuery, [meetingRequestId]);
        
        if (meetingResult.rows.length === 0) {
          return res.status(404).json({ error: 'Meeting request not found' });
        }

        const meetingRequest = meetingResult.rows[0];
        
        // Process with auto-scheduling service
        const workflow = await autoSchedulingService.processDetectedMeeting(meetingRequest);
        
        if (!workflow) {
          return res.status(500).json({ error: 'Failed to create scheduling workflow' });
        }

        res.json({
          message: 'Auto-scheduling workflow initiated',
          workflow: {
            id: workflow.id,
            type: workflow.workflowType,
            currentStep: workflow.currentStep,
            status: workflow.status,
            progress: `${workflow.stepNumber}/${workflow.totalSteps}`
          }
        });

      } catch (error) {
        console.error('âŒ Error processing meeting for auto-scheduling:', error);
        res.status(500).json({ error: 'Failed to process meeting request' });
      }
    });

    // Generate time slot suggestions for a meeting
    app.post('/auto-scheduling/suggest-times', async (req, res) => {
      try {
        const { meetingRequestId, recipientEmail } = req.body;
        
        if (!meetingRequestId) {
          return res.status(400).json({ error: 'Meeting request ID is required' });
        }

        console.log(`â° Generating time suggestions for meeting request ${meetingRequestId}...`);

        // Get meeting request
        const meetingQuery = 'SELECT * FROM meeting_requests WHERE id = $1';
        const meetingResult = await pool.query(meetingQuery, [meetingRequestId]);
        
        if (meetingResult.rows.length === 0) {
          return res.status(404).json({ error: 'Meeting request not found' });
        }

        const meetingRequest = meetingResult.rows[0];
        
        // Generate suggestions
        const suggestions = await autoSchedulingService.generateTimeSlotSuggestions(
          meetingRequest, 
          recipientEmail
        );

        res.json({
          meetingRequestId,
          suggestions: suggestions.map(s => ({
            startTime: s.start,
            endTime: s.end,
            confidence: s.confidence,
            reasoning: s.reason
          }))
        });

      } catch (error) {
        console.error('âŒ Error generating time suggestions:', error);
        res.status(500).json({ error: 'Failed to generate time suggestions' });
      }
    });

    // Create calendar hold for a time slot
    app.post('/auto-scheduling/create-hold', async (req, res) => {
      try {
        const { meetingRequestId, startTime, endTime, holderEmail, notes } = req.body;
        
        if (!meetingRequestId || !startTime || !endTime || !holderEmail) {
          return res.status(400).json({ 
            error: 'Meeting request ID, start time, end time, and holder email are required' 
          });
        }

        console.log(`ðŸ”’ Creating calendar hold for meeting ${meetingRequestId}...`);

        const hold = await autoSchedulingService.createCalendarHold(
          meetingRequestId,
          new Date(startTime),
          new Date(endTime),
          holderEmail,
          1440, // 24 hour hold
          notes
        );

        if (!hold) {
          return res.status(409).json({ error: 'Scheduling conflict detected, cannot create hold' });
        }

        res.json({
          message: 'Calendar hold created successfully',
          hold: {
            id: hold.id,
            startTime: hold.startTime,
            endTime: hold.endTime,
            status: hold.status,
            expiryTime: hold.expiryTime
          }
        });

      } catch (error) {
        console.error('âŒ Error creating calendar hold:', error);
        res.status(500).json({ error: 'Failed to create calendar hold' });
      }
    });

    // Confirm scheduling and create calendar event
    app.post('/auto-scheduling/confirm', async (req, res) => {
      try {
        const { meetingRequestId, selectedTimeSlot, additionalAttendees } = req.body;
        
        if (!meetingRequestId || !selectedTimeSlot) {
          return res.status(400).json({ 
            error: 'Meeting request ID and selected time slot are required' 
          });
        }

        console.log(`âœ… Confirming scheduling for meeting ${meetingRequestId}...`);

        const calendarEvent = await autoSchedulingService.confirmScheduling(
          meetingRequestId,
          selectedTimeSlot,
          additionalAttendees
        );

        if (!calendarEvent) {
          return res.status(500).json({ error: 'Failed to confirm scheduling' });
        }

        res.json({
          message: 'Meeting scheduled successfully',
          event: {
            id: calendarEvent.id,
            summary: calendarEvent.summary,
            startTime: calendarEvent.start.dateTime,
            endTime: calendarEvent.end.dateTime,
            attendees: calendarEvent.attendees,
            location: calendarEvent.location
          }
        });

      } catch (error) {
        console.error('âŒ Error confirming scheduling:', error);
        res.status(500).json({ error: 'Failed to confirm scheduling' });
      }
    });

    // Get scheduling workflows
    app.get('/auto-scheduling/workflows', async (req, res) => {
      try {
        const { status, limit } = req.query;
        
        console.log(`ðŸ“‹ Fetching scheduling workflows (status: ${status || 'all'})...`);

        let query = `
          SELECT sw.*, mr.subject, mr.sender_email, mr.meeting_type, mr.urgency_level
          FROM scheduling_workflows sw
          JOIN meeting_requests mr ON sw.meeting_request_id = mr.id
        `;
        
        const params: any[] = [];
        
        if (status) {
          query += ` WHERE sw.status = $1`;
          params.push(status);
        }
        
        query += ` ORDER BY sw.created_at DESC`;
        
        if (limit) {
          query += ` LIMIT $${params.length + 1}`;
          params.push(parseInt(limit as string));
        }

        const result = await pool.query(query, params);

        res.json({
          workflows: result.rows.map(row => ({
            id: row.id,
            meetingRequestId: row.meeting_request_id,
            workflowType: row.workflow_type,
            currentStep: row.current_step,
            progress: `${row.step_number}/${row.total_steps}`,
            status: row.status,
            createdAt: row.created_at,
            updatedAt: row.updated_at,
            meeting: {
              subject: row.subject,
              senderEmail: row.sender_email,
              meetingType: row.meeting_type,
              urgencyLevel: row.urgency_level
            }
          }))
        });

      } catch (error) {
        console.error('âŒ Error fetching workflows:', error);
        res.status(500).json({ error: 'Failed to fetch workflows' });
      }
    });

    // Get calendar holds
    app.get('/auto-scheduling/holds', async (req, res) => {
      try {
        const { status, active } = req.query;
        
        console.log(`ðŸ”’ Fetching calendar holds (status: ${status || 'all'})...`);

        let query = `
          SELECT ch.*, mr.subject, mr.sender_email
          FROM calendar_holds ch
          JOIN meeting_requests mr ON ch.meeting_request_id = mr.id
        `;
        
        const params: any[] = [];
        
        if (status) {
          query += ` WHERE ch.status = $1`;
          params.push(status);
        } else if (active === 'true') {
          query += ` WHERE ch.status IN ('active', 'confirmed') AND ch.expiry_time > NOW()`;
        }
        
        query += ` ORDER BY ch.start_time ASC`;

        const result = await pool.query(query, params);

        res.json({
          holds: result.rows.map(row => ({
            id: row.id,
            meetingRequestId: row.meeting_request_id,
            startTime: row.start_time,
            endTime: row.end_time,
            holderEmail: row.holder_email,
            status: row.status,
            expiryTime: row.expiry_time,
            notes: row.notes,
            meeting: {
              subject: row.subject,
              senderEmail: row.sender_email
            }
          }))
        });

      } catch (error) {
        console.error('âŒ Error fetching calendar holds:', error);
        res.status(500).json({ error: 'Failed to fetch calendar holds' });
      }
    });

    // Cleanup expired holds
    app.post('/auto-scheduling/cleanup-holds', async (req, res) => {
      try {
        console.log('ðŸ§¹ Cleaning up expired calendar holds...');
        
        const cleanedCount = await autoSchedulingService.cleanupExpiredHolds();
        
        res.json({
          message: `Cleaned up ${cleanedCount} expired holds`,
          cleanedCount
        });

      } catch (error) {
        console.error('âŒ Error cleaning up holds:', error);
        res.status(500).json({ error: 'Failed to cleanup expired holds' });
      }
    });

    // Auto-scheduling system health check
    app.get('/auto-scheduling/health', async (req, res) => {
      try {
        console.log('ðŸ¥ Running auto-scheduling system health check...');
        
        const health = await autoSchedulingService.healthCheck();
        
        // Get workflow statistics
        const workflowStats = await pool.query(`
          SELECT 
            COUNT(*) as total_workflows,
            COUNT(*) FILTER (WHERE status = 'active') as active_workflows,
            COUNT(*) FILTER (WHERE status = 'completed') as completed_workflows,
            COUNT(*) FILTER (WHERE status = 'failed') as failed_workflows
          FROM scheduling_workflows
        `);
        
        res.json({
          service: 'Auto-Scheduling System',
          timestamp: new Date().toISOString(),
          health: {
            status: health.status,
            activeWorkflows: health.activeWorkflows,
            activeHolds: health.activeHolds
          },
          statistics: workflowStats.rows[0] || {
            total_workflows: 0,
            active_workflows: 0,
            completed_workflows: 0,
            failed_workflows: 0
          }
        });

      } catch (error) {
        console.error('âŒ Auto-scheduling health check failed:', error);
        res.status(500).json({
          service: 'Auto-Scheduling System',
          timestamp: new Date().toISOString(),
          health: { status: 'error', activeWorkflows: 0, activeHolds: 0 },
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // Debug endpoint to initialize Phase 3.3 schema manually
    app.post('/debug/init-phase33-schema', async (req, res) => {
      try {
        console.log('ðŸ”§ Manually initializing Phase 3.3 schema...');
        
        // Create calendar_holds table first (without foreign key constraint)
        await pool.query(`
          CREATE TABLE IF NOT EXISTS calendar_holds (
              id SERIAL PRIMARY KEY,
              meeting_request_id INTEGER,
              start_time TIMESTAMP WITH TIME ZONE NOT NULL,
              end_time TIMESTAMP WITH TIME ZONE NOT NULL,
              holder_email VARCHAR(255) NOT NULL,
              status VARCHAR(50) DEFAULT 'active' CHECK (status IN ('active', 'confirmed', 'expired', 'cancelled')),
              expiry_time TIMESTAMP WITH TIME ZONE NOT NULL,
              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
              notes TEXT
          );
        `);
        
        // Create scheduling_responses table
        await pool.query(`
          CREATE TABLE IF NOT EXISTS scheduling_responses (
              id SERIAL PRIMARY KEY,
              meeting_request_id INTEGER,
              recipient_email VARCHAR(255) NOT NULL,
              response_type VARCHAR(50) NOT NULL CHECK (response_type IN ('accept_time', 'reject_time', 'suggest_alternative', 'decline_meeting')),
              suggested_time_start TIMESTAMP WITH TIME ZONE,
              suggested_time_end TIMESTAMP WITH TIME ZONE,
              response_confidence DECIMAL(3,2) DEFAULT 0.8,
              ai_analysis JSONB,
              email_content TEXT,
              processed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
          );
        `);
        
        // Create scheduling_workflows table
        await pool.query(`
          CREATE TABLE IF NOT EXISTS scheduling_workflows (
              id SERIAL PRIMARY KEY,
              meeting_request_id INTEGER,
              workflow_type VARCHAR(50) NOT NULL CHECK (workflow_type IN ('direct_schedule', 'negotiate_time', 'multi_recipient', 'recurring_setup')),
              current_step VARCHAR(100) NOT NULL,
              total_steps INTEGER DEFAULT 1,
              step_number INTEGER DEFAULT 1,
              status VARCHAR(50) DEFAULT 'active' CHECK (status IN ('active', 'completed', 'failed', 'cancelled')),
              context JSONB,
              next_action_time TIMESTAMP WITH TIME ZONE,
              retry_count INTEGER DEFAULT 0,
              max_retries INTEGER DEFAULT 3,
              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
              updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
          );
        `);
        
        // Create auto_scheduling_preferences table
        await pool.query(`
          CREATE TABLE IF NOT EXISTS auto_scheduling_preferences (
              id SERIAL PRIMARY KEY,
              user_email VARCHAR(255) NOT NULL,
              preference_type VARCHAR(100) NOT NULL,
              preference_value JSONB NOT NULL,
              priority INTEGER DEFAULT 5,
              is_active BOOLEAN DEFAULT true,
              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
              updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
              UNIQUE(user_email, preference_type)
          );
        `);
        
        // Create indexes
        await pool.query(`
          CREATE INDEX IF NOT EXISTS idx_calendar_holds_meeting_request ON calendar_holds(meeting_request_id);
          CREATE INDEX IF NOT EXISTS idx_calendar_holds_status_expiry ON calendar_holds(status, expiry_time);
          CREATE INDEX IF NOT EXISTS idx_calendar_holds_time_range ON calendar_holds(start_time, end_time);
          
          CREATE INDEX IF NOT EXISTS idx_scheduling_responses_meeting_request ON scheduling_responses(meeting_request_id);
          CREATE INDEX IF NOT EXISTS idx_scheduling_responses_recipient ON scheduling_responses(recipient_email);
          CREATE INDEX IF NOT EXISTS idx_scheduling_responses_type ON scheduling_responses(response_type);
          
          CREATE INDEX IF NOT EXISTS idx_scheduling_workflows_meeting_request ON scheduling_workflows(meeting_request_id);
          CREATE INDEX IF NOT EXISTS idx_scheduling_workflows_status ON scheduling_workflows(status);
          CREATE INDEX IF NOT EXISTS idx_scheduling_workflows_next_action ON scheduling_workflows(next_action_time) WHERE next_action_time IS NOT NULL;
          
          CREATE INDEX IF NOT EXISTS idx_auto_scheduling_preferences_user ON auto_scheduling_preferences(user_email);
          CREATE INDEX IF NOT EXISTS idx_auto_scheduling_preferences_type ON auto_scheduling_preferences(preference_type);
        `);
        
        // Insert default preferences
        await pool.query(`
          INSERT INTO auto_scheduling_preferences (user_email, preference_type, preference_value, priority) VALUES
          ('default', 'working_hours', '{"start": "09:00", "end": "17:00", "timezone": "America/New_York", "days": ["monday", "tuesday", "wednesday", "thursday", "friday"]}', 9),
          ('default', 'buffer_time', '{"before_meeting": 15, "after_meeting": 15, "unit": "minutes"}', 8),
          ('default', 'auto_confirm_threshold', '{"confidence_score": 0.85, "known_contacts_only": false}', 7),
          ('default', 'hold_duration', '{"duration_minutes": 1440, "max_concurrent_holds": 5}', 6),
          ('default', 'meeting_lengths', '{"default": 60, "quick_chat": 15, "brief": 30, "standard": 60, "detailed": 90, "unit": "minutes"}', 5)
          ON CONFLICT (user_email, preference_type) DO NOTHING;
        `);
        
        console.log('âœ… Phase 3.3 schema initialized successfully');
        res.json({ message: 'Phase 3.3 schema initialized successfully' });
        
      } catch (error) {
        console.error('âŒ Error initializing Phase 3.3 schema:', error);
        res.status(500).json({ 
          error: 'Failed to initialize Phase 3.3 schema',
          details: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // Enhanced draft generation with full context
    app.post('/ai/generate-drafts-with-context', async (req, res) => {
      try {
        console.log('âœ¨ Generating context-aware drafts...');

        // Get emails that need responses (have context analysis)
        const query = `
          SELECT e.*, et.context_summary, sp.relationship_type, sp.formality_preference
          FROM emails e
          LEFT JOIN email_threads et ON e.thread_id = et.thread_id  
          LEFT JOIN sender_profiles sp ON e.from_email = sp.email_address
          WHERE e.context_analyzed = TRUE 
          AND NOT EXISTS (SELECT 1 FROM drafts d WHERE d.email_id = e.id)
          ORDER BY e.received_at DESC
          LIMIT 5;
        `;
        
        const emailsResult = await pool.query(query);
        const emails = emailsResult.rows;

        if (emails.length === 0) {
          return res.json({ 
            message: 'No emails available for context-aware draft generation',
            suggestion: 'Run context analysis first: POST /context/analyze-emails'
          });
        }

        const generatedDrafts = [];

        for (const email of emails) {
          try {
            // Note: parseEmail is a stateless function, safe to use on database records
            const parsedEmail = gmailService.parseEmail(email);

            // Get full context for this email
            const fullContext = await contextService.getFullContextForDraft(parsedEmail);
            
            // Get latest tone profile
            const toneProfile = await draftModel.getLatestRealToneProfile();
            if (!toneProfile) {
              throw new Error('No tone profile available. Run tone analysis first.');
            }

            // Generate context-aware draft
            const draft = await aiService.generateDraft(
              {
                subject: parsedEmail.subject,
                body: parsedEmail.body,
                from: parsedEmail.from
              },
              email.category || 'other',
              toneProfile.profile_text,
              fullContext // Enhanced with context!
            );

            // Calculate enhanced quality score
            const qualityScore = await aiService.scoreDraft(
              draft.body,
              parsedEmail.body,
              email.category || 'other'
            );

            // Save draft
            const draftId = await draftModel.saveDraft({
              email_id: email.id,
              subject: draft.subject,
              body: draft.body,
              category: email.category || 'other',
              confidence_score: draft.confidence,
              quality_score: qualityScore
            });

            generatedDrafts.push({
              draftId,
              emailSubject: parsedEmail.subject,
              from: parsedEmail.from,
              contextUsed: fullContext.length > 0,
              confidence: draft.confidence,
              qualityScore
            });

          } catch (error) {
            console.error(`âŒ Error generating draft for email ${email.id}:`, error);
          }
        }

        res.json({
          message: 'Context-aware drafts generated successfully',
          draftsGenerated: generatedDrafts.length,
          totalEmailsProcessed: emails.length,
          drafts: generatedDrafts
        });

      } catch (error) {
        console.error('âŒ Error generating context-aware drafts:', error);
        res.status(500).json({ error: 'Failed to generate context-aware drafts' });
      }
    });

// Webhook management endpoints
app.get('/webhook-status', async (_req, res) => {
  try {
    const status = await webhookRenewalService.getWebhookStatus();
    res.json({
      webhooks: status,
      totalActive: status.filter(w => w.webhookActive).length,
      needingRenewal: status.filter(w => w.needsRenewal).length
    });
  } catch (error) {
    console.error('âŒ Error getting webhook status:', error);
    res.status(500).json({ error: 'Failed to get webhook status' });
  }
});

app.post('/webhook-renewal/manual', async (_req, res) => {
  try {
    await webhookRenewalService.manualRenewalCheck();
    res.json({ message: 'Manual webhook renewal check completed' });
  } catch (error) {
    console.error('âŒ Error in manual webhook renewal:', error);
    res.status(500).json({ error: 'Failed to perform manual webhook renewal' });
  }
});

// ðŸ§ª Webhook Testing Endpoints
app.post('/test/webhook-suite', async (_req, res) => {
  try {
    console.log('ðŸ§ª Running comprehensive webhook testing suite...');
    const startTime = Date.now();
    
    const testResults = await webhookTestingSuite.runAllTests();
    const duration = Date.now() - startTime;
    
    const passed = testResults.filter((r: any) => r.status === 'PASS').length;
    const failed = testResults.filter((r: any) => r.status === 'FAIL').length;
    const successRate = ((passed / (passed + failed)) * 100).toFixed(1);
    
    res.json({
      message: 'Comprehensive webhook testing completed',
      summary: {
        totalTests: testResults.length,
        passed,
        failed,
        successRate: `${successRate}%`,
        totalDuration: duration,
        status: failed === 0 ? 'ALL_PASS' : failed <= 2 ? 'MINOR_ISSUES' : 'CRITICAL_ISSUES'
      },
      results: testResults,
      recommendation: failed === 0 
        ? 'System ready for production use' 
        : failed <= 2 
          ? 'Review failed tests before production' 
          : 'Fix critical issues before using system'
    });
  } catch (error) {
    console.error('âŒ Error running webhook test suite:', error);
    res.status(500).json({ 
      error: 'Failed to run webhook test suite', 
      details: error instanceof Error ? error.message : 'Unknown error' 
    });
  }
});

app.get('/test/webhook-health', async (_req, res) => {
  try {
    const healthCheck = await webhookTestingSuite.quickHealthCheck();
    
    res.json({
      healthy: healthCheck.healthy,
      status: healthCheck.healthy ? 'HEALTHY' : 'UNHEALTHY',
      issues: healthCheck.issues,
      timestamp: new Date().toISOString(),
      recommendations: healthCheck.healthy 
        ? ['System operating normally']
        : healthCheck.issues.map((issue: any) => `Fix: ${issue}`)
    });
  } catch (error) {
    console.error('âŒ Error in webhook health check:', error);
    res.status(500).json({ 
      healthy: false, 
      status: 'ERROR',
      issues: ['Health check system error'],
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Error handling middleware (must be last)
app.use(errorHandler);

// Graceful shutdown handling
process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, shutting down gracefully');

  try {
    // Shutdown in order: stop new work first, then cleanup resources
    monitoring.shutdown();
    shutdownSecurity();
    if (webhookRenewalService) {
      webhookRenewalService.stopRenewalService();
    }

    // Close Redis connection
    await redis.close();

    // Close database pool (wait for in-flight queries to complete)
    await closePool();

    logger.info('âœ… Graceful shutdown completed');
    process.exit(0);
  } catch (error) {
    logger.error('âŒ Error during shutdown:', error);
    process.exit(1);
  }
});

process.on('SIGINT', async () => {
  logger.info('SIGINT received, shutting down gracefully');

  try {
    // Shutdown in order: stop new work first, then cleanup resources
    monitoring.shutdown();
    shutdownSecurity();
    if (webhookRenewalService) {
      webhookRenewalService.stopRenewalService();
    }

    // Close Redis connection
    await redis.close();

    // Close database pool (wait for in-flight queries to complete)
    await closePool();

    logger.info('âœ… Graceful shutdown completed');
    process.exit(0);
  } catch (error) {
    logger.error('âŒ Error during shutdown:', error);
    process.exit(1);
  }
});

// PRODUCTION: Handle unhandled promise rejections
// Prevents server crashes from async errors
process.on('unhandledRejection', (reason: any, promise: Promise<any>) => {
  logger.error('âŒ [CRITICAL] Unhandled Promise Rejection:', {
    reason: reason?.message || reason,
    stack: reason?.stack,
    promise: promise
  });

  // In production, log and continue (don't crash)
  // In development, we want to know about these immediately
  if (env.NODE_ENV !== 'production') {
    console.error('ðŸ’¥ Unhandled Rejection Details:', reason);
  }
});

// PRODUCTION: Handle uncaught exceptions
// Last resort error handler - log and gracefully shutdown
process.on('uncaughtException', async (error: Error) => {
  logger.error('âŒ [FATAL] Uncaught Exception - Server shutting down:', {
    message: error.message,
    stack: error.stack,
    name: error.name
  });

  // Attempt graceful shutdown
  try {
    monitoring.shutdown();
    shutdownSecurity();
    if (webhookRenewalService) {
      webhookRenewalService.stopRenewalService();
    }
    await redis.close();
    await closePool();
    logger.info('âœ… Emergency shutdown completed');
  } catch (shutdownError) {
    logger.error('âŒ Error during emergency shutdown:', shutdownError);
  }

  // Exit with error code
  process.exit(1);
});

// Start server
initializeServices().then(() => {
        // ðŸ“¡ Gmail Webhook Endpoints
    
    // Webhook heartbeat tracking (for status monitoring)
    let webhookHeartbeat = {
      lastReceived: null as Date | null,
      totalReceived: 0,
      lastProcessed: null as Date | null,
      totalProcessed: 0
    };

    // Webhook endpoint to receive Gmail push notifications
    app.post('/webhooks/gmail', async (req, res) => {
      try {
        // Update heartbeat tracking
        webhookHeartbeat.lastReceived = new Date();
        webhookHeartbeat.totalReceived++;

        pinoLogger.info({
          totalReceived: webhookHeartbeat.totalReceived
        }, 'webhook.gmail.received');

        pinoLogger.debug({
          headers: req.headers,
          body: req.body
        }, 'webhook.gmail.raw_data');

        // Acknowledge receipt immediately (Google requires < 10 second response)
        res.status(200).send('OK');

        // Decode the Pub/Sub message
        if (req.body.message && req.body.message.data) {
          const messageData = Buffer.from(req.body.message.data, 'base64').toString();
          pinoLogger.debug({ messageData }, 'webhook.gmail.decoded');

          try {
            const notification = JSON.parse(messageData);
            pinoLogger.info({
              historyId: notification.historyId,
              emailAddress: notification.emailAddress
            }, 'webhook.gmail.notification_parsed');

            // PRODUCTION: Idempotency check to prevent duplicate processing
            // Use historyId as unique identifier for this webhook event
            const lockKey = `webhook:gmail:${notification.historyId || Date.now()}`;
            const lockAcquired = await redis.acquireLock(lockKey, 60); // âœ… PHASE 1: 1 min TTL (only for deduplication)

            if (!lockAcquired) {
              pinoLogger.warn({ historyId: notification.historyId }, 'webhook.gmail.duplicate_skipped');
              return;
            }

            pinoLogger.debug({ historyId: notification.historyId }, 'webhook.gmail.lock_acquired');

            // âœ… PHASE 1 OPTIMIZATION: Release lock immediately after deduplication check
            // Lock is only for preventing duplicate webhook acceptance, not for processing duration
            // This allows next webhook to be accepted while previous one is still processing
            setTimeout(() => {
              redis.releaseLock(lockKey).catch(err => {
                pinoLogger.debug({
                  lockKey,
                  error: err instanceof Error ? err.message : String(err)
                }, 'webhook.gmail.lock_release_error');
              });
            }, 100); // Release after 100ms (ensures dedup window)

            // Process the notification asynchronously FOR ALL ACTIVE USERS (non-blocking)
            processGmailNotificationMultiUser(notification).then(() => {
              // Update processing heartbeat
              webhookHeartbeat.lastProcessed = new Date();
              webhookHeartbeat.totalProcessed++;
              pinoLogger.info({
                historyId: notification.historyId,
                totalProcessed: webhookHeartbeat.totalProcessed
              }, 'webhook.gmail.processing_complete');
            }).catch(error => {
              pinoLogger.error({
                historyId: notification.historyId,
                error: error instanceof Error ? error.message : String(error)
              }, 'webhook.gmail.processing_failed');
            });
          } catch (parseError) {
            pinoLogger.error({
              error: parseError instanceof Error ? parseError.message : String(parseError),
              messageData
            }, 'webhook.gmail.parse_error');
          }
        }

      } catch (error) {
        pinoLogger.error({
          error: error instanceof Error ? error.message : String(error)
        }, 'webhook.gmail.handler_error');
        // Response already sent on line 2704, don't send again
      }
    });

    // ðŸ§ª Test endpoint to manually trigger webhook processing (for testing)
    app.post('/test-webhook', async (_req, res) => {
      try {
        console.log('ðŸ§ª Manual webhook test triggered...');

        // Simulate a Gmail webhook notification (general notification, not specific email)
        const testNotification = {
          historyId: Date.now().toString(),
          messageId: null // This will trigger the "check recent emails" flow
        };

        // âœ… PHASE 1: Process asynchronously like production webhook handler
        processGmailNotificationMultiUser(testNotification).catch(error => {
          console.error('âŒ Test webhook processing failed:', error);
        });

        // Respond immediately (mimics production behavior)
        res.json({
          message: 'Test webhook dispatched (processing in background)',
          notification: testNotification,
          timestamp: new Date(),
          note: 'Check logs for processing status'
        });
      } catch (error) {
        console.error('âŒ Error in test webhook:', error);
        res.status(500).json({ error: 'Test webhook dispatch failed' });
      }
    });

    // ðŸŽ¯ Test endpoint to specifically test smart filtering logic
    app.post('/test-smart-filtering', authMiddleware.authenticate, async (req, res) => {
      try {
        const userId = getUserId(req);
        console.log('ðŸŽ¯ Testing smart filtering with provided email data...');
        
        const { from, subject, body } = req.body;
        if (!from || !subject || !body) {
          return res.status(400).json({ error: 'Missing required fields: from, subject, body' });
        }
        
        // Create mock email data to test filtering
        const mockEmail = {
          from: from,
          subject: subject,
          body: body
        };
        
        console.log('ðŸ“§ Testing email:', mockEmail);
        
        // Test the smart filtering logic
        const filterResult = await shouldGenerateResponseForEmail(mockEmail, userId);
        
        console.log(`ðŸ¤– Filter Result: ${filterResult.generate ? 'âœ… PROCESS' : 'âŒ SKIP'} - ${filterResult.reason}`);
        
        res.json({
          message: 'Smart filtering test completed',
          email: mockEmail,
          filterResult: filterResult,
          timestamp: new Date()
        });
        
      } catch (error) {
        console.error('âŒ Error in smart filtering test:', error);
        res.status(500).json({ error: 'Smart filtering test failed' });
      }
    });

    // ðŸ” Database verification endpoint for testing draft management
    app.get('/debug/draft-database/:id', async (req, res) => {
      try {
        const draftId = parseInt(req.params.id);
        console.log(`ðŸ” Database check for draft ID: ${draftId}`);
        
        // Query the database directly to see raw data
        const query = 'SELECT * FROM auto_generated_drafts WHERE id = $1';
        const result = await pool.query(query, [draftId]);
        
        if (result.rows.length === 0) {
          return res.status(404).json({ error: 'Draft not found in database' });
        }
        
        const draftData = result.rows[0];
        console.log('ðŸ“Š Raw database data:', draftData);
        
        res.json({
          message: 'Database verification completed',
          rawDatabaseData: draftData,
          timestamp: new Date()
        });
        
      } catch (error) {
        console.error('âŒ Error in database verification:', error);
        res.status(500).json({ error: 'Database verification failed' });
      }
    });

    // ðŸš€ PHASE 3: Intelligent Router Test Endpoint
    app.post('/test-intelligent-router', authMiddleware.authenticate, async (req, res) => {
      try {
        const userId = getUserId(req);
        const { testEmails } = req.body;
        
        console.log(`ðŸ§ª [ROUTER TEST] Testing intelligent router with ${testEmails?.length || 'default'} emails...`);
        
        // Default test emails if none provided
        const defaultTestEmails = [
          {
            id: 'test-meeting-1',
            from: 'colleague@work.com',
            to: 'user@company.com',
            subject: 'Coffee tomorrow?',
            body: 'Hey! Are you free for coffee tomorrow at 2 PM? Would love to catch up on the project.',
            date: new Date().toISOString(),
            threadId: 'test-thread-1',
            snippet: 'Coffee tomorrow at 2 PM'
          },
          {
            id: 'test-meeting-2',
            from: 'client@company.com',
            to: 'user@company.com',
            subject: 'Meeting request for next week',
            body: 'Hi, could we schedule a meeting to discuss the quarterly results? I\'m available next week.',
            date: new Date().toISOString(),
            threadId: 'test-thread-2',
            snippet: 'Meeting request for next week'
          },
          {
            id: 'test-regular-1',
            from: 'teammate@company.com',
            to: 'user@company.com',
            subject: 'Project update',
            body: 'Here\'s the latest update on the project. Please review the attached documents.',
            date: new Date().toISOString(),
            threadId: 'test-thread-3',
            snippet: 'Project update with documents'
          },
          {
            id: 'test-newsletter-1',
            from: 'newsletter@marketing.com',
            to: 'user@company.com',
            subject: 'Weekly Newsletter - Tech Updates',
            body: 'This week in tech: AI advances, new frameworks, and industry news.',
            date: new Date().toISOString(),
            threadId: 'test-thread-4',
            snippet: 'Weekly tech newsletter'
          }
        ];
        
        const emailsToTest = testEmails || defaultTestEmails;
        
        // Test routing for each email
        const routingResults = [];
        for (const email of emailsToTest) {
          console.log(`ðŸ§  [ROUTER TEST] Testing email: "${email.subject}"`);
          
          const routingResult = await intelligentEmailRouter.routeEmail(email, userId, undefined, true); // Test mode
          routingResults.push(routingResult);
          
          console.log(`âœ… [ROUTER TEST] Result: ${routingResult.routingDecision.route.toUpperCase()} (${routingResult.routingDecision.confidence}%)`);
        }
        
        // Generate statistics
        const stats = intelligentEmailRouter.getRoutingStats(routingResults);
        
        console.log(`ðŸ“Š [ROUTER TEST] Stats:`, stats);
        
        res.json({
          message: 'Intelligent router test completed',
          testResults: routingResults,
          statistics: stats,
          summary: {
            totalEmails: routingResults.length,
            meetingRouted: stats.routing.meeting,
            autoDraftRouted: stats.routing.autoDraft,
            skipped: stats.routing.skipped,
            avgProcessingTime: stats.performance.avgProcessingTime,
            avgConfidence: stats.performance.avgConfidence,
            successRate: stats.performance.successRate
          }
        });
        
      } catch (error) {
        console.error('âŒ Intelligent router test failed:', error);
        res.status(500).json({ 
          error: 'Intelligent router test failed',
          details: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // ðŸš€ PHASE 3: Intelligent Router Health Check Endpoint
    app.get('/health/intelligent-router', async (_req, res) => {
      try {
        console.log('ðŸ¥ [ROUTER HEALTH] Running intelligent router health check...');
        
        const healthCheck = await intelligentEmailRouter.healthCheck();
        
        const statusCode = healthCheck.status === 'healthy' ? 200 : 
                          healthCheck.status === 'degraded' ? 206 : 503;
        
        console.log(`ðŸ¥ [ROUTER HEALTH] Status: ${healthCheck.status}`, healthCheck);
        
        res.status(statusCode).json({
          service: 'intelligent-email-router',
          status: healthCheck.status,
          timestamp: new Date().toISOString(),
          components: {
            openAIClassifier: healthCheck.openAIClassifier,
            meetingPipeline: healthCheck.meetingPipeline,
            responseService: healthCheck.responseService,
            autoDraftModel: healthCheck.autoDraftModel
          },
          overallHealth: healthCheck.overallHealth
        });
        
      } catch (error) {
        console.error('âŒ Intelligent router health check failed:', error);
        res.status(503).json({ 
          service: 'intelligent-email-router',
          status: 'error',
          timestamp: new Date().toISOString(),
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // ðŸ§ª Test endpoint to manually create a draft for testing draft management
    app.post('/test-create-draft', async (_req, res) => {
      try {
        console.log('ðŸ§ª Manually creating test draft for draft management testing...');
        
        const testDraftData = {
          draft_id: `test_draft_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`,
          original_email_id: 66, // Real email ID from database
          subject: 'Re: Test Email for Draft Management',
          body: 'This is a test draft created to verify the draft management API suite is working correctly. Please feel free to edit, approve, or manage this draft.',
          tone: 'professional',
          urgency_level: 'medium',
          context_used: {
            sources: ['test_context'],
            confidence: 0.95
          },
          relationship_type: 'test',
          processing_time_ms: 1000
        };
        
        const draftId = await autoGeneratedDraftModel.createDraft(testDraftData);
        
        console.log(`âœ… Test draft created with ID: ${draftId}`);
        
        res.json({
          message: 'Test draft created successfully',
          draftId: draftId,
          draftData: testDraftData,
          timestamp: new Date(),
          nextSteps: [
            `GET /auto-drafts/${draftId} - View the draft`,
            `PUT /auto-drafts/${draftId} - Edit the draft`,
            `POST /auto-drafts/${draftId}/approve - Approve the draft`,
            `GET /debug/draft-database/${draftId} - Check database state`
          ]
        });
        
      } catch (error) {
        console.error('âŒ Error creating test draft:', error);
        res.status(500).json({ error: 'Failed to create test draft' });
      }
    });

    // ðŸš€ MULTI-USER WEBHOOK PROCESSING - Processes emails for the specific user in notification
    async function processGmailNotificationMultiUser(notification: any) {
      try {
        pinoLogger.debug({ emailAddress: notification.emailAddress }, 'webhook.multiuser.start');

        // Extract target email from notification
        const targetEmail = notification.emailAddress;
        if (!targetEmail) {
          pinoLogger.warn('webhook.multiuser.no_target_fallback_all');

          // Fallback: Get all users with active webhooks
          const activeUsers = await tokenStorageService.getActiveWebhookUsers();
          pinoLogger.info({ activeUserCount: activeUsers.length }, 'webhook.multiuser.active_users');

          if (activeUsers.length === 0) {
            pinoLogger.warn('webhook.multiuser.no_active_users');
            return;
          }

          // Process notification for each active user
          const processingPromises = activeUsers.map(async (userTokens) => {
            try {
              pinoLogger.debug({
                userId: sanitizeUserId(userTokens.userId),
                gmailAddress: userTokens.gmailAddress
              }, 'webhook.user.processing_start');

              // âœ… CRITICAL SECURITY FIX: Create isolated service container for each user
              // This prevents User A's webhook from accessing User B's data during concurrent processing
              const { ServiceFactory } = await import('./utils/serviceFactory');
              const services = ServiceFactory.createForUser(userTokens.userId);
              const gmail = await services.getGmailService();

              // Process the notification for this user with isolated gmail service
              await processGmailNotificationForUser(notification, userTokens.userId, gmail);

              pinoLogger.info({
                userId: sanitizeUserId(userTokens.userId),
                gmailAddress: userTokens.gmailAddress
              }, 'webhook.user.processing_complete');
            } catch (userError) {
              pinoLogger.error({
                userId: sanitizeUserId(userTokens.userId),
                gmailAddress: userTokens.gmailAddress,
                error: userError instanceof Error ? userError.message : String(userError)
              }, 'webhook.user.processing_failed');

              // If the error is auth-related, disable webhook for this user
              const errorMessage = userError instanceof Error ? userError.message : String(userError);
              if (errorMessage?.includes('invalid_grant') || errorMessage?.includes('unauthorized')) {
                pinoLogger.warn({
                  userId: sanitizeUserId(userTokens.userId),
                  gmailAddress: userTokens.gmailAddress
                }, 'webhook.user.auth_failed_disabling');
                await tokenStorageService.disableWebhookForUser(userTokens.userId, 'Authentication failed during webhook processing');
              }
            }
          });

          // âœ… PHASE 1 OPTIMIZATION: Fire and forget - don't block webhook handler
          // Process in background, track results for monitoring
          Promise.allSettled(processingPromises)
            .then(results => {
              const succeeded = results.filter(r => r.status === 'fulfilled').length;
              const failed = results.filter(r => r.status === 'rejected').length;

              pinoLogger.info({
                total: results.length,
                succeeded,
                failed,
                historyId: notification.historyId
              }, 'webhook.multiuser.fallback_batch_complete');

              if (failed > 0) {
                pinoLogger.warn({
                  failed,
                  total: results.length,
                  historyId: notification.historyId
                }, 'webhook.multiuser.fallback_some_failed');
              }
            })
            .catch(error => {
              pinoLogger.error({
                error: error instanceof Error ? error.message : String(error),
                historyId: notification.historyId
              }, 'webhook.multiuser.fallback_batch_error');
            });

          // Return immediately - don't wait for processing
          return;
        }

        pinoLogger.info({ targetEmail }, 'webhook.multiuser.specific_target');

        // Find the specific user ID for this notification
        const targetUserId = await tokenStorageService.getUserIdByEmail(targetEmail);
        if (!targetUserId) {
          pinoLogger.warn({ targetEmail }, 'webhook.multiuser.user_not_found');
          return;
        }

        // Get the user's tokens to check if webhook is active
        const targetUserTokens = await tokenStorageService.getUserTokens(targetUserId);
        if (!targetUserTokens || !targetUserTokens.webhookActive) {
          pinoLogger.warn({
            targetEmail,
            userId: sanitizeUserId(targetUserId)
          }, 'webhook.multiuser.webhook_not_active');
          return;
        }

        pinoLogger.debug({
          userId: sanitizeUserId(targetUserId),
          gmailAddress: targetUserTokens.gmailAddress
        }, 'webhook.multiuser.target_found');

        // Process notification for the specific user only
        const processingPromises = [targetUserTokens].map(async (userTokens) => {
          try {
            pinoLogger.debug({
              userId: sanitizeUserId(userTokens.userId),
              gmailAddress: userTokens.gmailAddress
            }, 'webhook.user.processing_start');

            // âœ… CRITICAL SECURITY FIX: Create isolated service container for this user
            const { ServiceFactory } = await import('./utils/serviceFactory');
            const services = ServiceFactory.createForUser(userTokens.userId);
            const gmail = await services.getGmailService();

            // Process the notification for this user with isolated gmail service
            await processGmailNotificationForUser(notification, userTokens.userId, gmail);

            pinoLogger.info({
              userId: sanitizeUserId(userTokens.userId),
              gmailAddress: userTokens.gmailAddress
            }, 'webhook.user.processing_complete');
          } catch (userError) {
            pinoLogger.error({
              userId: sanitizeUserId(userTokens.userId),
              gmailAddress: userTokens.gmailAddress,
              error: userError instanceof Error ? userError.message : String(userError)
            }, 'webhook.user.processing_failed');

            // If the error is auth-related, disable webhook for this user
            const errorMessage = userError instanceof Error ? userError.message : String(userError);
            if (errorMessage?.includes('invalid_grant') || errorMessage?.includes('unauthorized')) {
              pinoLogger.warn({
                userId: sanitizeUserId(userTokens.userId),
                gmailAddress: userTokens.gmailAddress
              }, 'webhook.user.auth_failed_disabling');
              await tokenStorageService.disableWebhookForUser(userTokens.userId, 'Authentication failed during webhook processing');
            }
          }
        });

        // âœ… PHASE 1 OPTIMIZATION: Fire and forget - don't block webhook handler
        // Process in background, track results for monitoring
        Promise.allSettled(processingPromises)
          .then(results => {
            const succeeded = results.filter(r => r.status === 'fulfilled').length;
            const failed = results.filter(r => r.status === 'rejected').length;

            pinoLogger.info({
              total: results.length,
              succeeded,
              failed,
              targetEmail,
              historyId: notification.historyId
            }, 'webhook.multiuser.specific_complete');

            if (failed > 0) {
              pinoLogger.error({
                targetEmail,
                historyId: notification.historyId
              }, 'webhook.multiuser.specific_failed');
            }
          })
          .catch(error => {
            pinoLogger.error({
              error: error instanceof Error ? error.message : String(error),
              targetEmail,
              historyId: notification.historyId
            }, 'webhook.multiuser.specific_batch_error');
          });

        // Return immediately - don't wait for processing
        pinoLogger.info({ targetEmail }, 'webhook.multiuser.dispatched');

      } catch (error) {
        pinoLogger.error({
          error: error instanceof Error ? error.message : String(error)
        }, 'webhook.multiuser.critical_error');
      }
    }
    
    // ðŸš€ ENHANCED FUNCTION TO PROCESS GMAIL NOTIFICATIONS FOR A SPECIFIC USER
    // âœ… SECURITY FIX: Now accepts gmail service instance parameter for per-user isolation
    async function processGmailNotificationForUser(notification: any, userId: string, gmail: any) {
      const startTime = Date.now();
      try {
        pinoLogger.info({
          userId: sanitizeUserId(userId),
          historyId: notification.historyId
        }, 'webhook.email.processing_start');

        const historyId = notification.historyId;
        pinoLogger.debug({ historyId }, 'webhook.email.history_id');

        let emailsToProcess: any[] = [];

        // Step 1: Extract email data based on notification type
        if (notification.messageId) {
          pinoLogger.debug({ messageId: notification.messageId }, 'webhook.email.specific_received');

          // Fetch the specific email using isolated service
          const email = await gmail.getEmailByMessageId(notification.messageId);
          if (email) {
            // Check if this specific email has been processed by webhook FOR THIS USER
            const existingEmail = await emailModel.getEmailByGmailId(email.id, userId);
            if (!existingEmail || !existingEmail.webhook_processed) {
              emailsToProcess = [email];
              const parsedEmail = gmail.parseEmail(email);
              pinoLogger.debug({
                subject: parsedEmail.subject,
                webhookProcessed: existingEmail?.webhook_processed || 'new'
              }, 'webhook.email.queue_added');
            } else {
              const parsedEmail = gmail.parseEmail(email);
              pinoLogger.debug({ subject: parsedEmail.subject }, 'webhook.email.already_processed');
              emailsToProcess = [];
            }
          }
        } else {
          pinoLogger.debug('webhook.email.checking_recent');

          // Get recent emails using isolated service
          const recentEmails = await gmail.getRecentEmails(5);

          for (const email of recentEmails) {
            // Check if we've already processed this email via webhook FOR THIS USER
            const existingEmail = await emailModel.getEmailByGmailId(email.id, userId);
            if (!existingEmail || !existingEmail.webhook_processed) {
              emailsToProcess.push(email);
              const parsedEmail = gmail.parseEmail(email);
              pinoLogger.debug({
                subject: parsedEmail.subject,
                webhookProcessed: existingEmail?.webhook_processed || 'new'
              }, 'webhook.email.queue_added');
            } else {
              const parsedEmail = gmail.parseEmail(email);
              pinoLogger.debug({ subject: parsedEmail.subject }, 'webhook.email.already_processed_skip');
            }
          }
        }

        pinoLogger.info({
          emailCount: emailsToProcess.length,
          userId: sanitizeUserId(userId)
        }, 'webhook.email.found_to_process');

        // NEW: Extract email processing into separate function for parallel processing
        async function processEmailSafe(emailData: any): Promise<{
          status: 'success' | 'skipped' | 'duplicate' | 'error';
          emailId: string;
          reason?: string;
          processingTime?: number;
        }> {
          const processingStartTime = Date.now();

          try {
            // Parse email content
            const parsedEmail = gmail.parseEmail(emailData);
            pinoLogger.debug({
              subject: parsedEmail.subject,
              from: parsedEmail.from,
              userId: sanitizeUserId(userId)
            }, 'webhook.email.parallel.processing');

            // Step 3: Smart email filtering
            const shouldGenerateResponse = await shouldGenerateResponseForEmail(parsedEmail, userId);
            if (!shouldGenerateResponse.generate) {
              pinoLogger.debug({
                subject: parsedEmail.subject,
                reason: shouldGenerateResponse.reason
              }, 'webhook.email.parallel.skipped');

              // Atomically save email and mark as webhook processed FOR THIS USER (even though no draft was generated)
              const result = await emailModel.saveEmailAndMarkAsWebhookProcessedForUser(parsedEmail, userId);
              if (result.success) {
                pinoLogger.debug({ emailId: result.emailId }, 'webhook.email.parallel.marked_filtered');
              }
              return {
                status: 'skipped',
                emailId: parsedEmail.id,
                reason: shouldGenerateResponse.reason,
                processingTime: Date.now() - processingStartTime
              };
            }

            pinoLogger.debug({
              subject: parsedEmail.subject,
              reason: shouldGenerateResponse.reason
            }, 'webhook.email.parallel.qualifies');

            // Step 4: Atomically save email and mark as webhook processed FOR THIS USER
            const result = await emailModel.saveEmailAndMarkAsWebhookProcessedForUser(parsedEmail, userId);
            if (!result.success) {
              pinoLogger.debug({ subject: parsedEmail.subject }, 'webhook.email.parallel.duplicate');
              return {
                status: 'duplicate',
                emailId: parsedEmail.id,
                processingTime: Date.now() - processingStartTime
              };
            }

            const emailId = result.emailId!;

            // ðŸš€ PHASE 3: Process email through intelligent router (replaces dual processing)
            pinoLogger.debug({ emailId: parsedEmail.id }, 'webhook.email.parallel.routing');
            const routingResult = await intelligentEmailRouter.routeEmail(
              parsedEmail,
              userId,
              emailId // Use the email DB ID we already have
            );

            pinoLogger.info({
              emailId,
              subject: parsedEmail.subject,
              route: routingResult.routingDecision.route,
              reasoning: routingResult.routingDecision.reasoning,
              userId: sanitizeUserId(userId)
            }, 'webhook.email.parallel.routed');

            if (routingResult.meetingResult?.isMeetingRequest) {
              pinoLogger.info({
                emailId,
                meetingType: routingResult.meetingResult.meetingRequest?.meetingType,
                confidence: routingResult.meetingResult.confidence,
                actionTaken: routingResult.meetingResult.response?.actionTaken
              }, 'webhook.email.parallel.meeting_detected');
            } else if (routingResult.autoDraftResult) {
              pinoLogger.info({
                emailId,
                draftSubject: routingResult.autoDraftResult.subject,
                tone: routingResult.autoDraftResult.tone,
                urgency: routingResult.autoDraftResult.urgencyLevel
              }, 'webhook.email.parallel.draft_generated');
            }

            const totalProcessingTime = Date.now() - processingStartTime;
            pinoLogger.debug({
              emailId,
              processingTime: totalProcessingTime
            }, 'webhook.email.parallel.timing');

            return {
              status: 'success',
              emailId: parsedEmail.id,
              processingTime: totalProcessingTime
            };

          } catch (emailError) {
            pinoLogger.error({
              emailId: emailData.id || 'unknown',
              error: emailError instanceof Error ? emailError.message : String(emailError),
              userId: sanitizeUserId(userId)
            }, 'webhook.email.parallel.error');
            return {
              status: 'error',
              emailId: emailData.id || 'unknown',
              reason: emailError instanceof Error ? emailError.message : 'Unknown error',
              processingTime: Date.now() - processingStartTime
            };
          }
        }

        // Step 2: Process emails in parallel with concurrency limit (SAFE PARALLEL PROCESSING)
        if (emailsToProcess.length > 0) {
          const CONCURRENCY_LIMIT = 3; // Limit concurrent API calls to avoid rate limits
          pinoLogger.info({
            emailCount: emailsToProcess.length,
            concurrencyLimit: CONCURRENCY_LIMIT,
            userId: sanitizeUserId(userId)
          }, 'webhook.email.parallel.batch_start');

          const processWithConcurrencyLimit = async (): Promise<Array<{
            status: 'success' | 'skipped' | 'duplicate' | 'error';
            emailId: string;
            reason?: string;
            processingTime?: number;
          }>> => {
            const results: Array<{
              status: 'success' | 'skipped' | 'duplicate' | 'error';
              emailId: string;
              reason?: string;
              processingTime?: number;
            }> = [];

            for (let i = 0; i < emailsToProcess.length; i += CONCURRENCY_LIMIT) {
              const batch = emailsToProcess.slice(i, i + CONCURRENCY_LIMIT);
              const batchNumber = Math.floor(i / CONCURRENCY_LIMIT) + 1;
              pinoLogger.debug({
                batchNumber,
                batchSize: batch.length
              }, 'webhook.email.parallel.batch_processing');

              // Process batch in parallel using Promise.allSettled for safe error handling
              const batchPromises = batch.map(emailData => processEmailSafe(emailData));
              const batchResults = await Promise.allSettled(batchPromises);

              // Extract results and log any failures
              batchResults.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                  results.push(result.value);
                } else {
                  pinoLogger.error({
                    batchNumber,
                    emailIndex: index + 1,
                    error: result.reason?.message || 'Unknown error'
                  }, 'webhook.email.parallel.batch_failed');
                  results.push({
                    status: 'error',
                    emailId: batch[index]?.id || 'unknown',
                    reason: result.reason?.message || 'Unknown error'
                  });
                }
              });

              // Small delay between batches to be gentle on APIs
              if (i + CONCURRENCY_LIMIT < emailsToProcess.length) {
                await new Promise(resolve => setTimeout(resolve, 100));
              }
            }

            return results;
          };

          const processingResults = await processWithConcurrencyLimit();

          // Log processing summary
          const successful = processingResults.filter(r => r.status === 'success').length;
          const skipped = processingResults.filter(r => r.status === 'skipped').length;
          const duplicates = processingResults.filter(r => r.status === 'duplicate').length;
          const errors = processingResults.filter(r => r.status === 'error').length;

          pinoLogger.info({
            successful,
            skipped,
            duplicates,
            errors,
            totalEmails: processingResults.length,
            userId: sanitizeUserId(userId)
          }, 'webhook.email.parallel.summary');
        } else {
          pinoLogger.debug({ userId: sanitizeUserId(userId) }, 'webhook.email.no_emails_to_process');
        }

        const totalTime = Date.now() - startTime;
        pinoLogger.info({
          totalTime,
          userId: sanitizeUserId(userId),
          historyId: notification.historyId
        }, 'webhook.email.processing_complete');

      } catch (error) {
        pinoLogger.error({
          error: error instanceof Error ? error.message : String(error),
          userId: sanitizeUserId(userId),
          historyId: notification.historyId
        }, 'webhook.email.processing_error');
        
        // Graceful degradation - store for manual processing
        await _storeFailedNotification(notification, error);
      }
    }

    // Smart Email Filtering Function (Phase 2 from roadmap)
    async function shouldGenerateResponseForEmail(email: any, userId: string): Promise<{generate: boolean, reason: string, classification?: string}> {
      const fromEmail = email.from.toLowerCase();
      const subject = email.subject;
      const body = email.body;

      pinoLogger.debug({
        subject,
        from: fromEmail,
        userId: sanitizeUserId(userId)
      }, 'webhook.filter.start');

      // ðŸ›¡ï¸ INFINITE LOOP PREVENTION - TEMPORARILY DISABLED FOR TESTING
      // TODO: Re-enable with smarter logic that doesn't block user's own email
      /*
      const aiSenderPatterns = [
        'parthahir012001@gmail.com',    // Main AI account
        'chief-ai@', 'ai-assistant@', 'auto-reply@', 'automated@', 'bot@',
        '@mailchimp.com', '@sendgrid.net', '@amazonses.com', 
        '@notifications.', '@alerts.', '@updates.', '@marketing.',
        '@calendar-notification', '@calendly.', '@zoom.us', '@teams.microsoft.com',
        '@facebookmail.com', '@linkedin.com', '@twitter.com', '@instagram.com',
        'mail-noreply@google.com'
      ];

      const aiSubjectPatterns = [
        '[AUTO-GENERATED]', '[AI RESPONSE]', '[AUTOMATED REPLY]', 
        'Auto-Reply:', 'Out of Office:', 'Vacation Response:', 'Automatic Reply:'
      ];

      const aiBodyPatterns = [
        'This email was automatically generated', 'Auto-generated by Chief AI',
        'Automated response from', 'This is an automated message',
        'Do not reply to this email', 'Generated by AI Assistant',
        'Powered by Chief AI', 'This email was sent automatically'
      ];

      // Check sender patterns
      for (const pattern of aiSenderPatterns) {
        if (fromEmail.includes(pattern.toLowerCase())) {
          console.log(`ðŸ›‘ [INFINITE LOOP PREVENTION] Blocked AI sender: ${pattern}`);
          return { generate: false, reason: `Infinite loop prevention: AI sender pattern "${pattern}" detected` };
        }
      }

      // Check subject patterns
      for (const pattern of aiSubjectPatterns) {
        if (subject.toLowerCase().includes(pattern.toLowerCase())) {
          console.log(`ðŸ›‘ [INFINITE LOOP PREVENTION] Blocked AI subject: ${pattern}`);
          return { generate: false, reason: `Infinite loop prevention: AI subject pattern "${pattern}" detected` };
        }
      }

      // Check body patterns
      for (const pattern of aiBodyPatterns) {
        if (body.toLowerCase().includes(pattern.toLowerCase())) {
          console.log(`ðŸ›‘ [INFINITE LOOP PREVENTION] Blocked AI body content: ${pattern}`);
          return { generate: false, reason: `Infinite loop prevention: AI body pattern "${pattern}" detected` };
        }
      }
      */

      pinoLogger.debug({
        subject,
        from: fromEmail
      }, 'webhook.filter.loop_prevention_disabled');

      // Skip no-reply addresses (fast check)
      const noReplyPatterns = ['no-reply', 'noreply', 'do-not-reply', 'donotreply'];
      if (noReplyPatterns.some(pattern => fromEmail.includes(pattern))) {
        return { generate: false, reason: 'No-reply email address' };
      }

      // Skip obvious auto-generated emails (fast check)
      const autoGenerated = ['automated', 'auto-generated', 'system generated', 'bounce', 'delivery failure'];
      if (autoGenerated.some(keyword => subject.toLowerCase().includes(keyword)) ||
          autoGenerated.some(keyword => body.toLowerCase().includes(keyword.toLowerCase()))) {
        return { generate: false, reason: 'Auto-generated email detected' };
      }

      // Use AI classification for newsletter vs personal email detection
      try {
        const classification = await aiService.classifyEmail(subject, body, fromEmail);
        
        if (classification === 'newsletter') {
          // ðŸ†• NEW: Save promotional email instead of just discarding
          try {
            await promotionalEmailModel.savePromotionalEmail({
              gmail_id: email.id,
              user_id: userId,
              thread_id: email.threadId,
              subject: email.subject,
              from_email: email.from,
              to_email: email.to,
              body: email.body,
              classification_reason: 'newsletter',
              received_at: email.date
            });
            pinoLogger.info({
              userId: sanitizeUserId(userId),
              subject
            }, 'webhook.filter.promotional_saved');
          } catch (saveError) {
            pinoLogger.error({
              userId: sanitizeUserId(userId),
              error: saveError instanceof Error ? saveError.message : String(saveError)
            }, 'webhook.filter.promotional_save_failed');
            // Continue with filtering even if save fails
          }

          return { generate: false, reason: 'AI classified as newsletter/promotional content', classification: 'newsletter' };
        } else {
          return { generate: true, reason: 'AI classified as personal/business communication', classification: 'personal' };
        }
      } catch (error) {
        pinoLogger.error({
          userId: sanitizeUserId(userId),
          error: error instanceof Error ? error.message : String(error)
        }, 'webhook.filter.classification_failed');
        return { generate: true, reason: 'AI classification failed - defaulting to process' };
      }
    }
    
    // Helper function to store processing results
    async function _storeProcessingResult(result: any) {
      try {
        // Store in database for dashboard display
        // This would be implemented based on your database schema
        console.log(`ðŸ’¾ Storing processing result: ${result.type}`);
      } catch (error) {
        console.error('âŒ Failed to store processing result:', error);
      }
    }
    
    // Helper function for failed notifications  
    async function _storeFailedNotification(_notification: any, _error: any) {
      try {
        console.log('ðŸ’¾ Storing failed notification for manual review...');
        // Store failed notification for manual processing
      } catch (storeError) {
        console.error('âŒ Failed to store failed notification:', storeError);
      }
    }

    // Set up Gmail watch for ALL active users (multi-user webhook setup)
    app.post('/gmail/setup-webhook-all-users', async (_req, res) => {
      try {
        console.log('ðŸ“¡ Setting up Gmail webhooks for ALL active users...');

        if (!gmailService) {
          return res.status(500).json({ error: 'Gmail service not initialized' });
        }

        // Get all active webhook users
        const activeUsers = await tokenStorageService.getActiveWebhookUsers();
        console.log(`ðŸ‘¥ Found ${activeUsers.length} active users for webhook setup`);

        if (activeUsers.length === 0) {
          return res.status(400).json({ error: 'No active webhook users found' });
        }

        const results = [];
        
        // Set up webhook for each active user
        for (const userTokens of activeUsers) {
          try {
            console.log(`ðŸ“¡ Setting up webhook for user: ${userTokens.gmailAddress}`);

            // âœ… CRITICAL SECURITY FIX: Create isolated service container for each user
            const { ServiceFactory } = await import('./utils/serviceFactory');
            const services = ServiceFactory.createForUser(userTokens.userId);
            const gmail = await services.getGmailService();

            // Set up webhook for this user with isolated service
            const watchResponse = await gmail.setupWebhook();

            results.push({
              user: userTokens.gmailAddress,
              success: true,
              watchResponse,
              expiration: new Date(parseInt(watchResponse.expiration)).toISOString()
            });

            console.log(`âœ… Webhook setup successful for ${userTokens.gmailAddress}`);
            
          } catch (userError) {
            console.error(`âŒ Failed to setup webhook for ${userTokens.gmailAddress}:`, userError);
            results.push({
              user: userTokens.gmailAddress,
              success: false,
              error: userError instanceof Error ? userError.message : String(userError)
            });
          }
        }

        const successCount = results.filter(r => r.success).length;
        
        res.json({
          message: `Gmail webhooks setup completed for ${successCount}/${activeUsers.length} users`,
          results,
          totalUsers: activeUsers.length,
          successfulSetups: successCount
        });

      } catch (error) {
        console.error('âŒ Error setting up Gmail webhooks for all users:', error);
        res.status(500).json({ error: 'Failed to setup Gmail webhooks for all users' });
      }
    });

    // Set up Gmail watch (subscribe to push notifications) - single user
    // âš ï¸ DEPRECATED: Unauthenticated endpoint using global singleton
    // TODO: Remove this endpoint - webhook setup now happens automatically after OAuth
    app.post('/gmail/setup-webhook', async (_req, res) => {
      try {
        console.log('ðŸ“¡ Setting up Gmail webhook...');

        if (!gmailService) {
          return res.status(500).json({ error: 'Gmail service not initialized' });
        }

        // âš ï¸ SECURITY ISSUE: Using global singleton - only safe for single-user testing
        // Check if we have valid credentials
        try {
          await gmailService.checkCredentials();
        } catch (error) {
          return res.status(401).json({
            error: 'No valid Gmail credentials. Please complete OAuth flow first.',
            suggestion: 'Visit /auth to authenticate'
          });
        }

        const watchResponse = await gmailService.setupWebhook();
        
        res.json({
          message: 'Gmail webhook setup successfully',
          watchResponse: watchResponse,
          webhookUrl: watchResponse.webhookUrl, // Use the actual webhook URL from the response
          expiration: new Date(parseInt(watchResponse.expiration)).toISOString()
        });

      } catch (error) {
        console.error('âŒ Error setting up Gmail webhook:', error);
        res.status(500).json({ error: 'Failed to setup Gmail webhook' });
      }
    });

    // Check webhook status
    // âš ï¸ DEPRECATED: Unauthenticated endpoint using global singleton
    // TODO: Add authentication or remove this endpoint
    app.get('/gmail/webhook-status', async (_req, res) => {
      try {
        console.log('ðŸ” Checking Gmail webhook status...');

        // âš ï¸ SECURITY ISSUE: Using global singleton - only safe for single-user testing
        const status = await gmailService.getWebhookStatus();
        
        res.json({
          message: 'Gmail webhook status retrieved',
          status: status
        });

      } catch (error) {
        console.error('âŒ Error checking webhook status:', error);
        res.status(500).json({ error: 'Failed to check webhook status' });
      }
    });

    // Get webhook heartbeat status (for live monitoring)
    app.get('/webhooks/status', async (_req, res) => {
      try {
        const now = new Date();
        const lastReceived = webhookHeartbeat.lastReceived;
        const lastProcessed = webhookHeartbeat.lastProcessed;
        
        // Calculate time since last webhook
        const timeSinceLastWebhook = lastReceived ? now.getTime() - lastReceived.getTime() : null;
        const timeSinceLastProcessed = lastProcessed ? now.getTime() - lastProcessed.getTime() : null;
        
        // Determine health status
        let healthStatus = 'unknown';
        if (lastReceived) {
          if (timeSinceLastWebhook! < 300000) { // 5 minutes
            healthStatus = 'healthy';
          } else if (timeSinceLastWebhook! < 900000) { // 15 minutes
            healthStatus = 'warning';
          } else {
            healthStatus = 'unhealthy';
          }
        }
        
        res.json({
          message: 'Webhook heartbeat status retrieved',
          heartbeat: {
            health: healthStatus,
            lastReceived: lastReceived,
            lastProcessed: lastProcessed,
            totalReceived: webhookHeartbeat.totalReceived,
            totalProcessed: webhookHeartbeat.totalProcessed,
            timeSinceLastWebhook: timeSinceLastWebhook,
            timeSinceLastProcessed: timeSinceLastProcessed
          }
        });

      } catch (error) {
        console.error('âŒ Error getting webhook heartbeat:', error);
        res.status(500).json({ error: 'Failed to get webhook heartbeat' });
      }
    });

    // Stop webhook (unsubscribe)
    // âš ï¸ DEPRECATED: Unauthenticated endpoint using global singleton
    // TODO: Add authentication or remove this endpoint
    app.post('/gmail/stop-webhook', async (_req, res) => {
      try {
        console.log('ðŸ›‘ Stopping Gmail webhook...');

        // âš ï¸ SECURITY ISSUE: Using global singleton - only safe for single-user testing
        const result = await gmailService.stopWebhook();
        
        res.json({
          message: 'Gmail webhook stopped successfully',
          result: result
        });

      } catch (error) {
        console.error('âŒ Error stopping webhook:', error);
        res.status(500).json({ error: 'Failed to stop webhook' });
      }
    });


      app.listen(port, () => {
        logger.info(`ðŸŒ Chief AI server running on http://localhost:${port}`, {
          environment: env.NODE_ENV,
          port,
          logLevel: env.LOG_LEVEL
        });
        logger.info('ðŸ”§ Server ready and accepting connections');
        
        if (env.NODE_ENV === 'development') {
          console.log('\nðŸ“‹ Available endpoints:');
          console.log('   GET  /health               - Health check');
          console.log('   GET  /health/ready         - Readiness probe');
          console.log('   GET  /auth                 - Start OAuth flow');
        console.log('   GET  /auth/callback        - OAuth callback');
        console.log('   GET  /emails/fetch         - Fetch emails from Gmail');
        console.log('   GET  /emails               - View stored emails');
        console.log('\nðŸ¤– Phase 2.1 - Real Email Analysis:');
        console.log('   POST /ai/analyze-tone-real - Analyze tone from real sent emails');
        console.log('   POST /ai/analyze-tone      - Analyze tone (mock fallback)');
        console.log('   GET  /tone-profiles        - View tone profile history');
        console.log('   GET  /tone-profiles/:id    - View specific tone profile');
        console.log('   POST /ai/refresh-tone      - Manually refresh tone analysis');
        console.log('   POST /ai/categorize-emails - Categorize emails');
        console.log('   POST /ai/generate-drafts   - Generate AI drafts');
        console.log('   GET  /drafts               - View generated drafts');
        console.log('   GET  /drafts/:id           - View specific draft');
        
        console.log('\nðŸš€ Phase 1 - Real-time Auto-Generated Drafts:');
        console.log('   GET    /auto-drafts         - List auto-generated drafts with pagination');
        console.log('   GET    /auto-drafts/:id     - Get specific auto-generated draft');
        console.log('   PUT    /auto-drafts/:id     - Edit draft content (triggers learning)');
        console.log('   POST   /auto-drafts/:id/send     - Send draft as actual email');
        console.log('   DELETE /auto-drafts/:id     - Delete unwanted draft');
        console.log('   POST   /auto-drafts/:id/approve  - Approve draft without changes');
        
        console.log('\nðŸ”” Webhook Management:');
        console.log('   GET    /webhook-status           - Check webhook status for all users');
        console.log('   POST   /webhook-renewal/manual   - Manually trigger webhook renewal check');
        
        console.log('\nðŸ§ª Webhook Testing:');
        console.log('   POST   /test/webhook-suite       - Run comprehensive webhook test suite');
        console.log('   GET    /test/webhook-health      - Quick webhook health check');
        
        console.log('\nðŸ’¡ Phase 2.1 workflow:');
        console.log('   1. Real tone analysis: POST /ai/analyze-tone-real');
        console.log('   2. View profiles: GET /tone-profiles');
        console.log('   3. Refresh tone: POST /ai/refresh-tone');
        console.log('   4. Categorize: POST /ai/categorize-emails');
        console.log('   5. Generate drafts: POST /ai/generate-drafts');
        console.log('   6. Review: GET /drafts');
        console.log('\nðŸ§  Phase 2.2 - Deep Context Intelligence:');
        console.log('   POST /context/analyze-emails     - Run context analysis on emails');
        console.log('   GET  /context/stats              - Context intelligence statistics');
        console.log('   GET  /context/threads            - Thread analytics');
        console.log('   GET  /context/senders            - Sender relationship insights');
        console.log('   GET  /context/entities           - Entity extraction insights');
        console.log('   GET  /context/thread/:id         - Full thread context');
        console.log('   GET  /context/health             - Context system health');
        console.log('   POST /ai/generate-drafts-with-context - Context-aware draft generation');

        console.log('\nðŸ¤– Phase 2.3 - Smart Response Generation:');
        console.log('   POST /response/generate-smart    - Generate intelligent responses with context');
        console.log('   GET  /response/templates         - Get response templates by context');
        console.log('   GET  /response/stats             - Response generation statistics');
        console.log('   GET  /response/recent            - Recent generated responses');
        console.log('   POST /response/feedback          - Record user feedback on responses');

        console.log('\nðŸŽ“ Phase 2.4 - Learning & Feedback System:');
        console.log('   POST /learning/analyze-edit      - Analyze user edits for learning');
        console.log('   GET  /learning/success-metrics   - Calculate success rates and trends');
        console.log('   GET  /learning/insights          - Generate learning insights from patterns');
        console.log('   GET  /learning/performance-trend - Weekly performance trend analysis');
        console.log('   POST /learning/weekly-analysis   - Comprehensive weekly performance report');

        console.log('\nðŸ“… Phase 3.1 - Calendar Intelligence:');
        console.log('   POST /calendar/set-tokens        - Set OAuth tokens for Calendar API');
        console.log('   GET  /calendar/events            - Get calendar events for date range');  
        console.log('   POST /calendar/check-availability - Just-in-time availability checking');
        console.log('   POST /calendar/suggest-times     - Smart time slot suggestions');
        console.log('   POST /calendar/create-event      - Create calendar events');
        console.log('   GET  /calendar/preferences       - Get user calendar preferences');
        console.log('   POST /calendar/preferences       - Update calendar preferences');
        console.log('   GET  /calendar/stats             - Calendar analytics and statistics');
        console.log('   GET  /calendar/health            - Calendar system health check');

        console.log('\nðŸ¤– Phase 3.2 - Meeting Request Detection:');
        console.log('   POST /meetings/detect            - Detect meeting request in specific email');
        console.log('   POST /meetings/scan-emails       - Scan recent emails for meeting requests');
        console.log('   GET  /meetings/requests          - Get all meeting requests');
        console.log('   PATCH /meetings/requests/:id     - Update meeting request status');
        console.log('   GET  /meetings/health            - Meeting detection system health check');

        console.log('\nðŸ”„ Phase 3.3 - Auto-Scheduling System:');
        console.log('   POST /auto-scheduling/process-meeting  - Process meeting request for auto-scheduling');
        console.log('   POST /auto-scheduling/suggest-times    - Generate time slot suggestions');
        console.log('   POST /auto-scheduling/create-hold      - Create calendar hold for time slot');
        console.log('   POST /auto-scheduling/confirm          - Confirm scheduling and create calendar event');
        console.log('   GET  /auto-scheduling/workflows       - Get scheduling workflows');
        console.log('   GET  /auto-scheduling/holds           - Get calendar holds');
        console.log('   POST /auto-scheduling/cleanup-holds   - Cleanup expired calendar holds');
        console.log('   GET  /auto-scheduling/health          - Auto-scheduling system health check');


    console.log('\nðŸ” System Monitoring:');
        console.log('   GET  /health/email-parsing  - Check parsing health');
        console.log('   POST /health/clear-failures - Clear failure log');
        console.log('   GET  /debug/email/:id       - Inspect specific email');

        console.log('\nðŸ“¡ Gmail Webhooks (Real-time Email):');
        console.log('   POST /webhooks/gmail        - Receive Gmail push notifications');
        console.log('   POST /gmail/setup-webhook   - Set up Gmail push notifications');
        console.log('   GET  /gmail/webhook-status  - Check webhook subscription status');
        console.log('   POST /gmail/stop-webhook    - Stop Gmail push notifications');
        }

      });
    })
    .catch((error) => {
      // Critical startup error - server cannot start
      logger.error('âŒ FATAL: Failed to initialize services', {
        error: error.message,
        stack: error.stack
      });

      console.error('\n========================================');
      console.error('âŒ SERVER STARTUP FAILED');
      console.error('========================================');
      console.error('Error:', error.message);
      console.error('\nPossible causes:');
      console.error('  - Database connection failed (check DATABASE_URL)');
      console.error('  - Required environment variables missing');
      console.error('  - Service initialization error');
      console.error('\nServer will now exit.');
      console.error('========================================\n');

      // Exit with error code so orchestration tools (Docker/Kubernetes) know startup failed
      process.exit(1);
    });
  }
}