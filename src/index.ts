import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';

// Load environment variables FIRST before any other imports that use them
dotenv.config();

// Production imports
import { env, features, initializeEnvironment } from './config/environment';

// Initialize environment configuration after dotenv is loaded
initializeEnvironment();
import { logger } from './utils/logger';
import { monitoring, monitoringMiddleware } from './utils/monitoring';
import { 
  securityHeaders, 
  requestLogging, 
  errorHandler,
  healthCheckBypass,
  authRateLimit,
  apiRateLimit
} from './middleware/security';
import healthRoutes from './routes/health';
import { testConnection, initializeDatabase, pool } from './database/connection';
import { GmailService } from './services/gmail';
import { EmailModel } from './models/Email';
import { AIService } from './services/ai';
import { DraftModel } from './models/Draft';
import { ContextService } from './services/context';
import { ContextModel } from './models/Context';
import { ResponseService } from './services/response';
import { LearningService } from './services/learning';
import { CalendarService } from './services/calendar';
import { CalendarModel } from './models/Calendar';
import { MeetingDetectionService } from './services/meetingDetection';
import { AutoSchedulingService } from './services/autoScheduling';
import { MeetingPipelineService } from './services/meetingPipeline';
import { MeetingConfirmationService } from './services/meetingConfirmation';
import { AutoGeneratedDraftModel } from './models/AutoGeneratedDraft';
import { PromotionalEmailModel } from './models/PromotionalEmail';
import { TokenStorageService } from './services/tokenStorage';
import { UserProfileService } from './services/userProfile';
import { IntelligentEmailRouter } from './services/intelligentEmailRouter';
import { WebhookRenewalService } from './services/webhookRenewal';
import { WebhookTestingSuite } from './services/webhookTesting';
import { google } from 'googleapis';
import { authMiddleware, getUserId } from './middleware/auth';
import authRoutes from './routes/auth';

const app = express();
const port = env.PORT;

// Production middleware - order matters!
app.use(requestLogging);
app.use(healthCheckBypass);
app.use(monitoringMiddleware());
app.use(express.json({ limit: '10mb' }));

// Enable CORS for frontend (conditionally)
if (features.enableCORS) {
  app.use(cors({
    origin: env.NODE_ENV === 'development' 
      ? 'http://localhost:5173'
      : 'https://chief-phi.vercel.app',
    credentials: true
  }));
}

// Global instances
let gmailService: GmailService;
let emailModel: EmailModel;
let aiService: AIService;
let draftModel: DraftModel;
let contextService: ContextService;
let contextModel: ContextModel;
let responseService: ResponseService;
let learningService: LearningService;
let calendarService: CalendarService;
let calendarModel: CalendarModel;
let meetingDetectionService: MeetingDetectionService;
let autoSchedulingService: AutoSchedulingService;
let meetingPipelineService: MeetingPipelineService;
let meetingConfirmationService: MeetingConfirmationService;
let autoGeneratedDraftModel: AutoGeneratedDraftModel;
let promotionalEmailModel: PromotionalEmailModel;
let tokenStorageService: TokenStorageService;
let intelligentEmailRouter: IntelligentEmailRouter;
let webhookRenewalService: WebhookRenewalService;
let webhookTestingSuite: WebhookTestingSuite;

// Initialize services
async function initializeServices() {
  logger.info('üöÄ Initializing Chief AI Email Assistant', {
    environment: env.NODE_ENV,
    port: env.PORT,
    version: '0.1.0'
  });
  
  // Test database connection
  const dbConnected = await testConnection();
  if (!dbConnected) {
    logger.error('‚ùå Cannot connect to database. Please check your DATABASE_URL configuration');
    process.exit(1);
  }

  // Initialize database schema
  await initializeDatabase();

  // Initialize services
  gmailService = new GmailService();
  emailModel = new EmailModel();
  aiService = new AIService();
  draftModel = new DraftModel();
  contextService = new ContextService();
  contextModel = new ContextModel();
  responseService = new ResponseService(aiService, contextService, gmailService);
  learningService = new LearningService(aiService);
  calendarService = new CalendarService();
  calendarModel = new CalendarModel();
  meetingDetectionService = new MeetingDetectionService();
  autoSchedulingService = new AutoSchedulingService();
  meetingPipelineService = new MeetingPipelineService(responseService);
  meetingConfirmationService = new MeetingConfirmationService();
  autoGeneratedDraftModel = new AutoGeneratedDraftModel();
  promotionalEmailModel = new PromotionalEmailModel();
  tokenStorageService = new TokenStorageService();
  intelligentEmailRouter = new IntelligentEmailRouter(responseService);
  webhookRenewalService = new WebhookRenewalService();
  webhookTestingSuite = new WebhookTestingSuite();

  logger.info('‚úÖ All services initialized successfully');
  
  // Start webhook renewal service
  webhookRenewalService.startRenewalService();
}

// Health check routes (no auth required)
app.use('/', healthRoutes);

// Auth routes with rate limiting
app.use('/api/auth', authRateLimit, authRoutes);

// OAuth routes (separate from API auth routes)
app.get('/auth', (req, res) => {
  const authUrl = gmailService.getAuthUrl();
  console.log('üîê Visit this URL to authorize the app:');
  console.log(authUrl);
  res.json({ authUrl });
});

// Intent-based auth endpoints for proper sign up/sign in flow
app.get('/auth/signup', (req, res) => {
  const authUrl = gmailService.getAuthUrl('signup');
  console.log('üÜï Sign up flow initiated');
  res.json({ authUrl, intent: 'signup' });
});

app.get('/auth/signin', (req, res) => {
  const authUrl = gmailService.getAuthUrl('signin');
  console.log('üîê Sign in flow initiated');
  res.json({ authUrl, intent: 'signin' });
});

app.get('/auth/callback', async (req, res) => {
  try {
    const { code, state } = req.query;
    if (!code) {
      // Redirect to frontend with error
      return res.redirect(`http://localhost:5173/auth/callback?error=no_code`);
    }

    // Extract intent from state parameter
    let intent = null;
    if (state) {
      try {
        const stateData = JSON.parse(state as string);
        intent = stateData.intent;
        console.log(`üéØ OAuth callback with intent: ${intent}`);
      } catch (error) {
        console.log('‚ö†Ô∏è Could not parse state parameter, continuing without intent');
      }
    }

    const tokens = await gmailService.setTokens(code as string);
    console.log('‚úÖ Authorization successful!');
    
    // Get user Gmail address and validate intent
    try {
      const gmail = google.gmail({ version: 'v1', auth: gmailService.oauth2Client });
      const userProfile = await gmail.users.getProfile({ userId: 'me' });
      const gmailAddress = userProfile.data.emailAddress;
      
      if (gmailAddress && tokens.refresh_token) {
        // üîç INTENT VALIDATION - Check user existence vs intent
        const existingUser = await tokenStorageService.getUserByEmail(gmailAddress);
        
        if (intent === 'signin' && !existingUser) {
          console.log(`‚ùå Sign in failed: User ${gmailAddress} does not exist`);
          return res.redirect(`http://localhost:5173/auth/callback?error=user_not_found&email=${encodeURIComponent(gmailAddress)}`);
        }
        
        if (intent === 'signup' && existingUser) {
          console.log(`‚ùå Sign up failed: User ${gmailAddress} already exists`);
          return res.redirect(`http://localhost:5173/auth/callback?error=user_exists&email=${encodeURIComponent(gmailAddress)}`);
        }
        
        console.log(`‚úÖ Intent validation passed for ${intent || 'no-intent'}: ${gmailAddress}`);
        
        // Determine if this is a new user (for onboarding flow)
        const isNewUser = !existingUser;
        // Save tokens to database for persistent 24/7 access
        const userId = await tokenStorageService.saveUserTokens(gmailAddress, {
          accessToken: tokens.access_token || '',
          refreshToken: tokens.refresh_token,
          expiresAt: new Date(Date.now() + 3600 * 1000) // 1 hour
        });
        
        console.log(`üíæ Tokens saved to database for 24/7 operation. User ID: ${userId}`);
        console.log(`üìß Gmail address: ${gmailAddress}`);
        
        // üöÄ AUTOMATIC WEBHOOK SETUP - Set up Gmail webhook for real-time processing
        try {
          console.log(`üîî Setting up automatic webhook subscription for ${gmailAddress}...`);
          
          // Initialize Gmail service for the new user
          await gmailService.initializeForUser(userId);
          
          // Set up webhook subscription
          const watchResponse = await gmailService.setupWebhook();
          
          console.log(`‚úÖ Automatic webhook setup successful for ${gmailAddress}`);
          console.log(`üìä Webhook expires: ${new Date(parseInt(watchResponse.expiration)).toISOString()}`);
        } catch (webhookError) {
          console.error(`‚ö†Ô∏è Failed to set up automatic webhook for ${gmailAddress}:`, webhookError);
          // Don't fail the entire OAuth process if webhook setup fails
          // User can still use the system, just without real-time processing
        }
        
        // Generate JWT token for frontend authentication
        const jwtToken = authMiddleware.generateToken(userId, gmailAddress);
        
        // Return JWT token with onboarding status
        const authData = Buffer.from(JSON.stringify({
          jwt_token: jwtToken,
          user_id: userId,
          email: gmailAddress,
          is_new_user: isNewUser,
          needs_onboarding: isNewUser || !existingUser?.onboardingCompleted
        })).toString('base64');
        
        // Redirect to frontend with JWT token and onboarding info
        res.redirect(`http://localhost:5173/auth/callback?success=true&tokens=${encodeURIComponent(authData)}`);
      } else {
        throw new Error('Missing Gmail address or refresh token');
      }
    } catch (error) {
      console.error('‚ö†Ô∏è Failed to complete user setup:', error);
      res.redirect(`http://localhost:5173/auth/callback?error=auth_failed`);
    }
  } catch (error) {
    console.error('‚ùå Authorization failed:', error);
    // Redirect to frontend with error
    res.redirect(`http://localhost:5173/auth/callback?error=auth_failed`);
  }
});

// Testing endpoint to set tokens directly
app.post('/auth/set-tokens', async (req, res) => {
  try {
    const { accessToken, refreshToken } = req.body;
    if (!accessToken || !refreshToken) {
      return res.status(400).json({ error: 'Both accessToken and refreshToken are required' });
    }
    
    await gmailService.setStoredTokens(accessToken, refreshToken);
    console.log('‚úÖ OAuth tokens set successfully');
    res.json({ message: 'Tokens set successfully for testing' });
  } catch (error) {
    console.error('‚ùå Error setting tokens:', error);
    res.status(500).json({ error: 'Failed to set tokens' });
  }
});

// Add authentication middleware to all protected routes
// User Profile endpoints
app.get('/api/user/scheduling-link', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const userProfileService = new UserProfileService(pool);

    const schedulingLink = await userProfileService.getSchedulingLink(userId);

    res.json({ schedulingLink });
  } catch (error) {
    console.error('‚ùå Error getting scheduling link:', error);
    res.status(500).json({ error: 'Failed to get scheduling link' });
  }
});

app.put('/api/user/scheduling-link', authMiddleware.authenticate, async (req, res) => {
  try {
    console.log('üîó PUT /api/user/scheduling-link called');
    const userId = getUserId(req);
    const { schedulingLink } = req.body;
    console.log(`üîó User ${userId.substring(0, 8)}: Updating scheduling link to: ${schedulingLink}`);

    if (!schedulingLink || typeof schedulingLink !== 'string') {
      console.log('üîó ‚ùå Invalid scheduling link provided');
      return res.status(400).json({ error: 'Valid scheduling link is required' });
    }

    // Validate the scheduling link
    const { SchedulingLinkValidator } = await import('./utils/schedulingLinkValidator');
    const validationResult = SchedulingLinkValidator.validateSchedulingLinkQuick(schedulingLink);
    console.log(`üîó Validation result:`, validationResult);

    if (!validationResult.isValid) {
      console.log(`üîó ‚ùå Validation failed: ${validationResult.error}`);
      return res.status(400).json({ error: validationResult.error });
    }

    const userProfileService = new UserProfileService(pool);
    const success = await userProfileService.updateSchedulingLink(userId, schedulingLink, true);

    if (success) {
      console.log(`‚úÖ Updated scheduling link for user ${userId.substring(0, 8)}: ${validationResult.platform}`);
      res.json({
        success: true,
        platform: validationResult.platform,
        message: 'Scheduling link updated successfully'
      });
    } else {
      res.status(500).json({ error: 'Failed to update scheduling link' });
    }
  } catch (error) {
    console.error('‚ùå Error updating scheduling link:', error);
    res.status(500).json({ error: 'Failed to update scheduling link' });
  }
});

app.delete('/api/user/scheduling-link', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const userProfileService = new UserProfileService(pool);

    const success = await userProfileService.updateSchedulingLink(userId, '', false);

    if (success) {
      console.log(`‚úÖ Removed scheduling link for user ${userId.substring(0, 8)}`);
      res.json({
        success: true,
        message: 'Scheduling link removed successfully'
      });
    } else {
      res.status(500).json({ error: 'Failed to remove scheduling link' });
    }
  } catch (error) {
    console.error('‚ùå Error removing scheduling link:', error);
    res.status(500).json({ error: 'Failed to remove scheduling link' });
  }
});

// Email routes - require authentication
app.get('/emails/fetch', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    console.log(`üìß Fetching emails for user: ${userId.substring(0, 8)}...`);
    
    // Initialize Gmail service for this user
    await gmailService.initializeForUser(userId);
    
    const emails = await gmailService.getRecentEmails(20);
    console.log(`‚úÖ Retrieved ${emails.length} emails from Gmail`);

    // Parse and save emails with user context, then process for meetings
    let savedCount = 0;
    let meetingProcessingResults: any[] = [];
    
    for (const email of emails) {
      try {
        const parsedEmail = gmailService.parseEmail(email);
        
        // Check if email already exists for this user
        const exists = await emailModel.emailExists(parsedEmail.id, userId);
        let emailDbId: number | undefined;
        
        if (!exists) {
          const savedEmail = await emailModel.saveEmail(parsedEmail, userId);
          emailDbId = savedEmail;
          savedCount++;
          
          // üöÄ PHASE 3: Process new emails through intelligent router
          if (emailDbId) {
            try {
              console.log(`üß† [MANUAL FETCH] Routing email ${parsedEmail.id} through intelligent router...`);
              const routingResult = await intelligentEmailRouter.routeEmail(
                parsedEmail, 
                userId, 
                emailDbId
              );
              
              // Convert routing result to meeting pipeline format for backward compatibility
              if (routingResult.meetingResult) {
                meetingProcessingResults.push(routingResult.meetingResult);
              } else {
                // Create a compatible result for non-meeting emails
                meetingProcessingResults.push({
                  emailId: parsedEmail.id,
                  userId,
                  isMeetingRequest: false,
                  confidence: routingResult.routingDecision.confidence,
                  processingTime: routingResult.totalProcessingTime,
                  status: routingResult.status === 'success' ? 'processed' : 'error',
                  reason: `Intelligent router: ${routingResult.routingDecision.reasoning}`
                });
              }
              
              console.log(`‚úÖ [MANUAL FETCH] Email routed to ${routingResult.routingDecision.route.toUpperCase()} pipeline`);
              
            } catch (routingError) {
              console.error(`‚ùå [INTELLIGENT ROUTER] Error processing email ${parsedEmail.id}:`, routingError);
            }
          }
        }
      } catch (error) {
        console.error(`Error processing email ${email.id}:`, error);
      }
    }

    console.log(`‚úÖ Saved ${savedCount} new emails to database for user ${userId.substring(0, 8)}...`);
    
    // Log meeting detection results
    const meetingsDetected = meetingProcessingResults.filter(r => r.isMeetingRequest).length;
    if (meetingProcessingResults.length > 0) {
      console.log(`üîç [MEETING PIPELINE] Processed ${meetingProcessingResults.length} emails, found ${meetingsDetected} meeting requests`);
    }
    
    const stats = await emailModel.getEmailStats(userId);
    
    res.json({
      message: 'Emails fetched successfully',
      retrieved: emails.length,
      saved: savedCount,
      meetingDetection: {
        processed: meetingProcessingResults.length,
        meetingsFound: meetingsDetected,
        successRate: meetingProcessingResults.length > 0 
          ? Math.round((meetingsDetected / meetingProcessingResults.length) * 100) 
          : 0
      },
      stats,
      userId: userId.substring(0, 8) + '...'
    });
  } catch (error) {
    console.error('‚ùå Error fetching emails:', error);
    res.status(500).json({ error: 'Failed to fetch emails' });
  }
});

app.get('/emails', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const emails = await emailModel.getRecentEmails(20, userId);
    const stats = await emailModel.getEmailStats(userId);

    res.json({
      emails: emails.map(email => ({
        id: email.id,
        subject: email.subject,
        from: email.from_email,
        date: email.received_at,
        isRead: email.is_read,
        preview: email.body?.substring(0, 150) + '...',
      })),
      stats
    });
  } catch (error) {
    console.error('‚ùå Error retrieving emails:', error);
    res.status(500).json({ error: 'Failed to retrieve emails' });
  }
});

// Promotional Emails API endpoints

// Meeting Pipeline API Endpoints
app.get('/meetings', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const { status, urgency, meetingType, limit = 20, offset = 0 } = req.query;
    const statusFilter = status as "pending" | "scheduled" | "declined" | "cancelled" | undefined;
    const urgencyFilter = urgency as "high" | "medium" | "low" | undefined;
    const meetingTypeFilter = meetingType as "urgent" | "regular" | "flexible" | "recurring" | undefined;
    const limitNum = parseInt(typeof limit === "string" ? limit : "20");
    const offsetNum = parseInt(typeof offset === "string" ? offset : "0");
    
    console.log(`üìã Fetching meeting requests for user: ${userId.substring(0, 8)}...`);
    
    const meetings = await meetingPipelineService.getMeetingRequests(userId, {
      status: statusFilter,
      urgency: urgencyFilter,
      meetingType: meetingTypeFilter,
      limit: limitNum,
      offset: offsetNum
    });
    
    const stats = await meetingPipelineService.getMeetingStats(userId);
    
    console.log(`‚úÖ Retrieved ${meetings.length} meeting requests`);
    
    res.json({
      message: 'Meeting requests fetched successfully',
      meetings,
      stats,
      pagination: {
        limit: limitNum,
        offset: offsetNum,
        total: stats.total
      }
    });
  } catch (error) {
    console.error('‚ùå Error fetching meeting requests:', error);
    res.status(500).json({ error: 'Failed to fetch meeting requests' });
  }
});

app.get('/meetings/stats', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    
    const stats = await meetingPipelineService.getMeetingStats(userId);
    
    res.json({
      message: 'Meeting statistics fetched successfully',
      stats
    });
  } catch (error) {
    console.error('‚ùå Error fetching meeting stats:', error);
    res.status(500).json({ error: 'Failed to fetch meeting statistics' });
  }
});

app.get('/meetings/pipeline/health', authMiddleware.authenticate, async (req, res) => {
  try {
    const health = await meetingPipelineService.healthCheck();
    
    res.json({
      message: 'Meeting pipeline health check',
      health,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('‚ùå Error checking meeting pipeline health:', error);
    res.status(500).json({ error: 'Meeting pipeline health check failed' });
  }
});

app.post('/meetings/:id/status', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const meetingId = parseInt(req.params.id);
    const { status } = req.body;
    
    if (!['pending', 'scheduled', 'declined', 'cancelled'].includes(status)) {
      return res.status(400).json({ error: 'Invalid status. Must be: pending, scheduled, declined, or cancelled' });
    }
    
    console.log(`üìù Updating meeting ${meetingId} status to: ${status}`);
    
    // Update meeting status in database
    const result = await pool.query(
      'UPDATE meeting_requests SET status = $1, updated_at = NOW() WHERE id = $2 AND user_id = $3 RETURNING *',
      [status, meetingId, userId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Meeting request not found' });
    }
    
    console.log(`‚úÖ Meeting status updated successfully`);
    
    res.json({
      message: 'Meeting status updated successfully',
      meeting: result.rows[0]
    });
  } catch (error) {
    console.error('‚ùå Error updating meeting status:', error);
    res.status(500).json({ error: 'Failed to update meeting status' });
  }
});


app.get('/promotional-emails', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const { is_read, classification_reason, from_email, limit = 50, offset = 0 } = req.query;

    const filters = {
      is_read: is_read ? is_read === 'true' : undefined,
      classification_reason: classification_reason as string,
      from_email: from_email as string,
      limit: parseInt(limit as string),
      offset: parseInt(offset as string)
    };

    const emails = await promotionalEmailModel.getPromotionalEmailsForUser(userId, filters);
    const stats = await promotionalEmailModel.getPromotionalEmailStats(userId);

    res.json({
      emails: emails.map(email => ({
        id: email.id,
        subject: email.subject,
        from_email: email.from_email,
        date: email.received_at,
        is_read: email.is_read,
        classification_reason: email.classification_reason,
        preview: email.body?.substring(0, 150) + '...',
      })),
      stats,
      filters
    });
  } catch (error) {
    console.error('‚ùå Error retrieving promotional emails:', error);
    res.status(500).json({ error: 'Failed to retrieve promotional emails' });
  }
});

app.post('/promotional-emails/:id/mark-read', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const { id } = req.params;
    const emailId = parseInt(id);

    if (isNaN(emailId)) {
      return res.status(400).json({ error: 'Invalid email ID' });
    }

    const success = await promotionalEmailModel.markAsRead(emailId, userId);
    
    if (success) {
      res.json({ success: true, message: 'Email marked as read' });
    } else {
      res.status(404).json({ error: 'Email not found or already processed' });
    }
  } catch (error) {
    console.error('‚ùå Error marking promotional email as read:', error);
    res.status(500).json({ error: 'Failed to mark email as read' });
  }
});

app.delete('/promotional-emails/:id', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const { id } = req.params;
    const emailId = parseInt(id);

    if (isNaN(emailId)) {
      return res.status(400).json({ error: 'Invalid email ID' });
    }

    const success = await promotionalEmailModel.deletePromotionalEmail(emailId, userId);
    
    if (success) {
      res.json({ success: true, message: 'Email deleted successfully' });
    } else {
      res.status(404).json({ error: 'Email not found or already deleted' });
    }
  } catch (error) {
    console.error('‚ùå Error deleting promotional email:', error);
    res.status(500).json({ error: 'Failed to delete email' });
  }
});

app.get('/promotional-emails/stats', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    const stats = await promotionalEmailModel.getPromotionalEmailStats(userId);
    
    res.json({ stats });
  } catch (error) {
    console.error('‚ùå Error retrieving promotional email stats:', error);
    res.status(500).json({ error: 'Failed to retrieve promotional email statistics' });
  }
});

// Phase 2.1: Real Email Analysis endpoints
app.post('/ai/analyze-tone-real', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    console.log(`üß† Analyzing tone from real sent emails for user: ${userId.substring(0, 8)}...`);
    
    // Initialize Gmail service for this user
    await gmailService.initializeForUser(userId);
    
    // Fetch real sent emails from Gmail with user context validation
    const sentEmails = await gmailService.getSentEmailsForUser(userId, 50);
    console.log(`üì§ Retrieved ${sentEmails.length} sent emails from Gmail`);
    
    // Filter emails for tone analysis
    const filteredEmails = gmailService.filterSentEmailsForToneAnalysis(sentEmails);
    
    if (filteredEmails.length === 0) {
      return res.status(400).json({ 
        error: 'No suitable emails found for tone analysis',
        suggestion: 'Try sending more emails or check if your sent folder has content'
      });
    }
    
    // Convert to format expected by AI service
    const emailsForAnalysis = filteredEmails.map(email => {
      const parsed = gmailService.parseEmail(email);
      return {
        subject: parsed.subject,
        body: parsed.body
      };
    });
    
    // Perform real tone analysis
    const toneAnalysis = await aiService.analyzeToneFromRealEmails(emailsForAnalysis);
    
    // Save to database with real data flag
    const savedProfileId = await draftModel.saveToneProfile({
      profile_text: toneAnalysis.profile,
      confidence_score: toneAnalysis.confidence,
      email_samples_analyzed: emailsForAnalysis.length,
      insights: toneAnalysis.insights,
      is_real_data: true
    });
    
    res.json({
      message: 'Real tone analysis completed successfully',
      profileId: savedProfileId,
      samplesAnalyzed: emailsForAnalysis.length,
      totalSentEmails: sentEmails.length,
      filteredEmails: filteredEmails.length,
      confidence: toneAnalysis.confidence,
      toneProfilePreview: toneAnalysis.profile.substring(0, 300) + '...',
      insights: toneAnalysis.insights.substring(0, 200) + '...'
    });
  } catch (error) {
    console.error('‚ùå Error analyzing real tone:', error);
    res.status(500).json({ error: 'Failed to analyze tone from real emails' });
  }
});

// Keep the old mock version for fallback
app.post('/ai/analyze-tone', authMiddleware.authenticate, async (req, res) => {
  try {
    const userId = getUserId(req);
    console.log(`üß† Analyzing tone from mock emails (fallback) for user: ${userId.substring(0, 8)}...`);
    
    const mockSentEmails = [
      { subject: 'Re: Meeting tomorrow', body: 'Hi John, That works perfectly for me. I\'ll see you at 3pm in the conference room. Thanks!' },
      { subject: 'Thank you', body: 'Hi Sarah, Thank you so much for your help with the project. I really appreciate your time and expertise.' },
      { subject: 'Quick question', body: 'Hey team, Just wanted to check if we\'re still on track for the deadline. Let me know if you need any help!' }
    ];
    
    const toneProfile = await aiService.analyzeToneFromEmails(mockSentEmails);
    
    const savedProfileId = await draftModel.saveToneProfile({
      profile_text: toneProfile,
      confidence_score: 70, // Lower confidence for mock data
      email_samples_analyzed: mockSentEmails.length,
      insights: 'Based on mock email samples - use real analysis for better results',
      is_real_data: false
    });
    
    res.json({
      message: 'Tone analysis completed (using mock data)',
      profileId: savedProfileId,
      samplesAnalyzed: mockSentEmails.length,
      confidence: 70,
      toneProfile: toneProfile.substring(0, 200) + '...',
      warning: 'This used mock data. Use /ai/analyze-tone-real for authentic results'
    });
  } catch (error) {
    console.error('‚ùå Error analyzing tone:', error);
    res.status(500).json({ error: 'Failed to analyze tone' });
  }
});

// Tone profile management endpoints
app.get('/tone-profiles', authMiddleware.authenticate, async (req, res) => {
  try {
    const profiles = await draftModel.getToneProfileHistory(5);
    
    res.json({
      profiles: profiles.map(profile => ({
        id: profile.id,
        isRealData: profile.is_real_data,
        confidence: profile.confidence_score,
        emailSamples: profile.email_samples_analyzed,
        createdAt: profile.created_at,
        profilePreview: profile.profile_text.substring(0, 200) + '...',
        insightsPreview: profile.insights?.substring(0, 100) + '...' || 'No insights available'
      })),
      total: profiles.length,
      latestReal: profiles.find(p => p.is_real_data) || null
    });
  } catch (error) {
    console.error('‚ùå Error fetching tone profiles:', error);
    res.status(500).json({ error: 'Failed to fetch tone profiles' });
  }
});

app.get('/tone-profiles/:id', async (req, res) => {
  try {
    const profileId = parseInt(req.params.id);
    const profiles = await draftModel.getToneProfileHistory(20);
    const profile = profiles.find(p => p.id === profileId);
    
    if (!profile) {
      return res.status(404).json({ error: 'Tone profile not found' });
    }
    
    res.json(profile);
  } catch (error) {
    console.error('‚ùå Error fetching tone profile:', error);
    res.status(500).json({ error: 'Failed to fetch tone profile' });
  }
});

app.post('/ai/refresh-tone', authMiddleware.authenticate, async (req, res) => {
  try {
    const { forceRefresh } = req.body;
    const userId = getUserId(req);
    
    // Check if we have a recent real tone profile (within last 7 days)
    const existingProfile = await draftModel.getLatestRealToneProfile();
    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    
    if (!forceRefresh && existingProfile && existingProfile.created_at > sevenDaysAgo) {
      return res.json({
        message: 'Recent tone profile already exists',
        profileId: existingProfile.id,
        createdAt: existingProfile.created_at,
        confidence: existingProfile.confidence_score,
        samplesAnalyzed: existingProfile.email_samples_analyzed,
        suggestion: 'Use forceRefresh: true to create a new profile anyway'
      });
    }
    
    console.log('üîÑ Refreshing tone analysis with latest sent emails...');
    
    // Initialize Gmail service for this user
    await gmailService.initializeForUser(userId);
    
    // Fetch and analyze fresh sent emails with user context validation
    const sentEmails = await gmailService.getSentEmailsForUser(userId, 50);
    const filteredEmails = gmailService.filterSentEmailsForToneAnalysis(sentEmails);
    
    if (filteredEmails.length < 5) {
      return res.status(400).json({
        error: 'Insufficient emails for tone analysis',
        found: filteredEmails.length,
        minimum: 5,
        suggestion: 'Send more emails and try again later'
      });
    }
    
    const emailsForAnalysis = filteredEmails.map(email => {
      const parsed = gmailService.parseEmail(email);
      return {
        subject: parsed.subject,
        body: parsed.body
      };
    });
    
    const toneAnalysis = await aiService.analyzeToneFromRealEmails(emailsForAnalysis);
    
    const savedProfileId = await draftModel.saveToneProfile({
      profile_text: toneAnalysis.profile,
      confidence_score: toneAnalysis.confidence,
      email_samples_analyzed: emailsForAnalysis.length,
      insights: toneAnalysis.insights,
      is_real_data: true
    });
    
    res.json({
      message: 'Tone profile refreshed successfully',
      profileId: savedProfileId,
      previousProfile: existingProfile?.id || null,
      samplesAnalyzed: emailsForAnalysis.length,
      confidence: toneAnalysis.confidence,
      improvementNotes: existingProfile ? 
        `Updated from ${existingProfile.email_samples_analyzed} to ${emailsForAnalysis.length} email samples` :
        'First real tone profile created'
    });
  } catch (error) {
    console.error('‚ùå Error refreshing tone:', error);
    res.status(500).json({ error: 'Failed to refresh tone profile' });
  }
});

app.post('/ai/categorize-emails', authMiddleware.authenticate, async (req, res) => {
  try {
    console.log('üè∑Ô∏è Categorizing recent emails...');
    
    const emails = await emailModel.getRecentEmails(10);
    let categorizedCount = 0;
    
    for (const email of emails) {
      if (!email.category) {
        const category = await aiService.categorizeEmail(
          email.subject || '',
          email.body || '',
          email.from_email
        );
        
        // Update email with category
        await emailModel.updateEmail(email.id, { category });
        categorizedCount++;
      }
    }
    
    res.json({
      message: 'Email categorization completed',
      categorized: categorizedCount,
      total: emails.length
    });
  } catch (error) {
    console.error('‚ùå Error categorizing emails:', error);
    res.status(500).json({ error: 'Failed to categorize emails' });
  }
});

app.post('/ai/generate-drafts', authMiddleware.authenticate, async (req, res) => {
  try {
    console.log('‚ú® Generating drafts for recent emails...');
    
    // Get recent unread emails without drafts
    const emails = await emailModel.getRecentEmails(5);
    const unprocessedEmails = emails.filter(email => !email.has_draft && !email.is_read);
    
    if (unprocessedEmails.length === 0) {
      return res.json({
        message: 'No unprocessed emails found',
        generated: 0
      });
    }
    
    // Get the latest tone profile
    const toneProfile = await draftModel.getLatestToneProfile();
    if (!toneProfile) {
      return res.status(400).json({ 
        error: 'No tone profile found. Please run tone analysis first.' 
      });
    }
    
    let generatedCount = 0;
    const drafts = [];
    
    for (const email of unprocessedEmails.slice(0, 3)) { // Limit to 3 for testing
      try {
        // Categorize email if not already categorized
        const category = email.category || await aiService.categorizeEmail(
          email.subject || '',
          email.body || '',
          email.from_email
        );
        
        // Generate draft
        const draft = await aiService.generateDraft(
          {
            subject: email.subject || '',
            body: email.body || '',
            from: email.from_email
          },
          category,
          toneProfile.profile_text
        );
        
        // Score the draft
        const qualityScore = await aiService.scoreDraft(
          draft.body,
          email.body || '',
          category
        );
        
        // Save draft to database
        const draftId = await draftModel.saveDraft({
          email_id: email.id,
          subject: draft.subject,
          body: draft.body,
          category,
          confidence_score: draft.confidence,
          quality_score: qualityScore
        });
        
        drafts.push({
          id: draftId,
          emailSubject: email.subject,
          category,
          confidence: draft.confidence,
          qualityScore
        });
        
        generatedCount++;
      } catch (error) {
        console.error(`Error processing email ${email.id}:`, error);
      }
    }
    
    res.json({
      message: 'Draft generation completed',
      generated: generatedCount,
      drafts
    });
  } catch (error) {
    console.error('‚ùå Error generating drafts:', error);
    res.status(500).json({ error: 'Failed to generate drafts' });
  }
});

app.get('/drafts', async (req, res) => {
  try {
    const drafts = await draftModel.getPendingDrafts(20);
    
    res.json({
      drafts: drafts.map(draft => ({
        id: draft.id,
        originalSubject: draft.original_subject,
        draftSubject: draft.subject,
        from: draft.from_email,
        category: draft.category,
        confidence: draft.confidence_score,
        qualityScore: draft.quality_score,
        status: draft.status,
        createdAt: draft.created_at,
        preview: draft.body.substring(0, 150) + '...'
      })),
      total: drafts.length
    });
  } catch (error) {
    console.error('‚ùå Error fetching drafts:', error);
    res.status(500).json({ error: 'Failed to fetch drafts' });
  }
});

app.get('/drafts/:id', async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    
    // Get draft by ID directly from database
    const query = 'SELECT * FROM drafts WHERE id = $1';
    const result = await pool.query(query, [draftId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Draft not found' });
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('‚ùå Error fetching draft:', error);
    res.status(500).json({ error: 'Failed to fetch draft' });
  }
});

// üöÄ Phase 1: Auto-Generated Draft Management API Endpoints

// GET /auto-drafts - List all auto-generated drafts with pagination (USER-FILTERED)
app.get('/auto-drafts', authMiddleware.authenticate, async (req, res) => {
  try {
    console.log('üîÑ Fetching auto-drafts with email data...');
    const limit = parseInt(req.query.limit as string) || 20;
    const status = req.query.status as string;
    const userId = req.userId; // Get user ID from auth middleware

    if (!userId) {
      return res.status(401).json({ error: 'User authentication required' });
    }

    let drafts;
    if (status === 'pending') {
      drafts = await autoGeneratedDraftModel.getPendingDraftsWithEmails(limit, userId);
    } else {
      // For now, just get pending drafts with email data for the specific user
      drafts = await autoGeneratedDraftModel.getPendingDraftsWithEmails(limit, userId);
    }

    res.json({
      message: 'Auto-generated drafts retrieved successfully',
      drafts: drafts.map(draft => ({
        id: draft.id,
        draftId: draft.draft_id,
        originalEmailId: draft.original_email_id,
        subject: draft.subject,
        body: draft.body,
        tone: draft.tone,
        urgencyLevel: draft.urgency_level,
        contextUsed: draft.context_used,
        relationshipType: draft.relationship_type,
        status: draft.status,
        createdAt: draft.created_at,
        processingTime: draft.processing_time_ms ? `${draft.processing_time_ms}ms` : null,
        // Include original email data
        originalEmail: {
          subject: draft.original_subject,
          from: draft.original_from,
          date: draft.original_date,
          isRead: draft.original_is_read,
          preview: draft.original_preview,
          gmailId: draft.original_gmail_id,
          body: draft.original_preview // Use the full preview as body for frontend
        }
      })),
      total: drafts.length,
      userId: userId.substring(0, 8) + '...' // For debugging
    });
  } catch (error) {
    console.error('‚ùå Error fetching auto-generated drafts:', error);
    res.status(500).json({ error: 'Failed to fetch auto-generated drafts' });
  }
});

// GET /auto-drafts/:id - Get specific auto-generated draft with metadata (USER-FILTERED)
app.get('/auto-drafts/:id', authMiddleware.authenticate, async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    const userId = req.userId;
    
    if (!userId) {
      return res.status(401).json({ error: 'User authentication required' });
    }
    
    const draft = await autoGeneratedDraftModel.getDraftById(draftId);
    
    if (!draft) {
      return res.status(404).json({ error: 'Auto-generated draft not found' });
    }
    
    // CRITICAL: Verify the draft belongs to the authenticated user
    if (draft.user_id !== userId) {
      return res.status(403).json({ error: 'Access denied: Draft belongs to another user' });
    }

    res.json({
      message: 'Auto-generated draft retrieved successfully',
      draft: {
        id: draft.id,
        draftId: draft.draft_id,
        originalEmailId: draft.original_email_id,
        subject: draft.subject,
        body: draft.body,
        tone: draft.tone,
        urgencyLevel: draft.urgency_level,
        contextUsed: draft.context_used,
        relationshipType: draft.relationship_type,
        status: draft.status,
        createdAt: draft.created_at,
        reviewedAt: draft.reviewed_at,
        sentAt: draft.sent_at,
        userEdited: draft.user_edited,
        editCount: draft.edit_count,
        processingTime: draft.processing_time_ms
      }
    });
  } catch (error) {
    console.error('‚ùå Error fetching auto-generated draft:', error);
    res.status(500).json({ error: 'Failed to fetch auto-generated draft' });
  }
});

// PUT /auto-drafts/:id - Edit draft content (triggers learning system)
app.put('/auto-drafts/:id', authMiddleware.authenticate, async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    const { subject, body, status } = req.body;
    const userId = req.userId;
    
    if (!userId) {
      return res.status(401).json({ error: 'User authentication required' });
    }
    
    const existingDraft = await autoGeneratedDraftModel.getDraftById(draftId);
    if (!existingDraft) {
      return res.status(404).json({ error: 'Auto-generated draft not found' });
    }
    
    // CRITICAL: Verify the draft belongs to the authenticated user
    if (existingDraft.user_id !== userId) {
      return res.status(403).json({ error: 'Access denied: Draft belongs to another user' });
    }

    // Store original content for learning analysis
    const originalSubject = existingDraft.subject || '';
    const originalBody = existingDraft.body || '';
    const newSubject = subject || existingDraft.subject;
    const newBody = body || existingDraft.body;
    
    // Check if content actually changed
    const subjectChanged = subject && subject !== existingDraft.subject;
    const bodyChanged = body && body !== existingDraft.body;
    const contentChanged = subjectChanged || bodyChanged;

    // Update the draft content in the database
    const updateQuery = `
      UPDATE auto_generated_drafts 
      SET subject = $1, body = $2, user_edited = true, edit_count = edit_count + 1
      WHERE id = $3
    `;
    await pool.query(updateQuery, [newSubject, newBody, draftId]);

    // Update status if provided
    if (status && status !== existingDraft.status) {
      await autoGeneratedDraftModel.updateDraftStatus(draftId, status);
    }

    // üß† NEW: Trigger Learning Analysis (NON-BLOCKING)
    if (contentChanged) {
      // Run learning analysis asynchronously to not block the response
      setImmediate(async () => {
        try {
          console.log(`üß† Triggering learning analysis for draft ${draftId}...`);
          
          const originalContent = `Subject: ${originalSubject}\n\nBody: ${originalBody}`;
          const editedContent = `Subject: ${newSubject}\n\nBody: ${newBody}`;
          
          console.log(`üìù Original content length: ${originalContent.length} chars`);
          console.log(`‚úèÔ∏è  Edited content length: ${editedContent.length} chars`);
          
          // Call the learning service to analyze the edit
          const analysisResult = await learningService.analyzeEdit(
            draftId.toString(), 
            originalContent, 
            editedContent,
            req.userId
          );
          
          console.log(`‚úÖ Learning analysis completed for draft ${draftId}:`);
          console.log(`   - Edit Type: ${analysisResult.editType}`);
          console.log(`   - Edit Percentage: ${analysisResult.editPercentage}%`);
          console.log(`   - Success Score: ${analysisResult.successScore}`);
          console.log(`   - Learning Insight: ${analysisResult.learningInsight}`);
          
        } catch (learningError) {
          // Learning failure should NOT affect the edit operation
          console.error('‚ö†Ô∏è Learning analysis failed (edit still succeeded):', learningError);
          console.error('   This is non-critical - user edit was saved successfully');
        }
      });
    } else {
      console.log(`‚ÑπÔ∏è No content changes detected for draft ${draftId} - skipping learning analysis`);
    }

    // Return success response immediately (don't wait for learning)
    res.json({
      message: 'Auto-generated draft updated successfully',
      draftId: draftId,
      changes: {
        subjectChanged,
        bodyChanged,
        statusChanged: status && status !== existingDraft.status
      },
      learningTriggered: contentChanged // Let frontend know if learning was triggered
    });
  } catch (error) {
    console.error('‚ùå Error updating auto-generated draft:', error);
    res.status(500).json({ error: 'Failed to update auto-generated draft' });
  }
});

// POST /auto-drafts/:id/send - Send draft as actual email
app.post('/auto-drafts/:id/send', authMiddleware.authenticate, async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    const userId = getUserId(req);
    
    // Get draft with original email data to determine recipient
    const draftWithEmail = await autoGeneratedDraftModel.getDraftByIdWithEmail(draftId);
    
    if (!draftWithEmail) {
      return res.status(404).json({ error: 'Auto-generated draft not found' });
    }

    if (draftWithEmail.status === 'sent') {
      return res.status(400).json({ error: 'Draft has already been sent' });
    }

    console.log(`üì§ Sending draft ${draftId} via Gmail API...`);
    console.log(`üìß To: ${draftWithEmail.original_from}`);
    console.log(`üìù Subject: ${draftWithEmail.subject}`);

    // Initialize Gmail service for this user
    await gmailService.initializeForUser(userId);

    // Send email via Gmail API with user context validation
    console.log(`üßµ [THREADING DEBUG] About to send email with threadId: ${draftWithEmail.original_thread_id ? draftWithEmail.original_thread_id : 'NULL/UNDEFINED'}`);
    const sendResult = await gmailService.sendEmailForUser(
      userId,
      draftWithEmail.original_from, // Send to the original sender (reply)
      draftWithEmail.subject,
      draftWithEmail.body,
      draftWithEmail.original_thread_id // Include thread ID for proper threading
    );

    // Update draft status to sent
    await autoGeneratedDraftModel.updateDraftStatus(draftId, 'sent');

    // Check if this is a meeting response draft and handle calendar booking
    let calendarEventId = null;
    let calendarBooked = false;

    // NEW: Check for new draft-first meeting system
    if (draftWithEmail.relationship_type === 'meeting_response' && draftWithEmail.context_used) {
      try {
        const context = draftWithEmail.context_used;
        const actionTaken = context.actionTaken;

        console.log(`üìÖ Processing meeting response (${actionTaken}) for draft ${draftId}...`);

        // Only create calendar event for accepted meetings
        if (actionTaken === 'accepted' && context.meetingRequest?.preferredDates?.[0]) {
          const proposedTime = context.meetingRequest.preferredDates[0];
          const meetingTitle = context.originalEmail?.subject || 'Meeting';
          const senderEmail = context.originalEmail?.from;

          console.log(`üìÖ Creating calendar event for accepted meeting: ${meetingTitle}`);
          console.log(`üïê Time: ${proposedTime}`);
          console.log(`üë§ With: ${senderEmail}`);

          // Create calendar event directly using calendar service
          try {
            // Initialize calendar service for this user (same way as meeting confirmation service)
            const { CalendarService } = await import('./services/calendar');
            const calendarService = new CalendarService();

            // Get user credentials and initialize calendar service
            const credentials = await tokenStorageService.getDecryptedCredentials(userId);
            if (!credentials) {
              throw new Error('No OAuth credentials found for user');
            }

            await calendarService.setStoredTokens(credentials.accessToken, credentials.refreshToken);

            // Create calendar event with proper structure
            const startTime = new Date(proposedTime);
            const durationMinutes = Math.min(context.meetingRequest.duration || 60, 120); // Cap at 2 hours max
            console.log(`üìÖ [CALENDAR DEBUG] Duration calculation:`, {
              originalDuration: context.meetingRequest.duration,
              fallbackDuration: 60,
              maxCap: 120,
              finalDuration: durationMinutes,
              startTime: startTime.toISOString(),
              durationMs: durationMinutes * 60000
            });
            const endTime = new Date(startTime.getTime() + durationMinutes * 60000);

            const calendarEvent = {
              summary: meetingTitle,
              description: `Meeting confirmed via Chief AI Assistant\n\nOriginal request: ${context.meetingRequest.subject || 'Meeting request'}`,
              start: {
                dateTime: startTime.toISOString(),
                timeZone: 'America/Los_Angeles' // PST timezone to match existing system
              },
              end: {
                dateTime: endTime.toISOString(),
                timeZone: 'America/Los_Angeles' // PST timezone to match existing system
              },
              attendees: senderEmail ? [{ email: senderEmail }] : []
            };

            const eventResult = await calendarService.createCalendarEvent(calendarEvent);

            calendarEventId = eventResult.id;
            calendarBooked = true;
            console.log(`‚úÖ Calendar event created directly: ${calendarEventId}`);

          } catch (calendarError) {
            console.warn('‚ö†Ô∏è Failed to create calendar event (continuing with email send):', calendarError);
            // Don't fail the entire operation if calendar booking fails
          }
        } else {
          console.log(`üìù Meeting response type: ${actionTaken} - no calendar event needed`);
        }

      } catch (meetingError) {
        console.warn('‚ö†Ô∏è Failed to process meeting response (continuing with email send):', meetingError);
      }
    }

    // LEGACY: Support old meeting confirmation system for backward compatibility
    let meetingConfirmationId = null;
    if (draftWithEmail.context_used && draftWithEmail.context_used.meetingRequest && draftWithEmail.context_used.meetingRequest.id) {
      try {
        const meetingRequestId = draftWithEmail.context_used.meetingRequest.id;
        const selectedTimeSlot = draftWithEmail.context_used.meetingRequest.selectedTimeSlot;

        console.log(`üìÖ [LEGACY] Creating meeting confirmation for draft ${draftId}...`);

        const confirmation = await meetingConfirmationService.createMeetingConfirmation(
          `draft_${draftId}_${Date.now()}`,
          meetingRequestId,
          userId,
          selectedTimeSlot
        );

        meetingConfirmationId = confirmation.id;
        console.log(`‚úÖ [LEGACY] Meeting confirmation created: ${meetingConfirmationId}`);

      } catch (confirmationError) {
        console.warn('‚ö†Ô∏è Failed to create legacy meeting confirmation:', confirmationError);
      }
    }

    console.log(`‚úÖ Draft ${draftId} sent successfully via Gmail API`);
    console.log(`üìß Gmail Message ID: ${sendResult.messageId}`);

    res.json({
      message: 'Auto-generated draft sent successfully via Gmail',
      draftId: draftId,
      subject: draftWithEmail.subject,
      sentAt: new Date(),
      gmailMessageId: sendResult.messageId,
      gmailThreadId: sendResult.threadId,
      // NEW: Calendar booking information
      calendarBooked: calendarBooked,
      calendarEventId: calendarEventId,
      // LEGACY: Meeting confirmation for old system
      meetingConfirmationId: meetingConfirmationId
    });
  } catch (error) {
    console.error('‚ùå Error sending auto-generated draft:', error);
    
    // If Gmail API fails, still update status but mark as error
    try {
      const draftId = parseInt(req.params.id);
      await autoGeneratedDraftModel.updateDraftStatus(draftId, 'sent');
      console.log(`‚ö†Ô∏è Draft ${draftId} marked as sent despite Gmail API error`);
    } catch (updateError) {
      console.error('‚ùå Error updating draft status after send failure:', updateError);
    }
    
    res.status(500).json({ 
      error: 'Failed to send auto-generated draft',
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

// POST /auto-drafts/:id/decline - Generate decline response for meeting
app.post('/auto-drafts/:id/decline', authMiddleware.authenticate, async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    const userId = getUserId(req);
    const { reason } = req.body;

    // Validate reason input
    if (!reason || typeof reason !== 'string' || reason.trim().length < 5) {
      return res.status(400).json({
        error: 'Decline reason is required (minimum 5 characters)'
      });
    }

    console.log(`üö´ [DECLINE] User ${userId} declining draft ${draftId}: "${reason.substring(0, 50)}..."`);

    // Get existing draft with original email context
    const existingDraft = await autoGeneratedDraftModel.getDraftByIdWithEmail(draftId);

    if (!existingDraft) {
      return res.status(404).json({ error: 'Draft not found' });
    }

    // Validate user owns this draft
    if (existingDraft.user_id !== userId) {
      return res.status(403).json({ error: 'Unauthorized to decline this draft' });
    }

    // Validate this is a meeting response
    if (existingDraft.relationship_type !== 'meeting_response') {
      return res.status(400).json({
        error: 'Can only decline meeting response drafts'
      });
    }

    // Extract meeting context
    const context = existingDraft.context_used;
    if (!context?.meetingRequest || !context?.originalEmail) {
      return res.status(400).json({
        error: 'Missing meeting context in draft'
      });
    }

    console.log(`üìß [DECLINE] Original meeting from: ${context.originalEmail.from}`);
    console.log(`üìÖ [DECLINE] Meeting type: ${context.meetingRequest.type}`);

    // Get user's communication tone
    const getUserTone = async (userId: string): Promise<'professional' | 'casual' | 'friendly'> => {
      try {
        const result = await pool.query(`
          SELECT pattern_value, recommendation
          FROM learning_insights
          WHERE pattern_type = 'tone'
          AND user_id = $1
          AND confidence > 60
          ORDER BY success_rate DESC, created_at DESC
          LIMIT 1
        `, [userId]);

        if (result.rows.length > 0) {
          const toneData = result.rows[0];
          const patternValue = toneData.pattern_value?.toLowerCase() || '';
          const recommendation = toneData.recommendation?.toLowerCase() || '';

          if (patternValue.includes('casual') || recommendation.includes('casual')) return 'casual';
          if (patternValue.includes('friendly') || recommendation.includes('friendly')) return 'friendly';
          if (patternValue.includes('professional') || recommendation.includes('professional')) return 'professional';
        }

        return 'professional';
      } catch (error) {
        console.error('‚ùå Error getting user tone:', error);
        return 'professional';
      }
    };

    const userTone = await getUserTone(userId);
    console.log(`üé® [DECLINE] Using tone: ${userTone}`);

    // Get user's name for signature
    const getUserName = async (userId: string): Promise<string> => {
      try {
        const result = await pool.query(`
          SELECT first_name, last_name, full_name
          FROM user_gmail_tokens
          WHERE user_id = $1
        `, [userId]);

        if (result.rows.length > 0) {
          const userData = result.rows[0];
          // Use full_name if available, otherwise first_name, otherwise empty
          return userData.full_name || userData.first_name || '';
        }

        return '';
      } catch (error) {
        console.error('‚ùå Error getting user name:', error);
        return '';
      }
    };

    const userName = await getUserName(userId);
    console.log(`üë§ [DECLINE] User name: ${userName || '(not set)'}`);

    // Build decline request for AI service
    const declineRequest: any = {
      action: 'decline',
      meetingRequest: context.meetingRequest,
      email: {
        id: context.originalEmail.gmailId || '',
        subject: context.originalEmail.subject || '',
        from: context.originalEmail.from || '',
        threadId: context.originalEmail.threadId || '',
        body: context.originalEmail.body || '',
        date: new Date(),
        to: '',
        snippet: ''
      },
      context: {
        senderRelationship: 'new_contact',
        isAvailable: false,
        userTone: userTone,
        meetingType: context.meetingRequest.type || 'regular',
        urgencyLevel: context.meetingRequest.urgency || 'medium'
      },
      declineReason: reason.trim(),
      userName: userName || undefined // Pass user's name to AI (or undefined if not set)
    };

    // Generate decline response using AI service (with fallback)
    const { MeetingAIContentService } = await import('./services/meetingAIContent');
    const aiContentService = new MeetingAIContentService(aiService);

    console.log(`ü§ñ [DECLINE] Generating AI decline response...`);
    const declineResponse = await aiContentService.generateEnhancedContent(declineRequest);

    let finalResponseText = declineResponse.responseText;
    let wasAIGenerated = declineResponse.aiGenerated;

    // Template fallback if AI fails
    if (declineResponse.fallbackUsed || !finalResponseText || finalResponseText.length < 20) {
      console.warn('‚ö†Ô∏è [DECLINE] AI generation failed, using template fallback');

      const generateDeclineTemplate = (tone: string, reason: string, name: string): string => {
        const greeting = tone === 'casual' ? 'Hi,' : 'Hello,';
        const closing = tone === 'casual' ? 'Best,' : 'Best regards,';

        return `${greeting}

Thank you for your meeting invitation. Unfortunately, I won't be able to make it as ${reason.toLowerCase()}.

I appreciate you thinking of me, and I hope we can connect another time.

${closing}${name ? '\n' + name : ''}`;
      };

      finalResponseText = generateDeclineTemplate(userTone, reason, userName);
      wasAIGenerated = false;
      console.log(`üìù [DECLINE] Using template fallback (${finalResponseText.length} chars)`);
    } else {
      console.log(`‚úÖ [DECLINE] AI generated response (${finalResponseText.length} chars, confidence: ${declineResponse.confidence})`);
    }

    // Safety: Remove any placeholder text if AI still included it
    if (userName) {
      finalResponseText = finalResponseText
        .replace(/\[Your [Nn]ame\]/g, userName)
        .replace(/\[your [Nn]ame\]/g, userName);

      // Log if we had to do replacement (means AI didn't follow instructions)
      if (finalResponseText.includes('[Your') || finalResponseText.includes('[your')) {
        console.warn('‚ö†Ô∏è [DECLINE] AI included placeholder despite instructions - replaced with actual name');
      }
    } else {
      // If no userName, just remove the placeholder entirely
      finalResponseText = finalResponseText
        .replace(/\[Your [Nn]ame\]\n?/g, '')
        .replace(/\[your [Nn]ame\]\n?/g, '');
    }

    // Create new decline draft
    let newDraftId: number;

    const updatedContext = {
      ...context,
      actionTaken: 'declined',
      declineReason: reason,
      previousDraftId: draftId,
      source: 'user_decline_request',
      aiGenerated: wasAIGenerated
    };

    const newDraftQuery = `
      INSERT INTO auto_generated_drafts (
        draft_id, original_email_id, subject, body, tone, urgency_level,
        context_used, relationship_type, status, user_id, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
      RETURNING id
    `;

    // Mark the old draft as superseded before creating new one
    await pool.query(
      `UPDATE auto_generated_drafts SET status = $1 WHERE id = $2`,
      ['superseded', draftId]
    );
    console.log(`üîÑ [DECLINE] Marked old draft ${draftId} as superseded`);

    const result = await pool.query(newDraftQuery, [
      `decline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      existingDraft.original_email_id,
      existingDraft.subject,
      finalResponseText,
      userTone,
      existingDraft.urgency_level,
      JSON.stringify(updatedContext),
      'meeting_response',
      'pending',
      userId
    ]);

    newDraftId = result.rows[0].id;
    console.log(`‚úÖ [DECLINE] New decline draft created: ${newDraftId}`);

    res.json({
      message: 'Decline response generated successfully',
      newDraftId: newDraftId,
      responseText: finalResponseText,
      aiGenerated: wasAIGenerated
    });

  } catch (error) {
    console.error('‚ùå [DECLINE] Error generating decline response:', error);
    res.status(500).json({
      error: 'Failed to generate decline response',
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

// DELETE /auto-drafts/:id - Delete unwanted draft
app.delete('/auto-drafts/:id', async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    
    const existingDraft = await autoGeneratedDraftModel.getDraftById(draftId);
    if (!existingDraft) {
      return res.status(404).json({ error: 'Auto-generated draft not found' });
    }

    await autoGeneratedDraftModel.updateDraftStatus(draftId, 'deleted');
    
    res.json({
      message: 'Auto-generated draft deleted successfully',
      draftId: draftId
    });
  } catch (error) {
    console.error('‚ùå Error deleting auto-generated draft:', error);
    res.status(500).json({ error: 'Failed to delete auto-generated draft' });
  }
});

// POST /auto-drafts/:id/approve - Approve draft without changes
app.post('/auto-drafts/:id/approve', async (req, res) => {
  try {
    const draftId = parseInt(req.params.id);
    const draft = await autoGeneratedDraftModel.getDraftById(draftId);
    
    if (!draft) {
      return res.status(404).json({ error: 'Auto-generated draft not found' });
    }

    await autoGeneratedDraftModel.updateDraftStatus(draftId, 'reviewed');
    
    res.json({
      message: 'Auto-generated draft approved successfully',
      draftId: draftId,
      approvedAt: new Date()
    });
  } catch (error) {
    console.error('‚ùå Error approving auto-generated draft:', error);
    res.status(500).json({ error: 'Failed to approve auto-generated draft' });
  }
});

// CLI testing function
export async function testPhase1() {
  console.log('\nüß™ PHASE 1 TEST: Email Reading & Parsing\n');
  
  try {
    await initializeServices();
    
    console.log('üìä Current email stats:');
    const stats = await emailModel.getEmailStats();
    console.log(`   Total emails in database: ${stats.total}`);
    console.log(`   Unread emails: ${stats.unread}`);
    
    console.log('\nüìß Recent emails in database:');
    const recentEmails = await emailModel.getRecentEmails(5);
    
    recentEmails.forEach((email, index) => {
      console.log(`\n${index + 1}. ${email.is_read ? '‚úÖ' : 'üî¥'} ${email.subject}`);
      console.log(`   From: ${email.from_email}`);
      console.log(`   Date: ${email.received_at.toLocaleDateString()}`);
      console.log(`   Preview: ${email.body?.substring(0, 100)}...`);
    });

    console.log('\n‚úÖ Phase 1 test completed successfully!');
    console.log('\nNext steps:');
    console.log('1. Start the server: npm run dev');
    console.log('2. Visit: http://localhost:3000/auth');
    console.log('3. Complete OAuth flow');
    console.log('4. Fetch emails: http://localhost:3000/emails/fetch');
    console.log('5. View emails: http://localhost:3000/emails');
    
  } catch (error) {
    console.error('‚ùå Phase 1 test failed:', error);
  }
}

// Start server
if (require.main === module) {
  // Check if running as test
  if (process.argv[2] === 'test') {
    testPhase1().then(() => process.exit(0));
  } else {
    // Email parsing health monitoring
    app.get('/health/email-parsing', async (req, res) => {
      try {
        const failedEmails = (global as any).failedEmails || [];
        const recentFailures = failedEmails.slice(-10);
        
        res.json({
          status: failedEmails.length === 0 ? 'healthy' : 'issues_detected',
          totalFailures: failedEmails.length,
          recentFailures,
          recommendations: failedEmails.length > 0 ? [
            'Check Gmail API permissions',
            'Verify email structure in Gmail',
            'Consider manual inspection of failed emails'
          ] : []
        });
      } catch (error) {
        console.error('Health check error:', error);
        res.status(500).json({ error: 'Health check failed' });
      }
    });

    // Clear failed emails log
    app.post('/health/clear-failures', (req, res) => {
      (global as any).failedEmails = [];
      res.json({ message: 'Failed emails log cleared' });
    });

    // Schema management endpoint (temporary for fixing issues)
    app.post('/admin/reset-context-schema', async (req, res) => {
      try {
        const fs = require('fs');
        const path = require('path');
        
        console.log('üîß Resetting context intelligence schema...');
        
        // Read and execute the fix script
        const fixScriptPath = path.join(__dirname, '../scripts/database/fix_schema.sql');
        if (fs.existsSync(fixScriptPath)) {
          const fixScript = fs.readFileSync(fixScriptPath, 'utf8');
          await pool.query(fixScript);
          console.log('‚úÖ Old schema dropped successfully');
        }
        
        // Re-apply the corrected Phase 2.2 schema
        const schemaPath = path.join(__dirname, '../scripts/database/phase2_2_schema.sql');
        const schema = fs.readFileSync(schemaPath, 'utf8');
        await pool.query(schema);
        console.log('‚úÖ New schema applied successfully');
        
        res.json({ 
          message: 'Context intelligence schema reset successfully',
          status: 'success'
        });
      } catch (error) {
        console.error('‚ùå Schema reset failed:', error);
        res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
      }
    });

    // Apply Phase 2.3 schema (temporary endpoint)
    app.post('/admin/apply-phase23-schema', async (req, res) => {
      try {
        const fs = require('fs');
        const path = require('path');
        
        console.log('üîß Applying Phase 2.3 schema...');
        
        // Apply the simplified Phase 2.3 schema
        const schemaPath = path.join(__dirname, '../scripts/database/create_phase23_tables.sql');
        if (fs.existsSync(schemaPath)) {
          const schema = fs.readFileSync(schemaPath, 'utf8');
          await pool.query(schema);
          console.log('‚úÖ Phase 2.3 schema applied successfully');
        }
        
        res.json({ 
          message: 'Phase 2.3 schema applied successfully',
          status: 'success'
        });
      } catch (error) {
        console.error('‚ùå Phase 2.3 schema application failed:', error);
        res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
      }
    });

    // Fix missing context_used column
    app.post('/admin/fix-context-column', async (req, res) => {
      try {
        const fs = require('fs');
        const path = require('path');
        
        console.log('üîß Adding missing context_used column...');
        
        const schemaPath = path.join(__dirname, '../scripts/database/add_context_used_column.sql');
        if (fs.existsSync(schemaPath)) {
          const schema = fs.readFileSync(schemaPath, 'utf8');
          await pool.query(schema);
          console.log('‚úÖ Context_used column added successfully');
        }
        
        res.json({ 
          message: 'Context_used column added successfully',
          status: 'success'
        });
      } catch (error) {
        console.error('‚ùå Column addition failed:', error);
        res.status(500).json({ error: error instanceof Error ? error.message : 'Unknown error' });
      }
    });

    // Manual email inspection tool
    app.get('/debug/email/:emailId', async (req, res) => {
      try {
        const { emailId } = req.params;
        
        // Get raw email data by re-fetching (since gmail is private)
        const sentEmails = await gmailService.getSentEmails(1);
        const foundEmail = sentEmails.find(e => e.id === emailId);
        
        if (!foundEmail) {
          return res.status(404).json({ error: 'Email not found' });
        }
        
        const parsed = gmailService.parseEmail(foundEmail);
        
        res.json({
          emailId,
          rawStructure: {
            hasDirectBody: !!foundEmail.payload.body?.data,
            partsCount: foundEmail.payload.parts?.length || 0,
            mimeTypes: foundEmail.payload.parts?.map((p: any) => p.mimeType) || [],
          },
          parsedResult: {
            bodyLength: parsed.body.length,
            subject: parsed.subject,
            from: parsed.from,
            bodyPreview: parsed.body.substring(0, 200) + (parsed.body.length > 200 ? '...' : '')
          },
          failedAttempts: (global as any).failedEmails?.find((f: any) => f.id === emailId)?.attempts || []
        });
      } catch (error) {
        console.error('Email debug error:', error);
        res.status(500).json({ error: 'Failed to debug email' });
      }
    });

    // Manual schema application endpoint
    app.post('/admin/apply-phase2-2-schema', async (req, res) => {
      try {
        const fs = require('fs');
        const path = require('path');
        
        const phase2_2SchemaPath = path.join(__dirname, '../scripts/database/phase2_2_schema.sql');
        const phase2_2Schema = fs.readFileSync(phase2_2SchemaPath, 'utf8');
        await pool.query(phase2_2Schema);
        
        res.json({ 
          message: 'Phase 2.2 schema applied successfully',
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        console.error('‚ùå Error applying Phase 2.2 schema:', error);
        res.status(500).json({ 
          error: 'Failed to apply schema',
          message: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    app.post('/admin/apply-phase3-calendar-schema', async (req, res) => {
      try {
        const fs = require('fs');
        const path = require('path');
        
        console.log('üìÖ Applying Phase 3 Calendar Intelligence schema...');
        
        const phase3SchemaPath = path.join(__dirname, '../scripts/database/phase3_calendar_schema.sql');
        const phase3Schema = fs.readFileSync(phase3SchemaPath, 'utf8');
        await pool.query(phase3Schema);
        
        console.log('‚úÖ Phase 3 Calendar schema applied successfully');
        
        res.json({ 
          message: 'Phase 3 Calendar Intelligence schema applied successfully',
          timestamp: new Date().toISOString()
        });
      } catch (error) {
        console.error('‚ùå Error applying Phase 3 Calendar schema:', error);
        res.status(500).json({ 
          error: 'Failed to apply Phase 3 Calendar schema',
          message: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // Add webhook_processed flag migration
    app.post('/admin/add-webhook-processed-flag', async (req, res) => {
      try {
        const fs = require('fs');
        const path = require('path');
        
        console.log('üîß Adding webhook_processed flag to emails table...');
        
        const migrationPath = path.join(__dirname, '../scripts/database/add_webhook_processed_flag.sql');
        const migration = fs.readFileSync(migrationPath, 'utf8');
        
        await pool.query(migration);
        
        console.log('‚úÖ webhook_processed flag added successfully');
        res.json({ 
          message: 'webhook_processed flag added successfully',
          timestamp: new Date()
        });
      } catch (error) {
        console.error('‚ùå Error adding webhook_processed flag:', error);
        res.status(500).json({ 
          error: 'Failed to add webhook_processed flag',
          message: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // Phase 2.2: Deep Context Intelligence endpoints
    app.post('/context/analyze-emails', async (req, res) => {
      try {
        console.log('üß† Starting deep context analysis on emails...');
        
        // Get emails that need context analysis
        const emailsToAnalyze = await contextModel.getEmailsNeedingContextAnalysis(10);
        console.log(`üìß Found ${emailsToAnalyze.length} emails needing context analysis`);

        let processedCount = 0;
        const results = [];

        for (const email of emailsToAnalyze) {
          try {
            // Convert database email to ParsedEmail format
            const parsedEmail = {
              id: email.id.toString(),
              threadId: email.thread_id,
              subject: email.subject,
              from: email.from_email,
              to: email.to_email || '',
              date: new Date(email.received_at),
              body: email.body,
              isRead: email.is_read
            };
            
            // Analyze sender intelligence
            const senderProfile = await contextService.analyzeSender(parsedEmail);
            
            // Group emails by thread for context analysis (MUST be done BEFORE extracting entities)
            const threadEmails = emailsToAnalyze.filter(e => e.thread_id === email.thread_id);
            const parsedThreadEmails = threadEmails.map(e => ({
              id: e.id.toString(),
              threadId: e.thread_id,
              subject: e.subject,
              from: e.from_email,
              to: e.to_email || '',
              date: new Date(e.received_at),
              body: e.body,
              isRead: e.is_read
            }));
            
            const threadContext = await contextService.analyzeThreadContext(parsedThreadEmails);
            
            // Extract entities (AFTER thread context is created to satisfy foreign key)
            const entities = await contextService.extractEntities(parsedEmail);

            // Mark as analyzed
            await contextModel.markEmailContextAnalyzed(email.id);
            
            processedCount++;
            results.push({
              emailId: email.id,
              senderProfile: senderProfile.display_name || senderProfile.email_address,
              entitiesFound: entities.length,
              threadContext: threadContext ? threadContext.context_summary : null
            });

          } catch (error) {
            console.error(`‚ùå Error processing email ${email.id}:`, error);
            results.push({
              emailId: email.id,
              error: error instanceof Error ? error.message : 'Unknown error'
            });
          }
        }

        res.json({
          message: `Context analysis completed`,
          emailsProcessed: processedCount,
          totalEmails: emailsToAnalyze.length,
          results
        });

      } catch (error) {
        console.error('‚ùå Error in context analysis:', error);
        res.status(500).json({ error: 'Context analysis failed' });
      }
    });

    app.get('/context/stats', async (req, res) => {
      try {
        const stats = await contextModel.getContextStats();
        res.json({
          message: 'Context intelligence statistics',
          stats
        });
      } catch (error) {
        console.error('‚ùå Error getting context stats:', error);
        res.status(500).json({ error: 'Failed to get context stats' });
      }
    });

    app.get('/context/threads', async (req, res) => {
      try {
        const threads = await contextModel.getThreadAnalytics();
        res.json({
          message: 'Email thread analytics',
          threads
        });
      } catch (error) {
        console.error('‚ùå Error getting thread analytics:', error);
        res.status(500).json({ error: 'Failed to get thread analytics' });
      }
    });

    app.get('/context/senders', async (req, res) => {
      try {
        const senders = await contextModel.getSenderInsights();
        res.json({
          message: 'Sender relationship insights',
          senders
        });
      } catch (error) {
        console.error('‚ùå Error getting sender insights:', error);
        res.status(500).json({ error: 'Failed to get sender insights' });
      }
    });

    app.get('/context/entities', async (req, res) => {
      try {
        const entities = await contextModel.getEntityInsights();
        res.json({
          message: 'Entity extraction insights',
          entities
        });
      } catch (error) {
        console.error('‚ùå Error getting entity insights:', error);
        res.status(500).json({ error: 'Failed to get entity insights' });
      }
    });

    app.get('/context/thread/:threadId', async (req, res) => {
      try {
        const { threadId } = req.params;
        const threadContext = await contextModel.getThreadFullContext(threadId);
        
        if (!threadContext) {
          return res.status(404).json({ error: 'Thread not found' });
        }

        res.json({
          message: 'Full thread context',
          threadId,
          context: threadContext
        });
      } catch (error) {
        console.error('‚ùå Error getting thread context:', error);
        res.status(500).json({ error: 'Failed to get thread context' });
      }
    });

    app.get('/context/health', async (req, res) => {
      try {
        const health = await contextModel.contextHealthCheck();
        res.json({
          message: 'Context intelligence health check',
          health
        });
      } catch (error) {
        console.error('‚ùå Error checking context health:', error);
        res.status(500).json({ error: 'Failed to check context health' });
      }
    });

    // Phase 2.3: Smart Response Generation endpoints
    app.post('/response/generate-smart', authMiddleware.authenticate, async (req, res) => {
      try {
        const { emailId, recipientEmail, originalSubject, originalBody, customInstructions } = req.body;
        const userId = getUserId(req);
        
        if (!recipientEmail || !originalSubject || !originalBody) {
          return res.status(400).json({ 
            error: 'Missing required fields: recipientEmail, originalSubject, originalBody' 
          });
        }

        console.log(`ü§ñ Generating smart response for ${recipientEmail}...`);
        
        const responseRequest = {
          emailId: emailId || null,
          recipientEmail,
          originalSubject,
          originalBody,
          responseType: 'reply' as const,
          customInstructions,
          userId: userId // ‚úÖ Add userId for proper user isolation
        };

        const smartResponse = await responseService.generateSmartResponse(responseRequest);
        
        res.json({
          message: 'Smart response generated successfully',
          response: smartResponse
        });

      } catch (error) {
        console.error('‚ùå Error generating smart response:', error);
        res.status(500).json({ error: 'Failed to generate smart response' });
      }
    });

    app.get('/response/templates', async (req, res) => {
      try {
        const { relationshipType, urgencyLevel, templateType } = req.query;
        
        let query = 'SELECT * FROM response_templates WHERE is_active = true';
        const params: any[] = [];
        let paramCount = 1;

        if (relationshipType) {
          query += ` AND relationship_context = $${paramCount}`;
          params.push(relationshipType);
          paramCount++;
        }
        
        if (urgencyLevel) {
          query += ` AND urgency_context = $${paramCount}`;
          params.push(urgencyLevel);
          paramCount++;
        }
        
        if (templateType) {
          query += ` AND template_type = $${paramCount}`;
          params.push(templateType);
          paramCount++;
        }
        
        query += ' ORDER BY success_rate DESC, usage_count DESC';
        
        const result = await pool.query(query, params);
        
        res.json({
          message: 'Response templates retrieved',
          templates: result.rows
        });

      } catch (error) {
        console.error('‚ùå Error fetching templates:', error);
        res.status(500).json({ error: 'Failed to fetch templates' });
      }
    });

    app.get('/response/stats', async (req, res) => {
      try {
        const statsQuery = `
          SELECT 
            COUNT(*) as total_generated,
            COUNT(*) FILTER (WHERE was_sent = true) as total_sent,
            COUNT(*) FILTER (WHERE user_edited = true) as total_edited,
            AVG(confidence) as avg_confidence,
            AVG(edit_percentage) FILTER (WHERE user_edited = true) as avg_edit_percentage,
            AVG(user_rating) FILTER (WHERE user_rating IS NOT NULL) as avg_user_rating
          FROM generated_responses
          WHERE generated_at >= CURRENT_DATE - INTERVAL '30 days';
        `;
        
        const recentStatsQuery = `
          SELECT 
            urgency_level,
            relationship_type,
            COUNT(*) as count,
            AVG(confidence) as avg_confidence
          FROM generated_responses 
          WHERE generated_at >= CURRENT_DATE - INTERVAL '7 days'
          GROUP BY urgency_level, relationship_type
          ORDER BY count DESC;
        `;

        const [stats, recentStats] = await Promise.all([
          pool.query(statsQuery),
          pool.query(recentStatsQuery)
        ]);

        res.json({
          message: 'Response generation statistics',
          stats: stats.rows[0],
          recentBreakdown: recentStats.rows
        });

      } catch (error) {
        console.error('‚ùå Error fetching response stats:', error);
        res.status(500).json({ error: 'Failed to fetch response stats' });
      }
    });

    app.post('/response/feedback', async (req, res) => {
      try {
        const { responseId, wasEdited, editPercentage, wasSent, userRating } = req.body;
        
        if (!responseId) {
          return res.status(400).json({ error: 'Missing required field: responseId' });
        }

        const updateQuery = `
          UPDATE generated_responses 
          SET 
            user_edited = COALESCE($2, user_edited),
            edit_percentage = COALESCE($3, edit_percentage),
            was_sent = COALESCE($4, was_sent),
            user_rating = COALESCE($5, user_rating),
            edited_at = CASE WHEN $2 = true THEN CURRENT_TIMESTAMP ELSE edited_at END,
            sent_at = CASE WHEN $4 = true THEN CURRENT_TIMESTAMP ELSE sent_at END,
            rated_at = CASE WHEN $5 IS NOT NULL THEN CURRENT_TIMESTAMP ELSE rated_at END
          WHERE response_id = $1
          RETURNING *;
        `;

        const result = await pool.query(updateQuery, [
          responseId,
          wasEdited,
          editPercentage,
          wasSent,
          userRating
        ]);

        if (result.rows.length === 0) {
          return res.status(404).json({ error: 'Response not found' });
        }

        res.json({
          message: 'Feedback recorded successfully',
          response: result.rows[0]
        });

      } catch (error) {
        console.error('‚ùå Error recording feedback:', error);
        res.status(500).json({ error: 'Failed to record feedback' });
      }
    });

    app.get('/response/recent', async (req, res) => {
      try {
        const { limit = 20 } = req.query;
        
        const query = `
          SELECT * FROM generated_responses 
          ORDER BY generated_at DESC 
          LIMIT $1;
        `;
        
        const result = await pool.query(query, [limit]);
        
        res.json({
          message: 'Recent responses retrieved',
          responses: result.rows
        });

      } catch (error) {
        console.error('‚ùå Error fetching recent responses:', error);
        res.status(500).json({ error: 'Failed to fetch recent responses' });
      }
    });

    // Phase 2.4: Learning & Feedback System endpoints
    app.post('/learning/analyze-edit', authMiddleware.authenticate, async (req, res) => {
      try {
        const { responseId, originalText, editedText } = req.body;
        
        if (!responseId || !originalText || !editedText) {
          return res.status(400).json({ 
            error: 'Missing required fields: responseId, originalText, editedText' 
          });
        }

        console.log(`üîç Analyzing edit for response ${responseId}...`);
        
        const analysis = await learningService.analyzeEdit(responseId, originalText, editedText, req.userId);
        
        res.json({
          message: 'Edit analysis completed',
          analysis
        });

      } catch (error) {
        console.error('‚ùå Error analyzing edit:', error);
        res.status(500).json({ error: 'Failed to analyze edit' });
      }
    });

    app.get('/learning/success-metrics', authMiddleware.authenticate, async (req, res) => {
      try {
        const { days = 7 } = req.query;
        const daysNumber = parseInt(days as string);
        
        console.log(`üìä Calculating success metrics for ${daysNumber} days...`);
        
        const metrics = await learningService.calculateSuccessMetrics(daysNumber, true, req.userId);
        
        res.json({
          message: 'Success metrics calculated',
          period: `${daysNumber} days`,
          metrics
        });

      } catch (error) {
        console.error('‚ùå Error calculating success metrics:', error);
        res.status(500).json({ error: 'Failed to calculate success metrics' });
      }
    });

    app.get('/learning/insights', authMiddleware.authenticate, async (req, res) => {
      try {
        const { days = 30 } = req.query;
        const daysNumber = parseInt(days as string);
        
        console.log(`üß† Generating learning insights for ${daysNumber} days...`);
        
        const insights = await learningService.generateLearningInsights(daysNumber, req.userId);
        
        res.json({
          message: 'Learning insights generated',
          period: `${daysNumber} days`,
          insights,
          count: insights.length
        });

      } catch (error) {
        console.error('‚ùå Error generating insights:', error);
        res.status(500).json({ error: 'Failed to generate learning insights' });
      }
    });

    // NOTE: Tone adjustment feature removed - learning insights now integrated directly into response generation

    app.get('/learning/performance-trend', authMiddleware.authenticate, async (req, res) => {
      try {
        const { weeks = 4 } = req.query;
        const weeksNumber = parseInt(weeks as string);
        
        console.log(`üìà Calculating performance trend for ${weeksNumber} weeks...`);
        
        const trend = await learningService.getPerformanceTrend(weeksNumber, req.userId);
        
        res.json({
          message: 'Performance trend calculated',
          period: `${weeksNumber} weeks`,
          trend,
          dataPoints: trend.length
        });

      } catch (error) {
        console.error('‚ùå Error calculating performance trend:', error);
        res.status(500).json({ error: 'Failed to calculate performance trend' });
      }
    });

    app.post('/learning/weekly-analysis', authMiddleware.authenticate, async (req, res) => {
      try {
        console.log('üìä Running weekly performance analysis...');
        
        // Get comprehensive weekly data
        const [metrics, insights, trend] = await Promise.all([
          learningService.calculateSuccessMetrics(7, true, req.userId),
          learningService.generateLearningInsights(7, req.userId),
          learningService.getPerformanceTrend(2, req.userId)
        ]);
        
        // Generate weekly report
        const weeklyReport = {
          period: 'Last 7 days',
          successMetrics: metrics,
          keyInsights: insights,
          trendData: trend,
          recommendations: insights.map(i => i.recommendation),
          overallAssessment: metrics.overallSuccessRate >= 80 ? 'excellent' : 
                            metrics.overallSuccessRate >= 60 ? 'good' : 'needs_improvement'
        };
        
        res.json({
          message: 'Weekly analysis completed',
          report: weeklyReport
        });

      } catch (error) {
        console.error('‚ùå Error running weekly analysis:', error);
        res.status(500).json({ error: 'Failed to run weekly analysis' });
      }
    });

    // üìÖ Phase 3: Calendar Intelligence endpoints

    // Calendar OAuth token sharing (uses same tokens as Gmail)
    app.post('/calendar/set-tokens', async (req, res) => {
      try {
        const { accessToken, refreshToken } = req.body;
        if (!accessToken || !refreshToken) {
          return res.status(400).json({ error: 'Both accessToken and refreshToken are required' });
        }
        
        await calendarService.setStoredTokens(accessToken, refreshToken);
        console.log('‚úÖ Calendar OAuth tokens set successfully');
        res.json({ message: 'Calendar tokens set successfully' });
      } catch (error) {
        console.error('‚ùå Error setting calendar tokens:', error);
        res.status(500).json({ error: 'Failed to set calendar tokens' });
      }
    });

    // Get calendar events for date range (user-specific)
    app.get('/calendar/events', authMiddleware.authenticate, async (req, res) => {
      try {
        const { start, end, maxResults } = req.query;
        
        if (!start || !end) {
          return res.status(400).json({ error: 'start and end date parameters are required (ISO format)' });
        }

        const userId = req.userId;
        if (!userId) {
          return res.status(401).json({ error: 'User authentication required' });
        }

        console.log(`üìÖ Fetching calendar events for user ${userId} from ${start} to ${end}...`);
        
        // Initialize calendar service with user tokens
        const credentials = await tokenStorageService.getDecryptedCredentials(userId);
        if (!credentials) {
          return res.status(401).json({ error: 'Calendar access not authorized' });
        }

        await calendarService.setStoredTokens(credentials.accessToken, credentials.refreshToken);
        
        const events = await calendarService.getCalendarEvents(
          start as string, 
          end as string, 
          parseInt(maxResults as string) || 50
        );

        // Save events to database for caching/analysis
        if (events.length > 0) {
          await calendarModel.saveCalendarEvents(events);
        }

        res.json({
          message: `Retrieved ${events.length} calendar events`,
          events: events,
          dateRange: { start, end },
          user: userId
        });

      } catch (error) {
        console.error('‚ùå Error fetching calendar events:', error);
        res.status(500).json({ error: 'Failed to fetch calendar events' });
      }
    });

    // Just-in-time availability check (user-specific)
    app.post('/calendar/check-availability', authMiddleware.authenticate, async (req, res) => {
      try {
        const { start, end } = req.body;
        
        if (!start || !end) {
          return res.status(400).json({ error: 'start and end datetime are required (ISO format)' });
        }

        const userId = req.userId;
        if (!userId) {
          return res.status(401).json({ error: 'User authentication required' });
        }

        console.log(`üéØ Checking availability for user ${userId}: ${start} to ${end}`);
        
        // Initialize calendar service with user tokens
        const credentials = await tokenStorageService.getDecryptedCredentials(userId);
        if (!credentials) {
          return res.status(401).json({ error: 'Calendar access not authorized' });
        }

        await calendarService.setStoredTokens(credentials.accessToken, credentials.refreshToken);
        
        const availability = await calendarService.checkAvailability(start, end);
        
        res.json({
          message: `Availability check: ${availability.isAvailable ? 'Available' : 'Conflicts found'}`,
          availability: availability,
          user: userId
        });

      } catch (error) {
        console.error('‚ùå Error checking availability:', error);
        res.status(500).json({ error: 'Failed to check availability' });
      }
    });

    // Smart time slot suggestions
    app.post('/calendar/suggest-times', async (req, res) => {
      try {
        const { duration, date, workingHours, maxSuggestions } = req.body;
        
        if (!duration || !date) {
          return res.status(400).json({ error: 'duration (minutes) and date (YYYY-MM-DD) are required' });
        }

        console.log(`üéØ Suggesting time slots: ${duration} minutes on ${date}`);
        
        const suggestions = await calendarService.suggestTimeSlots(
          duration,
          date,
          workingHours || { start: '09:00', end: '17:00' },
          maxSuggestions || 3
        );
        
        res.json({
          message: `Generated ${suggestions.length} time slot suggestions`,
          suggestions: suggestions,
          requestedDuration: duration,
          requestedDate: date
        });

      } catch (error) {
        console.error('‚ùå Error suggesting time slots:', error);
        res.status(500).json({ error: 'Failed to suggest time slots' });
      }
    });

    // Create calendar event
    app.post('/calendar/create-event', async (req, res) => {
      try {
        const { summary, description, start, end, attendees, location } = req.body;
        
        if (!summary || !start || !end) {
          return res.status(400).json({ error: 'summary, start, and end are required' });
        }

        const event = {
          summary,
          description,
          start: { dateTime: start },
          end: { dateTime: end },
          attendees: attendees?.map((email: string) => ({ email })),
          location
        };

        console.log(`üìÖ Creating calendar event: ${summary}`);
        
        const createdEvent = await calendarService.createCalendarEvent(event);
        
        // Save to database
        await calendarModel.saveCalendarEvent(createdEvent);
        
        res.json({
          message: 'Calendar event created successfully',
          event: createdEvent
        });

      } catch (error) {
        console.error('‚ùå Error creating calendar event:', error);
        res.status(500).json({ error: 'Failed to create calendar event' });
      }
    });

    // Calendar preferences management
    app.get('/calendar/preferences', async (req, res) => {
      try {
        console.log('‚öôÔ∏è Fetching calendar preferences...');
        
        const preferences = await calendarModel.getUserPreferences();
        
        res.json({
          message: `Retrieved ${preferences.length} calendar preferences`,
          preferences: preferences
        });

      } catch (error) {
        console.error('‚ùå Error fetching calendar preferences:', error);
        res.status(500).json({ error: 'Failed to fetch calendar preferences' });
      }
    });

    // Update calendar preference
    app.post('/calendar/preferences', async (req, res) => {
      try {
        const { preferenceType, preferenceValue } = req.body;
        
        if (!preferenceType || !preferenceValue) {
          return res.status(400).json({ error: 'preferenceType and preferenceValue are required' });
        }

        console.log(`‚öôÔ∏è Updating calendar preference: ${preferenceType}`);
        
        await calendarModel.updateUserPreference(preferenceType, preferenceValue);
        
        res.json({
          message: `Updated calendar preference: ${preferenceType}`,
          preferenceType: preferenceType,
          preferenceValue: preferenceValue
        });

      } catch (error) {
        console.error('‚ùå Error updating calendar preference:', error);
        res.status(500).json({ error: 'Failed to update calendar preference' });
      }
    });

    // Calendar analytics and stats
    app.get('/calendar/stats', async (req, res) => {
      try {
        console.log('üìä Fetching calendar statistics...');
        
        const stats = await calendarModel.getCalendarStats();
        
        res.json({
          message: 'Calendar statistics retrieved',
          stats: stats
        });

      } catch (error) {
        console.error('‚ùå Error fetching calendar stats:', error);
        res.status(500).json({ error: 'Failed to fetch calendar stats' });
      }
    });

    // Calendar health check
    app.get('/calendar/health', async (req, res) => {
      try {
        console.log('üè• Running calendar health check...');
        
        const [serviceHealth, modelHealth] = await Promise.all([
          calendarService.checkCalendarHealth(),
          calendarModel.calendarHealthCheck()
        ]);
        
        res.json({
          message: 'Calendar health check completed',
          service: serviceHealth,
          database: modelHealth
        });

      } catch (error) {
        console.error('‚ùå Calendar health check failed:', error);
        res.status(500).json({ error: 'Calendar health check failed' });
      }
    });

    // ü§ñ Phase 3.2: Meeting Request Detection endpoints

    // Analyze specific email for meeting request
    app.post('/meetings/detect', async (req, res) => {
      try {
        const { emailId } = req.body;
        if (!emailId) {
          return res.status(400).json({ error: 'emailId is required' });
        }

        console.log(`üîç Detecting meeting request in email ${emailId}...`);

        // Get email from database
        const emailResult = await pool.query('SELECT * FROM emails WHERE id = $1', [emailId]);
        if (emailResult.rows.length === 0) {
          return res.status(404).json({ error: 'Email not found' });
        }

        const email = emailResult.rows[0];
        const parsedEmail = {
          id: email.id.toString(),
          threadId: email.thread_id,
          subject: email.subject,
          from: email.from_email,
          to: email.to_email || '',
          date: email.received_at,
          body: email.body,
          isRead: email.is_read
        };

        // Detect meeting request
        const meetingRequest = await meetingDetectionService.detectMeetingRequest(parsedEmail);
        
        if (meetingRequest) {
          // Save to database
          const meetingRequestId = await calendarModel.saveMeetingRequest(meetingRequest);
          
          res.json({
            message: 'Meeting request detected successfully',
            meetingRequest: { ...meetingRequest, id: meetingRequestId }
          });
        } else {
          res.json({
            message: 'No meeting request detected in this email',
            meetingRequest: null
          });
        }

      } catch (error) {
        console.error('‚ùå Error detecting meeting request:', error);
        res.status(500).json({ error: 'Failed to detect meeting request' });
      }
    });

    // Analyze all unprocessed emails for meeting requests
    app.post('/meetings/scan-emails', async (req, res) => {
      try {
        const { limit = 10 } = req.body;
        
        console.log(`üîç Scanning recent emails for meeting requests (limit: ${limit})...`);

        // Get recent emails that haven't been scanned for meetings
        const emailsQuery = `
          SELECT * FROM emails 
          WHERE id NOT IN (SELECT DISTINCT email_id FROM meeting_requests WHERE email_id IS NOT NULL)
          ORDER BY received_at DESC 
          LIMIT $1
        `;
        
        const emailsResult = await pool.query(emailsQuery, [limit]);
        const emails = emailsResult.rows;

        if (emails.length === 0) {
          return res.json({
            message: 'No new emails to scan for meeting requests',
            meetingRequests: []
          });
        }

        const meetingRequests = [];
        let processed = 0;

        for (const email of emails) {
          try {
            const parsedEmail = {
              id: email.id.toString(),
              threadId: email.thread_id,
              subject: email.subject,
              from: email.from_email,
              to: email.to_email || '',
              date: email.received_at,
              body: email.body,
              isRead: email.is_read
            };

            const meetingRequest = await meetingDetectionService.detectMeetingRequest(parsedEmail);
            
            if (meetingRequest) {
              const meetingRequestId = await calendarModel.saveMeetingRequest(meetingRequest);
              meetingRequests.push({ ...meetingRequest, id: meetingRequestId });
            }
            
            processed++;

          } catch (error) {
            console.error(`‚ùå Error processing email ${email.id}:`, error);
          }
        }

        res.json({
          message: `Meeting request scan completed`,
          emailsProcessed: processed,
          meetingRequestsFound: meetingRequests.length,
          meetingRequests
        });

      } catch (error) {
        console.error('‚ùå Error scanning emails for meeting requests:', error);
        res.status(500).json({ error: 'Failed to scan emails for meeting requests' });
      }
    });

    // Get all meeting requests
    app.get('/meetings/requests', async (req, res) => {
      try {
        const { status, limit = 20 } = req.query;
        
        console.log('üìã Fetching meeting requests...');

        let query = `
          SELECT 
            mr.*,
            e.subject as email_subject,
            e.from_email,
            e.received_at as email_date
          FROM meeting_requests mr
          LEFT JOIN emails e ON mr.email_id = e.id
        `;
        
        const params: any[] = [];
        let paramCount = 1;

        if (status) {
          query += ` WHERE mr.status = $${paramCount}`;
          params.push(status);
          paramCount++;
        }

        query += ` ORDER BY mr.created_at DESC LIMIT $${paramCount}`;
        params.push(limit);

        const result = await pool.query(query, params);
        
        res.json({
          message: `Retrieved ${result.rows.length} meeting requests`,
          meetingRequests: result.rows
        });

      } catch (error) {
        console.error('‚ùå Error fetching meeting requests:', error);
        res.status(500).json({ error: 'Failed to fetch meeting requests' });
      }
    });

    // Update meeting request status
    app.patch('/meetings/requests/:id', async (req, res) => {
      try {
        const { id } = req.params;
        const { status } = req.body;

        if (!['pending', 'scheduled', 'declined', 'cancelled'].includes(status)) {
          return res.status(400).json({ 
            error: 'Invalid status. Must be: pending, scheduled, declined, cancelled' 
          });
        }

        console.log(`üìù Updating meeting request ${id} status to ${status}...`);

        const result = await pool.query(
          'UPDATE meeting_requests SET status = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2 RETURNING *',
          [status, id]
        );

        if (result.rows.length === 0) {
          return res.status(404).json({ error: 'Meeting request not found' });
        }

        res.json({
          message: 'Meeting request status updated successfully',
          meetingRequest: result.rows[0]
        });

      } catch (error) {
        console.error('‚ùå Error updating meeting request:', error);
        res.status(500).json({ error: 'Failed to update meeting request' });
      }
    });

    // Meeting detection service health check
    app.get('/meetings/health', async (req, res) => {
      try {
        console.log('üè• Running meeting detection health check...');
        
        const health = await meetingDetectionService.healthCheck();
        
        // Get meeting request statistics
        const statsQuery = `
          SELECT 
            COUNT(*) as total_requests,
            COUNT(*) FILTER (WHERE status = 'pending') as pending_requests,
            COUNT(*) FILTER (WHERE status = 'scheduled') as scheduled_requests,
            COUNT(*) FILTER (WHERE created_at >= CURRENT_DATE - INTERVAL '7 days') as recent_requests,
            AVG(detection_confidence) as avg_confidence
          FROM meeting_requests
        `;
        
        const statsResult = await pool.query(statsQuery);
        const stats = statsResult.rows[0];

        res.json({
          message: 'Meeting detection health check completed',
          service: health,
          statistics: {
            totalRequests: parseInt(stats.total_requests),
            pendingRequests: parseInt(stats.pending_requests),
            scheduledRequests: parseInt(stats.scheduled_requests),
            recentRequests: parseInt(stats.recent_requests),
            avgConfidence: parseFloat(stats.avg_confidence) || 0
          },
          lastUpdated: new Date()
        });

      } catch (error) {
        console.error('‚ùå Meeting detection health check failed:', error);
        res.status(500).json({ error: 'Meeting detection health check failed' });
      }
    });

    // ===== MEETING CONFIRMATION ENDPOINTS =====

    // Get pending meeting confirmations for user
    app.get('/meetings/confirmations', authMiddleware.authenticate, async (req, res) => {
      try {
        const userId = req.userId;
        if (!userId) {
          return res.status(401).json({ error: 'User authentication required' });
        }

        console.log(`üìã Fetching pending meeting confirmations for user: ${userId}`);
        
        const confirmations = await meetingConfirmationService.getPendingConfirmations(userId);
        
        res.json({
          message: `Found ${confirmations.length} pending meeting confirmations`,
          confirmations: confirmations
        });

      } catch (error) {
        console.error('‚ùå Error fetching meeting confirmations:', error);
        res.status(500).json({ error: 'Failed to fetch meeting confirmations' });
      }
    });

    // Confirm a meeting and create calendar event
    app.post('/meetings/confirmations/:id/confirm', authMiddleware.authenticate, async (req, res) => {
      try {
        const { id } = req.params;
        const { selectedTimeSlot } = req.body;
        
        const userId = req.userId;
        if (!userId) {
          return res.status(401).json({ error: 'User authentication required' });
        }

        console.log(`üìÖ Confirming meeting: ${id} for user: ${userId}`);
        
        const result = await meetingConfirmationService.confirmMeeting(
          id,
          userId,
          selectedTimeSlot
        );
        
        if (result.success) {
          res.json({
            message: 'Meeting confirmed and calendar event created successfully',
            calendarEventId: result.calendarEventId
          });
        } else {
          res.status(400).json({ 
            error: result.error || 'Failed to confirm meeting' 
          });
        }

      } catch (error) {
        console.error('‚ùå Error confirming meeting:', error);
        res.status(500).json({ error: 'Failed to confirm meeting' });
      }
    });

    // Cancel a meeting confirmation
    app.post('/meetings/confirmations/:id/cancel', authMiddleware.authenticate, async (req, res) => {
      try {
        const { id } = req.params;
        
        const userId = req.userId;
        if (!userId) {
          return res.status(401).json({ error: 'User authentication required' });
        }

        console.log(`‚ùå Cancelling meeting confirmation: ${id} for user: ${userId}`);
        
        const result = await meetingConfirmationService.cancelMeetingConfirmation(
          id,
          userId
        );
        
        if (result.success) {
          res.json({ message: 'Meeting confirmation cancelled successfully' });
        } else {
          res.status(400).json({ 
            error: result.error || 'Failed to cancel meeting confirmation' 
          });
        }

      } catch (error) {
        console.error('‚ùå Error cancelling meeting confirmation:', error);
        res.status(500).json({ error: 'Failed to cancel meeting confirmation' });
      }
    });

    // Get alternative time suggestions for a meeting
    app.get('/meetings/confirmations/:id/suggestions', authMiddleware.authenticate, async (req, res) => {
      try {
        const { id } = req.params;
        const { duration = 60 } = req.query;
        
        const userId = req.userId;
        if (!userId) {
          return res.status(401).json({ error: 'User authentication required' });
        }

        // Get confirmation to find meeting request ID
        const confirmation = await meetingConfirmationService.getMeetingConfirmation(id, userId);
        if (!confirmation) {
          return res.status(404).json({ error: 'Meeting confirmation not found' });
        }

        console.log(`üìÖ Getting alternative time suggestions for meeting: ${id}`);
        
        const suggestions = await meetingConfirmationService.getAlternativeTimeSuggestions(
          confirmation.meetingRequestId,
          userId,
          parseInt(duration as string)
        );
        
        res.json({
          message: `Found ${suggestions.length} alternative time suggestions`,
          suggestions: suggestions
        });

      } catch (error) {
        console.error('‚ùå Error getting alternative time suggestions:', error);
        res.status(500).json({ error: 'Failed to get alternative time suggestions' });
      }
    });

    // ============================================================================
    // PHASE 3.3: AUTO-SCHEDULING SYSTEM - Automated Meeting Scheduling
    // ============================================================================

    // Process meeting request for auto-scheduling
    app.post('/auto-scheduling/process-meeting', async (req, res) => {
      try {
        const { meetingRequestId } = req.body;
        
        if (!meetingRequestId) {
          return res.status(400).json({ error: 'Meeting request ID is required' });
        }

        console.log(`ü§ñ Processing meeting request ${meetingRequestId} for auto-scheduling...`);

        // Get meeting request from database
        const meetingQuery = 'SELECT * FROM meeting_requests WHERE id = $1';
        const meetingResult = await pool.query(meetingQuery, [meetingRequestId]);
        
        if (meetingResult.rows.length === 0) {
          return res.status(404).json({ error: 'Meeting request not found' });
        }

        const meetingRequest = meetingResult.rows[0];
        
        // Process with auto-scheduling service
        const workflow = await autoSchedulingService.processDetectedMeeting(meetingRequest);
        
        if (!workflow) {
          return res.status(500).json({ error: 'Failed to create scheduling workflow' });
        }

        res.json({
          message: 'Auto-scheduling workflow initiated',
          workflow: {
            id: workflow.id,
            type: workflow.workflowType,
            currentStep: workflow.currentStep,
            status: workflow.status,
            progress: `${workflow.stepNumber}/${workflow.totalSteps}`
          }
        });

      } catch (error) {
        console.error('‚ùå Error processing meeting for auto-scheduling:', error);
        res.status(500).json({ error: 'Failed to process meeting request' });
      }
    });

    // Generate time slot suggestions for a meeting
    app.post('/auto-scheduling/suggest-times', async (req, res) => {
      try {
        const { meetingRequestId, recipientEmail } = req.body;
        
        if (!meetingRequestId) {
          return res.status(400).json({ error: 'Meeting request ID is required' });
        }

        console.log(`‚è∞ Generating time suggestions for meeting request ${meetingRequestId}...`);

        // Get meeting request
        const meetingQuery = 'SELECT * FROM meeting_requests WHERE id = $1';
        const meetingResult = await pool.query(meetingQuery, [meetingRequestId]);
        
        if (meetingResult.rows.length === 0) {
          return res.status(404).json({ error: 'Meeting request not found' });
        }

        const meetingRequest = meetingResult.rows[0];
        
        // Generate suggestions
        const suggestions = await autoSchedulingService.generateTimeSlotSuggestions(
          meetingRequest, 
          recipientEmail
        );

        res.json({
          meetingRequestId,
          suggestions: suggestions.map(s => ({
            startTime: s.start,
            endTime: s.end,
            confidence: s.confidence,
            reasoning: s.reason
          }))
        });

      } catch (error) {
        console.error('‚ùå Error generating time suggestions:', error);
        res.status(500).json({ error: 'Failed to generate time suggestions' });
      }
    });

    // Create calendar hold for a time slot
    app.post('/auto-scheduling/create-hold', async (req, res) => {
      try {
        const { meetingRequestId, startTime, endTime, holderEmail, notes } = req.body;
        
        if (!meetingRequestId || !startTime || !endTime || !holderEmail) {
          return res.status(400).json({ 
            error: 'Meeting request ID, start time, end time, and holder email are required' 
          });
        }

        console.log(`üîí Creating calendar hold for meeting ${meetingRequestId}...`);

        const hold = await autoSchedulingService.createCalendarHold(
          meetingRequestId,
          new Date(startTime),
          new Date(endTime),
          holderEmail,
          1440, // 24 hour hold
          notes
        );

        if (!hold) {
          return res.status(409).json({ error: 'Scheduling conflict detected, cannot create hold' });
        }

        res.json({
          message: 'Calendar hold created successfully',
          hold: {
            id: hold.id,
            startTime: hold.startTime,
            endTime: hold.endTime,
            status: hold.status,
            expiryTime: hold.expiryTime
          }
        });

      } catch (error) {
        console.error('‚ùå Error creating calendar hold:', error);
        res.status(500).json({ error: 'Failed to create calendar hold' });
      }
    });

    // Confirm scheduling and create calendar event
    app.post('/auto-scheduling/confirm', async (req, res) => {
      try {
        const { meetingRequestId, selectedTimeSlot, additionalAttendees } = req.body;
        
        if (!meetingRequestId || !selectedTimeSlot) {
          return res.status(400).json({ 
            error: 'Meeting request ID and selected time slot are required' 
          });
        }

        console.log(`‚úÖ Confirming scheduling for meeting ${meetingRequestId}...`);

        const calendarEvent = await autoSchedulingService.confirmScheduling(
          meetingRequestId,
          selectedTimeSlot,
          additionalAttendees
        );

        if (!calendarEvent) {
          return res.status(500).json({ error: 'Failed to confirm scheduling' });
        }

        res.json({
          message: 'Meeting scheduled successfully',
          event: {
            id: calendarEvent.id,
            summary: calendarEvent.summary,
            startTime: calendarEvent.start.dateTime,
            endTime: calendarEvent.end.dateTime,
            attendees: calendarEvent.attendees,
            location: calendarEvent.location
          }
        });

      } catch (error) {
        console.error('‚ùå Error confirming scheduling:', error);
        res.status(500).json({ error: 'Failed to confirm scheduling' });
      }
    });

    // Get scheduling workflows
    app.get('/auto-scheduling/workflows', async (req, res) => {
      try {
        const { status, limit } = req.query;
        
        console.log(`üìã Fetching scheduling workflows (status: ${status || 'all'})...`);

        let query = `
          SELECT sw.*, mr.subject, mr.sender_email, mr.meeting_type, mr.urgency_level
          FROM scheduling_workflows sw
          JOIN meeting_requests mr ON sw.meeting_request_id = mr.id
        `;
        
        const params: any[] = [];
        
        if (status) {
          query += ` WHERE sw.status = $1`;
          params.push(status);
        }
        
        query += ` ORDER BY sw.created_at DESC`;
        
        if (limit) {
          query += ` LIMIT $${params.length + 1}`;
          params.push(parseInt(limit as string));
        }

        const result = await pool.query(query, params);

        res.json({
          workflows: result.rows.map(row => ({
            id: row.id,
            meetingRequestId: row.meeting_request_id,
            workflowType: row.workflow_type,
            currentStep: row.current_step,
            progress: `${row.step_number}/${row.total_steps}`,
            status: row.status,
            createdAt: row.created_at,
            updatedAt: row.updated_at,
            meeting: {
              subject: row.subject,
              senderEmail: row.sender_email,
              meetingType: row.meeting_type,
              urgencyLevel: row.urgency_level
            }
          }))
        });

      } catch (error) {
        console.error('‚ùå Error fetching workflows:', error);
        res.status(500).json({ error: 'Failed to fetch workflows' });
      }
    });

    // Get calendar holds
    app.get('/auto-scheduling/holds', async (req, res) => {
      try {
        const { status, active } = req.query;
        
        console.log(`üîí Fetching calendar holds (status: ${status || 'all'})...`);

        let query = `
          SELECT ch.*, mr.subject, mr.sender_email
          FROM calendar_holds ch
          JOIN meeting_requests mr ON ch.meeting_request_id = mr.id
        `;
        
        const params: any[] = [];
        
        if (status) {
          query += ` WHERE ch.status = $1`;
          params.push(status);
        } else if (active === 'true') {
          query += ` WHERE ch.status IN ('active', 'confirmed') AND ch.expiry_time > NOW()`;
        }
        
        query += ` ORDER BY ch.start_time ASC`;

        const result = await pool.query(query, params);

        res.json({
          holds: result.rows.map(row => ({
            id: row.id,
            meetingRequestId: row.meeting_request_id,
            startTime: row.start_time,
            endTime: row.end_time,
            holderEmail: row.holder_email,
            status: row.status,
            expiryTime: row.expiry_time,
            notes: row.notes,
            meeting: {
              subject: row.subject,
              senderEmail: row.sender_email
            }
          }))
        });

      } catch (error) {
        console.error('‚ùå Error fetching calendar holds:', error);
        res.status(500).json({ error: 'Failed to fetch calendar holds' });
      }
    });

    // Cleanup expired holds
    app.post('/auto-scheduling/cleanup-holds', async (req, res) => {
      try {
        console.log('üßπ Cleaning up expired calendar holds...');
        
        const cleanedCount = await autoSchedulingService.cleanupExpiredHolds();
        
        res.json({
          message: `Cleaned up ${cleanedCount} expired holds`,
          cleanedCount
        });

      } catch (error) {
        console.error('‚ùå Error cleaning up holds:', error);
        res.status(500).json({ error: 'Failed to cleanup expired holds' });
      }
    });

    // Auto-scheduling system health check
    app.get('/auto-scheduling/health', async (req, res) => {
      try {
        console.log('üè• Running auto-scheduling system health check...');
        
        const health = await autoSchedulingService.healthCheck();
        
        // Get workflow statistics
        const workflowStats = await pool.query(`
          SELECT 
            COUNT(*) as total_workflows,
            COUNT(*) FILTER (WHERE status = 'active') as active_workflows,
            COUNT(*) FILTER (WHERE status = 'completed') as completed_workflows,
            COUNT(*) FILTER (WHERE status = 'failed') as failed_workflows
          FROM scheduling_workflows
        `);
        
        res.json({
          service: 'Auto-Scheduling System',
          timestamp: new Date().toISOString(),
          health: {
            status: health.status,
            activeWorkflows: health.activeWorkflows,
            activeHolds: health.activeHolds
          },
          statistics: workflowStats.rows[0] || {
            total_workflows: 0,
            active_workflows: 0,
            completed_workflows: 0,
            failed_workflows: 0
          }
        });

      } catch (error) {
        console.error('‚ùå Auto-scheduling health check failed:', error);
        res.status(500).json({
          service: 'Auto-Scheduling System',
          timestamp: new Date().toISOString(),
          health: { status: 'error', activeWorkflows: 0, activeHolds: 0 },
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // Debug endpoint to initialize Phase 3.3 schema manually
    app.post('/debug/init-phase33-schema', async (req, res) => {
      try {
        console.log('üîß Manually initializing Phase 3.3 schema...');
        
        // Create calendar_holds table first (without foreign key constraint)
        await pool.query(`
          CREATE TABLE IF NOT EXISTS calendar_holds (
              id SERIAL PRIMARY KEY,
              meeting_request_id INTEGER,
              start_time TIMESTAMP WITH TIME ZONE NOT NULL,
              end_time TIMESTAMP WITH TIME ZONE NOT NULL,
              holder_email VARCHAR(255) NOT NULL,
              status VARCHAR(50) DEFAULT 'active' CHECK (status IN ('active', 'confirmed', 'expired', 'cancelled')),
              expiry_time TIMESTAMP WITH TIME ZONE NOT NULL,
              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
              notes TEXT
          );
        `);
        
        // Create scheduling_responses table
        await pool.query(`
          CREATE TABLE IF NOT EXISTS scheduling_responses (
              id SERIAL PRIMARY KEY,
              meeting_request_id INTEGER,
              recipient_email VARCHAR(255) NOT NULL,
              response_type VARCHAR(50) NOT NULL CHECK (response_type IN ('accept_time', 'reject_time', 'suggest_alternative', 'decline_meeting')),
              suggested_time_start TIMESTAMP WITH TIME ZONE,
              suggested_time_end TIMESTAMP WITH TIME ZONE,
              response_confidence DECIMAL(3,2) DEFAULT 0.8,
              ai_analysis JSONB,
              email_content TEXT,
              processed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
          );
        `);
        
        // Create scheduling_workflows table
        await pool.query(`
          CREATE TABLE IF NOT EXISTS scheduling_workflows (
              id SERIAL PRIMARY KEY,
              meeting_request_id INTEGER,
              workflow_type VARCHAR(50) NOT NULL CHECK (workflow_type IN ('direct_schedule', 'negotiate_time', 'multi_recipient', 'recurring_setup')),
              current_step VARCHAR(100) NOT NULL,
              total_steps INTEGER DEFAULT 1,
              step_number INTEGER DEFAULT 1,
              status VARCHAR(50) DEFAULT 'active' CHECK (status IN ('active', 'completed', 'failed', 'cancelled')),
              context JSONB,
              next_action_time TIMESTAMP WITH TIME ZONE,
              retry_count INTEGER DEFAULT 0,
              max_retries INTEGER DEFAULT 3,
              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
              updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
          );
        `);
        
        // Create auto_scheduling_preferences table
        await pool.query(`
          CREATE TABLE IF NOT EXISTS auto_scheduling_preferences (
              id SERIAL PRIMARY KEY,
              user_email VARCHAR(255) NOT NULL,
              preference_type VARCHAR(100) NOT NULL,
              preference_value JSONB NOT NULL,
              priority INTEGER DEFAULT 5,
              is_active BOOLEAN DEFAULT true,
              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
              updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
              UNIQUE(user_email, preference_type)
          );
        `);
        
        // Create indexes
        await pool.query(`
          CREATE INDEX IF NOT EXISTS idx_calendar_holds_meeting_request ON calendar_holds(meeting_request_id);
          CREATE INDEX IF NOT EXISTS idx_calendar_holds_status_expiry ON calendar_holds(status, expiry_time);
          CREATE INDEX IF NOT EXISTS idx_calendar_holds_time_range ON calendar_holds(start_time, end_time);
          
          CREATE INDEX IF NOT EXISTS idx_scheduling_responses_meeting_request ON scheduling_responses(meeting_request_id);
          CREATE INDEX IF NOT EXISTS idx_scheduling_responses_recipient ON scheduling_responses(recipient_email);
          CREATE INDEX IF NOT EXISTS idx_scheduling_responses_type ON scheduling_responses(response_type);
          
          CREATE INDEX IF NOT EXISTS idx_scheduling_workflows_meeting_request ON scheduling_workflows(meeting_request_id);
          CREATE INDEX IF NOT EXISTS idx_scheduling_workflows_status ON scheduling_workflows(status);
          CREATE INDEX IF NOT EXISTS idx_scheduling_workflows_next_action ON scheduling_workflows(next_action_time) WHERE next_action_time IS NOT NULL;
          
          CREATE INDEX IF NOT EXISTS idx_auto_scheduling_preferences_user ON auto_scheduling_preferences(user_email);
          CREATE INDEX IF NOT EXISTS idx_auto_scheduling_preferences_type ON auto_scheduling_preferences(preference_type);
        `);
        
        // Insert default preferences
        await pool.query(`
          INSERT INTO auto_scheduling_preferences (user_email, preference_type, preference_value, priority) VALUES
          ('default', 'working_hours', '{"start": "09:00", "end": "17:00", "timezone": "America/New_York", "days": ["monday", "tuesday", "wednesday", "thursday", "friday"]}', 9),
          ('default', 'buffer_time', '{"before_meeting": 15, "after_meeting": 15, "unit": "minutes"}', 8),
          ('default', 'auto_confirm_threshold', '{"confidence_score": 0.85, "known_contacts_only": false}', 7),
          ('default', 'hold_duration', '{"duration_minutes": 1440, "max_concurrent_holds": 5}', 6),
          ('default', 'meeting_lengths', '{"default": 60, "quick_chat": 15, "brief": 30, "standard": 60, "detailed": 90, "unit": "minutes"}', 5)
          ON CONFLICT (user_email, preference_type) DO NOTHING;
        `);
        
        console.log('‚úÖ Phase 3.3 schema initialized successfully');
        res.json({ message: 'Phase 3.3 schema initialized successfully' });
        
      } catch (error) {
        console.error('‚ùå Error initializing Phase 3.3 schema:', error);
        res.status(500).json({ 
          error: 'Failed to initialize Phase 3.3 schema',
          details: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // Enhanced draft generation with full context
    app.post('/ai/generate-drafts-with-context', async (req, res) => {
      try {
        console.log('‚ú® Generating context-aware drafts...');

        // Get emails that need responses (have context analysis)
        const query = `
          SELECT e.*, et.context_summary, sp.relationship_type, sp.formality_preference
          FROM emails e
          LEFT JOIN email_threads et ON e.thread_id = et.thread_id  
          LEFT JOIN sender_profiles sp ON e.from_email = sp.email_address
          WHERE e.context_analyzed = TRUE 
          AND NOT EXISTS (SELECT 1 FROM drafts d WHERE d.email_id = e.id)
          ORDER BY e.received_at DESC
          LIMIT 5;
        `;
        
        const emailsResult = await pool.query(query);
        const emails = emailsResult.rows;

        if (emails.length === 0) {
          return res.json({ 
            message: 'No emails available for context-aware draft generation',
            suggestion: 'Run context analysis first: POST /context/analyze-emails'
          });
        }

        const generatedDrafts = [];

        for (const email of emails) {
          try {
            const parsedEmail = gmailService.parseEmail(email);
            
            // Get full context for this email
            const fullContext = await contextService.getFullContextForDraft(parsedEmail);
            
            // Get latest tone profile
            const toneProfile = await draftModel.getLatestRealToneProfile();
            if (!toneProfile) {
              throw new Error('No tone profile available. Run tone analysis first.');
            }

            // Generate context-aware draft
            const draft = await aiService.generateDraft(
              {
                subject: parsedEmail.subject,
                body: parsedEmail.body,
                from: parsedEmail.from
              },
              email.category || 'other',
              toneProfile.profile_text,
              fullContext // Enhanced with context!
            );

            // Calculate enhanced quality score
            const qualityScore = await aiService.scoreDraft(
              draft.body,
              parsedEmail.body,
              email.category || 'other'
            );

            // Save draft
            const draftId = await draftModel.saveDraft({
              email_id: email.id,
              subject: draft.subject,
              body: draft.body,
              category: email.category || 'other',
              confidence_score: draft.confidence,
              quality_score: qualityScore
            });

            generatedDrafts.push({
              draftId,
              emailSubject: parsedEmail.subject,
              from: parsedEmail.from,
              contextUsed: fullContext.length > 0,
              confidence: draft.confidence,
              qualityScore
            });

          } catch (error) {
            console.error(`‚ùå Error generating draft for email ${email.id}:`, error);
          }
        }

        res.json({
          message: 'Context-aware drafts generated successfully',
          draftsGenerated: generatedDrafts.length,
          totalEmailsProcessed: emails.length,
          drafts: generatedDrafts
        });

      } catch (error) {
        console.error('‚ùå Error generating context-aware drafts:', error);
        res.status(500).json({ error: 'Failed to generate context-aware drafts' });
      }
    });

// Webhook management endpoints
app.get('/webhook-status', async (_req, res) => {
  try {
    const status = await webhookRenewalService.getWebhookStatus();
    res.json({
      webhooks: status,
      totalActive: status.filter(w => w.webhookActive).length,
      needingRenewal: status.filter(w => w.needsRenewal).length
    });
  } catch (error) {
    console.error('‚ùå Error getting webhook status:', error);
    res.status(500).json({ error: 'Failed to get webhook status' });
  }
});

app.post('/webhook-renewal/manual', async (_req, res) => {
  try {
    await webhookRenewalService.manualRenewalCheck();
    res.json({ message: 'Manual webhook renewal check completed' });
  } catch (error) {
    console.error('‚ùå Error in manual webhook renewal:', error);
    res.status(500).json({ error: 'Failed to perform manual webhook renewal' });
  }
});

// üß™ Webhook Testing Endpoints
app.post('/test/webhook-suite', async (_req, res) => {
  try {
    console.log('üß™ Running comprehensive webhook testing suite...');
    const startTime = Date.now();
    
    const testResults = await webhookTestingSuite.runAllTests();
    const duration = Date.now() - startTime;
    
    const passed = testResults.filter((r: any) => r.status === 'PASS').length;
    const failed = testResults.filter((r: any) => r.status === 'FAIL').length;
    const successRate = ((passed / (passed + failed)) * 100).toFixed(1);
    
    res.json({
      message: 'Comprehensive webhook testing completed',
      summary: {
        totalTests: testResults.length,
        passed,
        failed,
        successRate: `${successRate}%`,
        totalDuration: duration,
        status: failed === 0 ? 'ALL_PASS' : failed <= 2 ? 'MINOR_ISSUES' : 'CRITICAL_ISSUES'
      },
      results: testResults,
      recommendation: failed === 0 
        ? 'System ready for production use' 
        : failed <= 2 
          ? 'Review failed tests before production' 
          : 'Fix critical issues before using system'
    });
  } catch (error) {
    console.error('‚ùå Error running webhook test suite:', error);
    res.status(500).json({ 
      error: 'Failed to run webhook test suite', 
      details: error instanceof Error ? error.message : 'Unknown error' 
    });
  }
});

app.get('/test/webhook-health', async (_req, res) => {
  try {
    const healthCheck = await webhookTestingSuite.quickHealthCheck();
    
    res.json({
      healthy: healthCheck.healthy,
      status: healthCheck.healthy ? 'HEALTHY' : 'UNHEALTHY',
      issues: healthCheck.issues,
      timestamp: new Date().toISOString(),
      recommendations: healthCheck.healthy 
        ? ['System operating normally']
        : healthCheck.issues.map((issue: any) => `Fix: ${issue}`)
    });
  } catch (error) {
    console.error('‚ùå Error in webhook health check:', error);
    res.status(500).json({ 
      healthy: false, 
      status: 'ERROR',
      issues: ['Health check system error'],
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Error handling middleware (must be last)
app.use(errorHandler);

// Graceful shutdown handling
process.on('SIGTERM', () => {
  logger.info('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  logger.info('SIGINT received, shutting down gracefully');  
  process.exit(0);
});

// Start server
initializeServices().then(() => {
      app.listen(port, () => {
        logger.info(`üåê Chief AI server running on http://localhost:${port}`, {
          environment: env.NODE_ENV,
          port,
          logLevel: env.LOG_LEVEL
        });
        logger.info('üîß Server ready and accepting connections');
        
        if (env.NODE_ENV === 'development') {
          console.log('\nüìã Available endpoints:');
          console.log('   GET  /health               - Health check');
          console.log('   GET  /health/ready         - Readiness probe');
          console.log('   GET  /auth                 - Start OAuth flow');
        console.log('   GET  /auth/callback        - OAuth callback');
        console.log('   GET  /emails/fetch         - Fetch emails from Gmail');
        console.log('   GET  /emails               - View stored emails');
        console.log('\nü§ñ Phase 2.1 - Real Email Analysis:');
        console.log('   POST /ai/analyze-tone-real - Analyze tone from real sent emails');
        console.log('   POST /ai/analyze-tone      - Analyze tone (mock fallback)');
        console.log('   GET  /tone-profiles        - View tone profile history');
        console.log('   GET  /tone-profiles/:id    - View specific tone profile');
        console.log('   POST /ai/refresh-tone      - Manually refresh tone analysis');
        console.log('   POST /ai/categorize-emails - Categorize emails');
        console.log('   POST /ai/generate-drafts   - Generate AI drafts');
        console.log('   GET  /drafts               - View generated drafts');
        console.log('   GET  /drafts/:id           - View specific draft');
        
        console.log('\nüöÄ Phase 1 - Real-time Auto-Generated Drafts:');
        console.log('   GET    /auto-drafts         - List auto-generated drafts with pagination');
        console.log('   GET    /auto-drafts/:id     - Get specific auto-generated draft');
        console.log('   PUT    /auto-drafts/:id     - Edit draft content (triggers learning)');
        console.log('   POST   /auto-drafts/:id/send     - Send draft as actual email');
        console.log('   DELETE /auto-drafts/:id     - Delete unwanted draft');
        console.log('   POST   /auto-drafts/:id/approve  - Approve draft without changes');
        
        console.log('\nüîî Webhook Management:');
        console.log('   GET    /webhook-status           - Check webhook status for all users');
        console.log('   POST   /webhook-renewal/manual   - Manually trigger webhook renewal check');
        
        console.log('\nüß™ Webhook Testing:');
        console.log('   POST   /test/webhook-suite       - Run comprehensive webhook test suite');
        console.log('   GET    /test/webhook-health      - Quick webhook health check');
        
        console.log('\nüí° Phase 2.1 workflow:');
        console.log('   1. Real tone analysis: POST /ai/analyze-tone-real');
        console.log('   2. View profiles: GET /tone-profiles');
        console.log('   3. Refresh tone: POST /ai/refresh-tone');
        console.log('   4. Categorize: POST /ai/categorize-emails');
        console.log('   5. Generate drafts: POST /ai/generate-drafts');
        console.log('   6. Review: GET /drafts');
        console.log('\nüß† Phase 2.2 - Deep Context Intelligence:');
        console.log('   POST /context/analyze-emails     - Run context analysis on emails');
        console.log('   GET  /context/stats              - Context intelligence statistics');
        console.log('   GET  /context/threads            - Thread analytics');
        console.log('   GET  /context/senders            - Sender relationship insights');
        console.log('   GET  /context/entities           - Entity extraction insights');
        console.log('   GET  /context/thread/:id         - Full thread context');
        console.log('   GET  /context/health             - Context system health');
        console.log('   POST /ai/generate-drafts-with-context - Context-aware draft generation');

        console.log('\nü§ñ Phase 2.3 - Smart Response Generation:');
        console.log('   POST /response/generate-smart    - Generate intelligent responses with context');
        console.log('   GET  /response/templates         - Get response templates by context');
        console.log('   GET  /response/stats             - Response generation statistics');
        console.log('   GET  /response/recent            - Recent generated responses');
        console.log('   POST /response/feedback          - Record user feedback on responses');

        console.log('\nüéì Phase 2.4 - Learning & Feedback System:');
        console.log('   POST /learning/analyze-edit      - Analyze user edits for learning');
        console.log('   GET  /learning/success-metrics   - Calculate success rates and trends');
        console.log('   GET  /learning/insights          - Generate learning insights from patterns');
        console.log('   GET  /learning/performance-trend - Weekly performance trend analysis');
        console.log('   POST /learning/weekly-analysis   - Comprehensive weekly performance report');

        console.log('\nüìÖ Phase 3.1 - Calendar Intelligence:');
        console.log('   POST /calendar/set-tokens        - Set OAuth tokens for Calendar API');
        console.log('   GET  /calendar/events            - Get calendar events for date range');  
        console.log('   POST /calendar/check-availability - Just-in-time availability checking');
        console.log('   POST /calendar/suggest-times     - Smart time slot suggestions');
        console.log('   POST /calendar/create-event      - Create calendar events');
        console.log('   GET  /calendar/preferences       - Get user calendar preferences');
        console.log('   POST /calendar/preferences       - Update calendar preferences');
        console.log('   GET  /calendar/stats             - Calendar analytics and statistics');
        console.log('   GET  /calendar/health            - Calendar system health check');

        console.log('\nü§ñ Phase 3.2 - Meeting Request Detection:');
        console.log('   POST /meetings/detect            - Detect meeting request in specific email');
        console.log('   POST /meetings/scan-emails       - Scan recent emails for meeting requests');
        console.log('   GET  /meetings/requests          - Get all meeting requests');
        console.log('   PATCH /meetings/requests/:id     - Update meeting request status');
        console.log('   GET  /meetings/health            - Meeting detection system health check');

        console.log('\nüîÑ Phase 3.3 - Auto-Scheduling System:');
        console.log('   POST /auto-scheduling/process-meeting  - Process meeting request for auto-scheduling');
        console.log('   POST /auto-scheduling/suggest-times    - Generate time slot suggestions');
        console.log('   POST /auto-scheduling/create-hold      - Create calendar hold for time slot');
        console.log('   POST /auto-scheduling/confirm          - Confirm scheduling and create calendar event');
        console.log('   GET  /auto-scheduling/workflows       - Get scheduling workflows');
        console.log('   GET  /auto-scheduling/holds           - Get calendar holds');
        console.log('   POST /auto-scheduling/cleanup-holds   - Cleanup expired calendar holds');
        console.log('   GET  /auto-scheduling/health          - Auto-scheduling system health check');


        // üì° Gmail Webhook Endpoints
    
    // Webhook heartbeat tracking (for status monitoring)
    let webhookHeartbeat = {
      lastReceived: null as Date | null,
      totalReceived: 0,
      lastProcessed: null as Date | null,
      totalProcessed: 0
    };

    // Webhook endpoint to receive Gmail push notifications
    app.post('/webhooks/gmail', async (req, res) => {
      try {
        // Update heartbeat tracking
        webhookHeartbeat.lastReceived = new Date();
        webhookHeartbeat.totalReceived++;
        
        console.log('üìß Received Gmail webhook notification');
        console.log('Headers:', JSON.stringify(req.headers, null, 2));
        console.log('Body:', JSON.stringify(req.body, null, 2));

        // Acknowledge receipt immediately (Google requires < 10 second response)
        res.status(200).send('OK');

        // Decode the Pub/Sub message
        if (req.body.message && req.body.message.data) {
          const messageData = Buffer.from(req.body.message.data, 'base64').toString();
          console.log('üì® Decoded message:', messageData);
          
          try {
            const notification = JSON.parse(messageData);
            console.log('üéØ Gmail notification:', notification);

            // Process the notification asynchronously FOR ALL ACTIVE USERS
            processGmailNotificationMultiUser(notification).then(() => {
              // Update processing heartbeat
              webhookHeartbeat.lastProcessed = new Date();
              webhookHeartbeat.totalProcessed++;
            }).catch(error => {
              console.error('‚ùå Error processing Gmail notification:', error);
            });
          } catch (parseError) {
            console.error('‚ùå Error parsing Gmail webhook message:', parseError);
            console.log('üì® Invalid message data:', messageData);
          }
        }

      } catch (error) {
        console.error('‚ùå Error handling Gmail webhook:', error);
        // Response already sent on line 2704, don't send again
      }
    });

    // üß™ Test endpoint to manually trigger webhook processing (for testing)
    app.post('/test-webhook', async (_req, res) => {
      try {
        console.log('üß™ Manual webhook test triggered...');
        
        // Simulate a Gmail webhook notification (general notification, not specific email)
        const testNotification = {
          historyId: Date.now().toString(),
          messageId: null // This will trigger the "check recent emails" flow
        };
        
        // Process the simulated notification for all users
        await processGmailNotificationMultiUser(testNotification);
        
        res.json({
          message: 'Test webhook processing completed',
          notification: testNotification,
          timestamp: new Date()
        });
      } catch (error) {
        console.error('‚ùå Error in test webhook:', error);
        res.status(500).json({ error: 'Test webhook processing failed' });
      }
    });

    // üéØ Test endpoint to specifically test smart filtering logic
    app.post('/test-smart-filtering', authMiddleware.authenticate, async (req, res) => {
      try {
        const userId = getUserId(req);
        console.log('üéØ Testing smart filtering with provided email data...');
        
        const { from, subject, body } = req.body;
        if (!from || !subject || !body) {
          return res.status(400).json({ error: 'Missing required fields: from, subject, body' });
        }
        
        // Create mock email data to test filtering
        const mockEmail = {
          from: from,
          subject: subject,
          body: body
        };
        
        console.log('üìß Testing email:', mockEmail);
        
        // Test the smart filtering logic
        const filterResult = await shouldGenerateResponseForEmail(mockEmail, userId);
        
        console.log(`ü§ñ Filter Result: ${filterResult.generate ? '‚úÖ PROCESS' : '‚ùå SKIP'} - ${filterResult.reason}`);
        
        res.json({
          message: 'Smart filtering test completed',
          email: mockEmail,
          filterResult: filterResult,
          timestamp: new Date()
        });
        
      } catch (error) {
        console.error('‚ùå Error in smart filtering test:', error);
        res.status(500).json({ error: 'Smart filtering test failed' });
      }
    });

    // üîç Database verification endpoint for testing draft management
    app.get('/debug/draft-database/:id', async (req, res) => {
      try {
        const draftId = parseInt(req.params.id);
        console.log(`üîç Database check for draft ID: ${draftId}`);
        
        // Query the database directly to see raw data
        const query = 'SELECT * FROM auto_generated_drafts WHERE id = $1';
        const result = await pool.query(query, [draftId]);
        
        if (result.rows.length === 0) {
          return res.status(404).json({ error: 'Draft not found in database' });
        }
        
        const draftData = result.rows[0];
        console.log('üìä Raw database data:', draftData);
        
        res.json({
          message: 'Database verification completed',
          rawDatabaseData: draftData,
          timestamp: new Date()
        });
        
      } catch (error) {
        console.error('‚ùå Error in database verification:', error);
        res.status(500).json({ error: 'Database verification failed' });
      }
    });

    // üöÄ PHASE 3: Intelligent Router Test Endpoint
    app.post('/test-intelligent-router', authMiddleware.authenticate, async (req, res) => {
      try {
        const userId = getUserId(req);
        const { testEmails } = req.body;
        
        console.log(`üß™ [ROUTER TEST] Testing intelligent router with ${testEmails?.length || 'default'} emails...`);
        
        // Default test emails if none provided
        const defaultTestEmails = [
          {
            id: 'test-meeting-1',
            from: 'colleague@work.com',
            to: 'user@company.com',
            subject: 'Coffee tomorrow?',
            body: 'Hey! Are you free for coffee tomorrow at 2 PM? Would love to catch up on the project.',
            date: new Date().toISOString(),
            threadId: 'test-thread-1',
            snippet: 'Coffee tomorrow at 2 PM'
          },
          {
            id: 'test-meeting-2',
            from: 'client@company.com',
            to: 'user@company.com',
            subject: 'Meeting request for next week',
            body: 'Hi, could we schedule a meeting to discuss the quarterly results? I\'m available next week.',
            date: new Date().toISOString(),
            threadId: 'test-thread-2',
            snippet: 'Meeting request for next week'
          },
          {
            id: 'test-regular-1',
            from: 'teammate@company.com',
            to: 'user@company.com',
            subject: 'Project update',
            body: 'Here\'s the latest update on the project. Please review the attached documents.',
            date: new Date().toISOString(),
            threadId: 'test-thread-3',
            snippet: 'Project update with documents'
          },
          {
            id: 'test-newsletter-1',
            from: 'newsletter@marketing.com',
            to: 'user@company.com',
            subject: 'Weekly Newsletter - Tech Updates',
            body: 'This week in tech: AI advances, new frameworks, and industry news.',
            date: new Date().toISOString(),
            threadId: 'test-thread-4',
            snippet: 'Weekly tech newsletter'
          }
        ];
        
        const emailsToTest = testEmails || defaultTestEmails;
        
        // Test routing for each email
        const routingResults = [];
        for (const email of emailsToTest) {
          console.log(`üß† [ROUTER TEST] Testing email: "${email.subject}"`);
          
          const routingResult = await intelligentEmailRouter.routeEmail(email, userId, undefined, true); // Test mode
          routingResults.push(routingResult);
          
          console.log(`‚úÖ [ROUTER TEST] Result: ${routingResult.routingDecision.route.toUpperCase()} (${routingResult.routingDecision.confidence}%)`);
        }
        
        // Generate statistics
        const stats = intelligentEmailRouter.getRoutingStats(routingResults);
        
        console.log(`üìä [ROUTER TEST] Stats:`, stats);
        
        res.json({
          message: 'Intelligent router test completed',
          testResults: routingResults,
          statistics: stats,
          summary: {
            totalEmails: routingResults.length,
            meetingRouted: stats.routing.meeting,
            autoDraftRouted: stats.routing.autoDraft,
            skipped: stats.routing.skipped,
            avgProcessingTime: stats.performance.avgProcessingTime,
            avgConfidence: stats.performance.avgConfidence,
            successRate: stats.performance.successRate
          }
        });
        
      } catch (error) {
        console.error('‚ùå Intelligent router test failed:', error);
        res.status(500).json({ 
          error: 'Intelligent router test failed',
          details: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // üöÄ PHASE 3: Intelligent Router Health Check Endpoint
    app.get('/health/intelligent-router', async (_req, res) => {
      try {
        console.log('üè• [ROUTER HEALTH] Running intelligent router health check...');
        
        const healthCheck = await intelligentEmailRouter.healthCheck();
        
        const statusCode = healthCheck.status === 'healthy' ? 200 : 
                          healthCheck.status === 'degraded' ? 206 : 503;
        
        console.log(`üè• [ROUTER HEALTH] Status: ${healthCheck.status}`, healthCheck);
        
        res.status(statusCode).json({
          service: 'intelligent-email-router',
          status: healthCheck.status,
          timestamp: new Date().toISOString(),
          components: {
            openAIClassifier: healthCheck.openAIClassifier,
            meetingPipeline: healthCheck.meetingPipeline,
            responseService: healthCheck.responseService,
            autoDraftModel: healthCheck.autoDraftModel
          },
          overallHealth: healthCheck.overallHealth
        });
        
      } catch (error) {
        console.error('‚ùå Intelligent router health check failed:', error);
        res.status(503).json({ 
          service: 'intelligent-email-router',
          status: 'error',
          timestamp: new Date().toISOString(),
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // üß™ Test endpoint to manually create a draft for testing draft management
    app.post('/test-create-draft', async (_req, res) => {
      try {
        console.log('üß™ Manually creating test draft for draft management testing...');
        
        const testDraftData = {
          draft_id: `test_draft_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`,
          original_email_id: 66, // Real email ID from database
          subject: 'Re: Test Email for Draft Management',
          body: 'This is a test draft created to verify the draft management API suite is working correctly. Please feel free to edit, approve, or manage this draft.',
          tone: 'professional',
          urgency_level: 'medium',
          context_used: {
            sources: ['test_context'],
            confidence: 0.95
          },
          relationship_type: 'test',
          processing_time_ms: 1000
        };
        
        const draftId = await autoGeneratedDraftModel.createDraft(testDraftData);
        
        console.log(`‚úÖ Test draft created with ID: ${draftId}`);
        
        res.json({
          message: 'Test draft created successfully',
          draftId: draftId,
          draftData: testDraftData,
          timestamp: new Date(),
          nextSteps: [
            `GET /auto-drafts/${draftId} - View the draft`,
            `PUT /auto-drafts/${draftId} - Edit the draft`,
            `POST /auto-drafts/${draftId}/approve - Approve the draft`,
            `GET /debug/draft-database/${draftId} - Check database state`
          ]
        });
        
      } catch (error) {
        console.error('‚ùå Error creating test draft:', error);
        res.status(500).json({ error: 'Failed to create test draft' });
      }
    });

    // üöÄ MULTI-USER WEBHOOK PROCESSING - Processes emails for the specific user in notification
    async function processGmailNotificationMultiUser(notification: any) {
      try {
        console.log('üåç Processing Gmail notification for target user...');
        
        // Extract target email from notification
        const targetEmail = notification.emailAddress;
        if (!targetEmail) {
          console.log('‚ö†Ô∏è No emailAddress found in notification. Processing for all active users as fallback.');
          
          // Fallback: Get all users with active webhooks
          const activeUsers = await tokenStorageService.getActiveWebhookUsers();
          console.log(`üë• Found ${activeUsers.length} active users with webhook subscriptions`);
          
          if (activeUsers.length === 0) {
            console.log('‚ö†Ô∏è No active webhook users found. Skipping processing.');
            return;
          }
          
          // Process notification for each active user
          const processingPromises = activeUsers.map(async (userTokens) => {
            try {
              console.log(`üîÑ Processing notification for user: ${userTokens.gmailAddress} (${userTokens.userId.substring(0, 8)}...)`);
              
              // Initialize Gmail service for this specific user
              await gmailService.initializeForUser(userTokens.userId);
              
              // Process the notification for this user
              await processGmailNotificationForUser(notification, userTokens.userId);
              
              console.log(`‚úÖ Completed processing for user: ${userTokens.gmailAddress}`);
            } catch (userError) {
              console.error(`‚ùå Error processing notification for user ${userTokens.gmailAddress}:`, userError);
              
              // If the error is auth-related, disable webhook for this user
              const errorMessage = userError instanceof Error ? userError.message : String(userError);
              if (errorMessage?.includes('invalid_grant') || errorMessage?.includes('unauthorized')) {
                console.log(`‚ö†Ô∏è Disabling webhook for user ${userTokens.gmailAddress} due to auth issues`);
                await tokenStorageService.disableWebhookForUser(userTokens.userId, 'Authentication failed during webhook processing');
              }
            }
          });
          
          // Wait for all user processing to complete
          await Promise.allSettled(processingPromises);
          return;
        }
        
        console.log(`üéØ Processing notification for specific user: ${targetEmail}`);
        
        // Find the specific user ID for this notification
        const targetUserId = await tokenStorageService.getUserIdByEmail(targetEmail);
        if (!targetUserId) {
          console.log(`‚ö†Ô∏è Target user ${targetEmail} not found. Skipping processing.`);
          return;
        }
        
        // Get the user's tokens to check if webhook is active
        const targetUserTokens = await tokenStorageService.getUserTokens(targetUserId);
        if (!targetUserTokens || !targetUserTokens.webhookActive) {
          console.log(`‚ö†Ô∏è Target user ${targetEmail} webhook not active. Skipping processing.`);
          return;
        }
        
        console.log(`üë§ Found target user: ${targetUserTokens.gmailAddress} (${targetUserId.substring(0, 8)}...)`);
        
        // Process notification for the specific user only
        const processingPromises = [targetUserTokens].map(async (userTokens) => {
          try {
            console.log(`üîÑ Processing notification for user: ${userTokens.gmailAddress} (${userTokens.userId.substring(0, 8)}...)`);
            
            // Initialize Gmail service for this specific user
            await gmailService.initializeForUser(userTokens.userId);
            
            // Process the notification for this user
            await processGmailNotificationForUser(notification, userTokens.userId);
            
            console.log(`‚úÖ Completed processing for user: ${userTokens.gmailAddress}`);
          } catch (userError) {
            console.error(`‚ùå Error processing notification for user ${userTokens.gmailAddress}:`, userError);
            
            // If the error is auth-related, disable webhook for this user
            const errorMessage = userError instanceof Error ? userError.message : String(userError);
            if (errorMessage?.includes('invalid_grant') || errorMessage?.includes('unauthorized')) {
              console.log(`‚ö†Ô∏è Disabling webhook for user ${userTokens.gmailAddress} due to auth issues`);
              await tokenStorageService.disableWebhookForUser(userTokens.userId, 'Authentication failed during webhook processing');
            }
          }
        });
        
        // Wait for all user processing to complete
        await Promise.allSettled(processingPromises);
        
        console.log('üéâ Multi-user webhook processing completed for all active users');
        
      } catch (error) {
        console.error('‚ùå Critical error in multi-user webhook processing:', error);
      }
    }
    
    // üöÄ ENHANCED FUNCTION TO PROCESS GMAIL NOTIFICATIONS FOR A SPECIFIC USER
    async function processGmailNotificationForUser(notification: any, userId: string) {
      const startTime = Date.now();
      try {
        console.log('üöÄ Real-time email processing initiated...');
        console.log('üîÑ Processing Gmail notification for auto-draft generation...');
        
        const historyId = notification.historyId;
        console.log(`üìä History ID: ${historyId}`);

        let emailsToProcess: any[] = [];

        // Step 1: Extract email data based on notification type
        if (notification.messageId) {
          console.log(`üì© Specific email received: ${notification.messageId}`);
          
          // Fetch the specific email
          const email = await gmailService.getEmailByMessageId(notification.messageId);
          if (email) {
            // Check if this specific email has been processed by webhook FOR THIS USER
            const existingEmail = await emailModel.getEmailByGmailId(email.id, userId);
            if (!existingEmail || !existingEmail.webhook_processed) {
              emailsToProcess = [email];
              const parsedEmail = gmailService.parseEmail(email);
              console.log(`üìß Specific email "${parsedEmail.subject}" added to processing queue for user (webhook_processed: ${existingEmail?.webhook_processed || 'new email'})`);
            } else {
              const parsedEmail = gmailService.parseEmail(email);
              console.log(`‚è≠Ô∏è Specific email "${parsedEmail.subject}" already processed by webhook for this user, skipping`);
              emailsToProcess = [];
            }
          }
        } else {
          console.log('üìß General notification - checking for new emails...');
          
          // Get recent emails and filter for new ones
          const recentEmails = await gmailService.getRecentEmails(5);
          
          for (const email of recentEmails) {
            // Check if we've already processed this email via webhook FOR THIS USER
            const existingEmail = await emailModel.getEmailByGmailId(email.id, userId);
            if (!existingEmail || !existingEmail.webhook_processed) {
              emailsToProcess.push(email);
              const parsedEmail = gmailService.parseEmail(email);
              console.log(`üìß Email "${parsedEmail.subject}" added to processing queue for user (webhook_processed: ${existingEmail?.webhook_processed || 'new email'})`);
            } else {
              const parsedEmail = gmailService.parseEmail(email);
              console.log(`‚è≠Ô∏è Email "${parsedEmail.subject}" already processed by webhook for this user, skipping`);
            }
          }
        }

        console.log(`üì¨ Found ${emailsToProcess.length} new emails to process`);

        // NEW: Extract email processing into separate function for parallel processing
        async function processEmailSafe(emailData: any): Promise<{
          status: 'success' | 'skipped' | 'duplicate' | 'error';
          emailId: string;
          reason?: string;
          processingTime?: number;
        }> {
          const processingStartTime = Date.now();

          try {
            // Parse email content
            const parsedEmail = gmailService.parseEmail(emailData);
            console.log(`üìß [PARALLEL] Processing: "${parsedEmail.subject}" from ${parsedEmail.from}`);

            // Step 3: Smart email filtering
            const shouldGenerateResponse = await shouldGenerateResponseForEmail(parsedEmail, userId);
            if (!shouldGenerateResponse.generate) {
              console.log(`‚è≠Ô∏è [PARALLEL] Skipping email: ${shouldGenerateResponse.reason}`);

              // Atomically save email and mark as webhook processed FOR THIS USER (even though no draft was generated)
              const result = await emailModel.saveEmailAndMarkAsWebhookProcessedForUser(parsedEmail, userId);
              if (result.success) {
                console.log(`üè∑Ô∏è [PARALLEL] Email ID ${result.emailId} marked as webhook_processed = true for user (filtered out)`);
              } else {
                console.log(`‚è≠Ô∏è [PARALLEL] Email already processed by webhook for this user, skipping (filtered out)`);
              }
              return {
                status: 'skipped',
                emailId: parsedEmail.id,
                reason: shouldGenerateResponse.reason,
                processingTime: Date.now() - processingStartTime
              };
            }

            console.log(`‚úÖ [PARALLEL] Email qualifies for response generation: ${shouldGenerateResponse.reason}`);

            // Step 4: Atomically save email and mark as webhook processed FOR THIS USER
            const result = await emailModel.saveEmailAndMarkAsWebhookProcessedForUser(parsedEmail, userId);
            if (!result.success) {
              console.log(`‚è≠Ô∏è [PARALLEL] Email already processed by webhook for this user, skipping draft generation`);
              return {
                status: 'duplicate',
                emailId: parsedEmail.id,
                processingTime: Date.now() - processingStartTime
              };
            }

            const emailId = result.emailId!;

            // üöÄ PHASE 3: Process email through intelligent router (replaces dual processing)
            console.log(`üß† [PARALLEL] Routing email ${parsedEmail.id} through intelligent router...`);
            const routingResult = await intelligentEmailRouter.routeEmail(
              parsedEmail,
              userId,
              emailId // Use the email DB ID we already have
            );

            console.log(`‚úÖ [PARALLEL] Email routed to ${routingResult.routingDecision.route.toUpperCase()} pipeline`);
            console.log(`üéØ [PARALLEL] Routing reasoning: ${routingResult.routingDecision.reasoning}`);

            if (routingResult.meetingResult?.isMeetingRequest) {
              console.log(`üìÖ [PARALLEL] Meeting detected! Type: ${routingResult.meetingResult.meetingRequest?.meetingType}, Confidence: ${routingResult.meetingResult.confidence}%`);
              if (routingResult.meetingResult.response) {
                console.log(`ü§ñ [PARALLEL] Meeting response generated: ${routingResult.meetingResult.response.actionTaken}`);
              }
            } else if (routingResult.autoDraftResult) {
              console.log(`üìù [PARALLEL] Auto-draft generated: "${routingResult.autoDraftResult.subject}"`);
              console.log(`üéØ [PARALLEL] Tone: ${routingResult.autoDraftResult.tone}, Urgency: ${routingResult.autoDraftResult.urgencyLevel}`);
            } else if (routingResult.routingDecision.route === 'skip') {
              console.log(`‚è≠Ô∏è [PARALLEL] Email skipped: ${routingResult.routingDecision.reasoning}`);
            }

            const totalProcessingTime = Date.now() - processingStartTime;
            console.log(`‚ö° [PARALLEL] Email processing time: ${totalProcessingTime}ms`);

            // Email is already marked as webhook_processed by the atomic operation above
            console.log(`üè∑Ô∏è [PARALLEL] Email ID ${emailId} already marked as webhook_processed = true`);

            return {
              status: 'success',
              emailId: parsedEmail.id,
              processingTime: totalProcessingTime
            };

          } catch (emailError) {
            console.error(`‚ùå [PARALLEL] Error processing email:`, emailError);
            return {
              status: 'error',
              emailId: emailData.id || 'unknown',
              reason: emailError instanceof Error ? emailError.message : 'Unknown error',
              processingTime: Date.now() - processingStartTime
            };
          }
        }

        // Step 2: Process emails in parallel with concurrency limit (SAFE PARALLEL PROCESSING)
        if (emailsToProcess.length > 0) {
          const CONCURRENCY_LIMIT = 3; // Limit concurrent API calls to avoid rate limits
          console.log(`üîÑ [PARALLEL] Processing ${emailsToProcess.length} emails with concurrency limit: ${CONCURRENCY_LIMIT}`);

          const processWithConcurrencyLimit = async (): Promise<Array<{
            status: 'success' | 'skipped' | 'duplicate' | 'error';
            emailId: string;
            reason?: string;
            processingTime?: number;
          }>> => {
            const results: Array<{
              status: 'success' | 'skipped' | 'duplicate' | 'error';
              emailId: string;
              reason?: string;
              processingTime?: number;
            }> = [];

            for (let i = 0; i < emailsToProcess.length; i += CONCURRENCY_LIMIT) {
              const batch = emailsToProcess.slice(i, i + CONCURRENCY_LIMIT);
              const batchNumber = Math.floor(i / CONCURRENCY_LIMIT) + 1;
              console.log(`üîÑ [PARALLEL] Processing batch ${batchNumber}: ${batch.length} emails`);

              // Process batch in parallel using Promise.allSettled for safe error handling
              const batchPromises = batch.map(emailData => processEmailSafe(emailData));
              const batchResults = await Promise.allSettled(batchPromises);

              // Extract results and log any failures
              batchResults.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                  results.push(result.value);
                } else {
                  console.error(`‚ùå [PARALLEL] Batch ${batchNumber} email ${index + 1} failed:`, result.reason);
                  results.push({
                    status: 'error',
                    emailId: batch[index]?.id || 'unknown',
                    reason: result.reason?.message || 'Unknown error'
                  });
                }
              });

              // Small delay between batches to be gentle on APIs
              if (i + CONCURRENCY_LIMIT < emailsToProcess.length) {
                await new Promise(resolve => setTimeout(resolve, 100));
              }
            }

            return results;
          };

          const processingResults = await processWithConcurrencyLimit();

          // Log processing summary
          const successful = processingResults.filter(r => r.status === 'success').length;
          const skipped = processingResults.filter(r => r.status === 'skipped').length;
          const duplicates = processingResults.filter(r => r.status === 'duplicate').length;
          const errors = processingResults.filter(r => r.status === 'error').length;

          console.log(`üìä [PARALLEL] Processing Summary:`);
          console.log(`   ‚úÖ Successful: ${successful}`);
          console.log(`   ‚è≠Ô∏è Skipped: ${skipped}`);
          console.log(`   üîÑ Duplicates: ${duplicates}`);
          console.log(`   ‚ùå Errors: ${errors}`);

          if (successful > 0 || skipped > 0) {
            console.log(`üéâ [PARALLEL] Successfully processed ${successful + skipped} emails!`);
          }
        } else {
          console.log(`üì≠ [PARALLEL] No emails to process`);
        }

        const totalTime = Date.now() - startTime;
        console.log(`üéâ Gmail notification processing COMPLETE! Total time: ${totalTime}ms`);
        
      } catch (error) {
        console.error('‚ùå Error in processGmailNotification:', error);
        
        // Graceful degradation - store for manual processing
        await _storeFailedNotification(notification, error);
      }
    }

    // Smart Email Filtering Function (Phase 2 from roadmap)
    async function shouldGenerateResponseForEmail(email: any, userId: string): Promise<{generate: boolean, reason: string, classification?: string}> {
      const fromEmail = email.from.toLowerCase();
      const subject = email.subject;
      const body = email.body;

      console.log(`üîç Smart filtering email: "${subject}" from ${fromEmail}`);

      // üõ°Ô∏è INFINITE LOOP PREVENTION - TEMPORARILY DISABLED FOR TESTING
      // TODO: Re-enable with smarter logic that doesn't block user's own email
      /*
      const aiSenderPatterns = [
        'parthahir012001@gmail.com',    // Main AI account
        'chief-ai@', 'ai-assistant@', 'auto-reply@', 'automated@', 'bot@',
        '@mailchimp.com', '@sendgrid.net', '@amazonses.com', 
        '@notifications.', '@alerts.', '@updates.', '@marketing.',
        '@calendar-notification', '@calendly.', '@zoom.us', '@teams.microsoft.com',
        '@facebookmail.com', '@linkedin.com', '@twitter.com', '@instagram.com',
        'mail-noreply@google.com'
      ];

      const aiSubjectPatterns = [
        '[AUTO-GENERATED]', '[AI RESPONSE]', '[AUTOMATED REPLY]', 
        'Auto-Reply:', 'Out of Office:', 'Vacation Response:', 'Automatic Reply:'
      ];

      const aiBodyPatterns = [
        'This email was automatically generated', 'Auto-generated by Chief AI',
        'Automated response from', 'This is an automated message',
        'Do not reply to this email', 'Generated by AI Assistant',
        'Powered by Chief AI', 'This email was sent automatically'
      ];

      // Check sender patterns
      for (const pattern of aiSenderPatterns) {
        if (fromEmail.includes(pattern.toLowerCase())) {
          console.log(`üõë [INFINITE LOOP PREVENTION] Blocked AI sender: ${pattern}`);
          return { generate: false, reason: `Infinite loop prevention: AI sender pattern "${pattern}" detected` };
        }
      }

      // Check subject patterns
      for (const pattern of aiSubjectPatterns) {
        if (subject.toLowerCase().includes(pattern.toLowerCase())) {
          console.log(`üõë [INFINITE LOOP PREVENTION] Blocked AI subject: ${pattern}`);
          return { generate: false, reason: `Infinite loop prevention: AI subject pattern "${pattern}" detected` };
        }
      }

      // Check body patterns
      for (const pattern of aiBodyPatterns) {
        if (body.toLowerCase().includes(pattern.toLowerCase())) {
          console.log(`üõë [INFINITE LOOP PREVENTION] Blocked AI body content: ${pattern}`);
          return { generate: false, reason: `Infinite loop prevention: AI body pattern "${pattern}" detected` };
        }
      }
      */

      console.log(`‚úÖ [LOOP PREVENTION DISABLED] Proceeding with email processing: "${subject}" from ${fromEmail}`);

      // Skip no-reply addresses (fast check)
      const noReplyPatterns = ['no-reply', 'noreply', 'do-not-reply', 'donotreply'];
      if (noReplyPatterns.some(pattern => fromEmail.includes(pattern))) {
        return { generate: false, reason: 'No-reply email address' };
      }

      // Skip obvious auto-generated emails (fast check)
      const autoGenerated = ['automated', 'auto-generated', 'system generated', 'bounce', 'delivery failure'];
      if (autoGenerated.some(keyword => subject.toLowerCase().includes(keyword)) ||
          autoGenerated.some(keyword => body.toLowerCase().includes(keyword.toLowerCase()))) {
        return { generate: false, reason: 'Auto-generated email detected' };
      }

      // Use AI classification for newsletter vs personal email detection
      try {
        const classification = await aiService.classifyEmail(subject, body, fromEmail);
        
        if (classification === 'newsletter') {
          // üÜï NEW: Save promotional email instead of just discarding
          try {
            await promotionalEmailModel.savePromotionalEmail({
              gmail_id: email.id,
              user_id: userId,
              thread_id: email.threadId,
              subject: email.subject,
              from_email: email.from,
              to_email: email.to,
              body: email.body,
              classification_reason: 'newsletter',
              received_at: email.date
            });
            console.log(`üì∞ Promotional email saved for user ${userId}: "${subject}"`);
          } catch (saveError) {
            console.error('‚ùå Error saving promotional email:', saveError);
            // Continue with filtering even if save fails
          }
          
          return { generate: false, reason: 'AI classified as newsletter/promotional content', classification: 'newsletter' };
        } else {
          return { generate: true, reason: 'AI classified as personal/business communication', classification: 'personal' };
        }
      } catch (error) {
        console.error('‚ùå AI classification failed, defaulting to generate:', error);
        return { generate: true, reason: 'AI classification failed - defaulting to process' };
      }
    }
    
    // Helper function to store processing results
    async function _storeProcessingResult(result: any) {
      try {
        // Store in database for dashboard display
        // This would be implemented based on your database schema
        console.log(`üíæ Storing processing result: ${result.type}`);
      } catch (error) {
        console.error('‚ùå Failed to store processing result:', error);
      }
    }
    
    // Helper function for failed notifications  
    async function _storeFailedNotification(_notification: any, _error: any) {
      try {
        console.log('üíæ Storing failed notification for manual review...');
        // Store failed notification for manual processing
      } catch (storeError) {
        console.error('‚ùå Failed to store failed notification:', storeError);
      }
    }

    // Set up Gmail watch for ALL active users (multi-user webhook setup)
    app.post('/gmail/setup-webhook-all-users', async (_req, res) => {
      try {
        console.log('üì° Setting up Gmail webhooks for ALL active users...');

        if (!gmailService) {
          return res.status(500).json({ error: 'Gmail service not initialized' });
        }

        // Get all active webhook users
        const activeUsers = await tokenStorageService.getActiveWebhookUsers();
        console.log(`üë• Found ${activeUsers.length} active users for webhook setup`);

        if (activeUsers.length === 0) {
          return res.status(400).json({ error: 'No active webhook users found' });
        }

        const results = [];
        
        // Set up webhook for each active user
        for (const userTokens of activeUsers) {
          try {
            console.log(`üì° Setting up webhook for user: ${userTokens.gmailAddress}`);
            
            // Initialize Gmail service for this user
            await gmailService.initializeForUser(userTokens.userId);
            
            // Set up webhook for this user
            const watchResponse = await gmailService.setupWebhook();
            
            results.push({
              user: userTokens.gmailAddress,
              success: true,
              watchResponse,
              expiration: new Date(parseInt(watchResponse.expiration)).toISOString()
            });
            
            console.log(`‚úÖ Webhook setup successful for ${userTokens.gmailAddress}`);
            
          } catch (userError) {
            console.error(`‚ùå Failed to setup webhook for ${userTokens.gmailAddress}:`, userError);
            results.push({
              user: userTokens.gmailAddress,
              success: false,
              error: userError instanceof Error ? userError.message : String(userError)
            });
          }
        }

        const successCount = results.filter(r => r.success).length;
        
        res.json({
          message: `Gmail webhooks setup completed for ${successCount}/${activeUsers.length} users`,
          results,
          totalUsers: activeUsers.length,
          successfulSetups: successCount
        });

      } catch (error) {
        console.error('‚ùå Error setting up Gmail webhooks for all users:', error);
        res.status(500).json({ error: 'Failed to setup Gmail webhooks for all users' });
      }
    });

    // Set up Gmail watch (subscribe to push notifications) - single user
    app.post('/gmail/setup-webhook', async (_req, res) => {
      try {
        console.log('üì° Setting up Gmail webhook...');

        if (!gmailService) {
          return res.status(500).json({ error: 'Gmail service not initialized' });
        }

        // Check if we have valid credentials
        try {
          await gmailService.checkCredentials();
        } catch (error) {
          return res.status(401).json({ 
            error: 'No valid Gmail credentials. Please complete OAuth flow first.',
            suggestion: 'Visit /auth to authenticate'
          });
        }

        const watchResponse = await gmailService.setupWebhook();
        
        res.json({
          message: 'Gmail webhook setup successfully',
          watchResponse: watchResponse,
          webhookUrl: watchResponse.webhookUrl, // Use the actual webhook URL from the response
          expiration: new Date(parseInt(watchResponse.expiration)).toISOString()
        });

      } catch (error) {
        console.error('‚ùå Error setting up Gmail webhook:', error);
        res.status(500).json({ error: 'Failed to setup Gmail webhook' });
      }
    });

    // Check webhook status
    app.get('/gmail/webhook-status', async (_req, res) => {
      try {
        console.log('üîç Checking Gmail webhook status...');

        const status = await gmailService.getWebhookStatus();
        
        res.json({
          message: 'Gmail webhook status retrieved',
          status: status
        });

      } catch (error) {
        console.error('‚ùå Error checking webhook status:', error);
        res.status(500).json({ error: 'Failed to check webhook status' });
      }
    });

    // Get webhook heartbeat status (for live monitoring)
    app.get('/webhooks/status', async (_req, res) => {
      try {
        const now = new Date();
        const lastReceived = webhookHeartbeat.lastReceived;
        const lastProcessed = webhookHeartbeat.lastProcessed;
        
        // Calculate time since last webhook
        const timeSinceLastWebhook = lastReceived ? now.getTime() - lastReceived.getTime() : null;
        const timeSinceLastProcessed = lastProcessed ? now.getTime() - lastProcessed.getTime() : null;
        
        // Determine health status
        let healthStatus = 'unknown';
        if (lastReceived) {
          if (timeSinceLastWebhook! < 300000) { // 5 minutes
            healthStatus = 'healthy';
          } else if (timeSinceLastWebhook! < 900000) { // 15 minutes
            healthStatus = 'warning';
          } else {
            healthStatus = 'unhealthy';
          }
        }
        
        res.json({
          message: 'Webhook heartbeat status retrieved',
          heartbeat: {
            health: healthStatus,
            lastReceived: lastReceived,
            lastProcessed: lastProcessed,
            totalReceived: webhookHeartbeat.totalReceived,
            totalProcessed: webhookHeartbeat.totalProcessed,
            timeSinceLastWebhook: timeSinceLastWebhook,
            timeSinceLastProcessed: timeSinceLastProcessed
          }
        });

      } catch (error) {
        console.error('‚ùå Error getting webhook heartbeat:', error);
        res.status(500).json({ error: 'Failed to get webhook heartbeat' });
      }
    });

    // Stop webhook (unsubscribe)
    app.post('/gmail/stop-webhook', async (_req, res) => {
      try {
        console.log('üõë Stopping Gmail webhook...');

        const result = await gmailService.stopWebhook();
        
        res.json({
          message: 'Gmail webhook stopped successfully',
          result: result
        });

      } catch (error) {
        console.error('‚ùå Error stopping webhook:', error);
        res.status(500).json({ error: 'Failed to stop webhook' });
      }
    });

    console.log('\nüîç System Monitoring:');
        console.log('   GET  /health/email-parsing  - Check parsing health');
        console.log('   POST /health/clear-failures - Clear failure log');
        console.log('   GET  /debug/email/:id       - Inspect specific email');

        console.log('\nüì° Gmail Webhooks (Real-time Email):');
        console.log('   POST /webhooks/gmail        - Receive Gmail push notifications');
        console.log('   POST /gmail/setup-webhook   - Set up Gmail push notifications');
        console.log('   GET  /gmail/webhook-status  - Check webhook subscription status');
        console.log('   POST /gmail/stop-webhook    - Stop Gmail push notifications');
        }
        
      });
    });
  }
}