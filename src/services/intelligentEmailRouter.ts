// PHASE 3: Intelligent Email Router Service
// Routes emails to optimal processing pipeline based on OpenAI classification

import { ParsedEmail } from '../types';
import { OpenAIMeetingClassifier, EmailClassification } from './openAIClassifier';
import { MeetingPipelineService, MeetingPipelineResult } from './meetingPipeline';
import { ResponseService } from './response';
import { AutoGeneratedDraftModel } from '../models/AutoGeneratedDraft';
import { logger, sanitizeUserId } from '../utils/pino-logger';

export interface RoutingDecision {
  route: 'meeting' | 'autodraft' | 'skip';
  confidence: number;
  reasoning: string;
  classification: EmailClassification;
  processingTime: number;
}

export interface RouterResult {
  emailId: string;
  userId: string;
  routingDecision: RoutingDecision;
  meetingResult?: MeetingPipelineResult;
  autoDraftResult?: {
    draftId: string;
    subject: string;
    body: string;
    tone: string;
    urgencyLevel: string;
  };
  status: 'success' | 'error';
  reason?: string;
  totalProcessingTime: number;
}

export class IntelligentEmailRouter {
  private openAIClassifier: OpenAIMeetingClassifier;
  private meetingPipeline: MeetingPipelineService;
  private responseService: ResponseService | null;
  private autoGeneratedDraftModel: AutoGeneratedDraftModel;

  constructor(responseService?: ResponseService) {
    this.openAIClassifier = new OpenAIMeetingClassifier();
    // Pass ResponseService to meeting pipeline for fallback draft generation
    this.meetingPipeline = new MeetingPipelineService(responseService);
    // Accept ResponseService as parameter to avoid circular dependencies
    this.responseService = responseService || null;
    this.autoGeneratedDraftModel = new AutoGeneratedDraftModel();
  }

  /**
   * Intelligently route email to optimal processing pipeline
   * This replaces the dual processing approach with smart routing
   */
  async routeEmail(
    email: ParsedEmail,
    userId: string,
    emailDbId?: number,
    testMode: boolean = false
  ): Promise<RouterResult> {
    const routingStartTime = Date.now();
    
    try {
      logger.debug({ userId: sanitizeUserId(userId), emailId: email.id, from: email.from, subject: email.subject }, 'router.email.processing');

      // Step 1: Get OpenAI classification (Phase 2)
      const classificationStartTime = Date.now();
      const classification = await this.openAIClassifier.classifyEmailType(email);
      const classificationTime = Date.now() - classificationStartTime;

      logger.info({ userId: sanitizeUserId(userId), isMeeting: classification.isMeeting, confidence: classification.confidence }, 'router.email.classified');
      

      // Step 2: Make routing decision
      const routingDecision = this.makeRoutingDecision(classification, classificationTime);
      logger.info({ userId: sanitizeUserId(userId), route: routingDecision.route, confidence: routingDecision.confidence }, 'router.decision.made');

      // Step 3: Route to appropriate pipeline
      const result: RouterResult = {
        emailId: email.id,
        userId,
        routingDecision,
        status: 'success',
        totalProcessingTime: 0 // Will be set at the end
      };

      if (routingDecision.route === 'meeting') {
        
        const meetingResult = await this.processThroughMeetingPipeline(email, userId, emailDbId, testMode);
        result.meetingResult = meetingResult;
        
        if (meetingResult.status === 'error') {
          result.status = 'error';
          result.reason = meetingResult.reason;
        }
        
      } else if (routingDecision.route === 'autodraft') {
        
        const autoDraftResult = await this.processThroughAutoDraftPipeline(email, userId, emailDbId);
        result.autoDraftResult = autoDraftResult || undefined;
        
        if (!autoDraftResult) {
          result.status = 'error';
          result.reason = 'Auto-draft generation failed';
        }
        
      } else {
        logger.debug({ userId: sanitizeUserId(userId), emailId: email.id, reason: result.reason }, 'router.email.skipped');
        result.reason = routingDecision.reasoning;
      }

      result.totalProcessingTime = Date.now() - routingStartTime;
      
      logger.info({ userId: sanitizeUserId(userId), emailId: email.id, duration: result.totalProcessingTime, route: result.routingDecision.route }, 'router.email.processed');
      return result;

    } catch (error) {
      logger.error({ userId: sanitizeUserId(userId), emailId: email.id, error: error instanceof Error ? error.message : String(error) }, 'router.email.failed');
      
      return {
        emailId: email.id,
        userId,
        routingDecision: {
          route: 'skip',
          confidence: 0,
          reasoning: 'Router error occurred',
          classification: {
            isMeeting: false,
            confidence: 0,
            reasoning: 'Error during classification',
            fallbackUsed: true
          },
          processingTime: 0
        },
        status: 'error',
        reason: error instanceof Error ? error.message : 'Unknown router error',
        totalProcessingTime: Date.now() - routingStartTime
      };
    }
  }

  /**
   * Make intelligent routing decision based on classification
   */
  private makeRoutingDecision(
    classification: EmailClassification,
    classificationTime: number
  ): RoutingDecision {
    
    // High confidence meeting requests go to meeting pipeline
    if (classification.isMeeting && classification.confidence >= 80) {
      return {
        route: 'meeting',
        confidence: classification.confidence,
        reasoning: `High confidence meeting request (${classification.confidence}%) - routing to meeting pipeline`,
        classification,
        processingTime: classificationTime
      };
    }
    
    // Medium confidence meeting requests go to meeting pipeline
    if (classification.isMeeting && classification.confidence >= 60) {
      return {
        route: 'meeting',
        confidence: classification.confidence,
        reasoning: `Medium confidence meeting request (${classification.confidence}%) - routing to meeting pipeline`,
        classification,
        processingTime: classificationTime
      };
    }
    
    // Low confidence meetings treated as regular emails (safer)
    if (classification.isMeeting && classification.confidence < 60) {
      return {
        route: 'autodraft',
        confidence: classification.confidence,
        reasoning: `Low confidence meeting (${classification.confidence}%) - routing to auto-draft for safer handling`,
        classification,
        processingTime: classificationTime
      };
    }
    
    // Non-meeting emails go to auto-draft pipeline
    if (!classification.isMeeting && classification.confidence >= 70) {
      return {
        route: 'autodraft',
        confidence: classification.confidence,
        reasoning: `Non-meeting email (${classification.confidence}% confidence) - routing to auto-draft pipeline`,
        classification,
        processingTime: classificationTime
      };
    }
    
    // Very low confidence emails are skipped for safety
    return {
      route: 'skip',
      confidence: classification.confidence,
      reasoning: `Very low confidence classification (${classification.confidence}%) - skipping for safety`,
      classification,
      processingTime: classificationTime
    };
  }

  /**
   * Process email through meeting pipeline
   */
  private async processThroughMeetingPipeline(
    email: ParsedEmail,
    userId: string,
    emailDbId?: number,
    testMode: boolean = false
  ): Promise<MeetingPipelineResult> {
    try {
      
      
      const meetingResult = await this.meetingPipeline.processEmailForMeetings(
        email,
        userId,
        emailDbId,
        testMode
      );
      
      
      if (meetingResult.isMeetingRequest) {
        
        
      }
      
      return meetingResult;
      
    } catch (error) {
      logger.error({ userId: sanitizeUserId(userId), emailId: email.id, error: error instanceof Error ? error.message : String(error) }, 'router.meeting.failed');
      return {
        emailId: email.id,
        userId,
        isMeetingRequest: false,
        confidence: 0,
        processingTime: 0,
        status: 'error',
        reason: error instanceof Error ? error.message : 'Meeting pipeline error'
      };
    }
  }

  /**
   * Process email through auto-draft pipeline
   */
  private async processThroughAutoDraftPipeline(
    email: ParsedEmail,
    userId: string,
    emailDbId?: number
  ): Promise<{ draftId: string; subject: string; body: string; tone: string; urgencyLevel: string } | null> {
    try {
      
      
      // Prepare request for response service
      const responseRequest = {
        emailId: emailDbId?.toString() || email.id,
        recipientEmail: email.from,
        originalSubject: email.subject,
        originalBody: email.body,
        responseType: 'reply' as const,
        userId: userId
      };
      
      // Generate smart response
      if (!this.responseService) {
        throw new Error('ResponseService not available - router not properly initialized');
      }
      const smartResponse = await this.responseService.generateSmartResponse(responseRequest);
      
      // Create auto-generated draft
      const draftId = `autodraft_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
      
      const autoDraftData = {
        draft_id: draftId,
        original_email_id: emailDbId || 0, // Use emailDbId if available
        subject: smartResponse.subject,
        body: smartResponse.body,
        tone: smartResponse.tone,
        urgency_level: smartResponse.urgencyLevel,
        context_used: {
          source: 'intelligent_router',
          route: 'autodraft',
          originalEmail: {
            subject: email.subject,
            from: email.from,
            threadId: email.threadId,
            gmailId: email.id
          },
          responseGeneration: {
            tone: smartResponse.tone,
            urgency: smartResponse.urgencyLevel,
            reasoning: 'Auto-draft generated via intelligent routing'
          }
        },
        relationship_type: 'auto_response',
        status: 'pending',
        user_id: userId // FIX: Add missing user_id
      };
      
      const autoDraftId = await this.autoGeneratedDraftModel.createDraftForUser(autoDraftData);
      
      logger.info({ userId: sanitizeUserId(userId), draftId: autoDraftId.toString() }, 'router.autodraft.created');
      
      
      
      return {
        draftId: autoDraftId.toString(),
        subject: smartResponse.subject,
        body: smartResponse.body,
        tone: smartResponse.tone,
        urgencyLevel: smartResponse.urgencyLevel
      };
      
    } catch (error) {
      logger.error({ userId: sanitizeUserId(userId), error: error instanceof Error ? error.message : String(error) }, 'router.autodraft.failed');
      return null;
    }
  }

  /**
   * Batch process multiple emails through intelligent routing
   */
  async routeEmails(
    emails: ParsedEmail[],
    userId: string
  ): Promise<RouterResult[]> {
    logger.info({ emailCount: emails.length, userId: sanitizeUserId(userId) }, 'router.batch.started');
    
    const results: RouterResult[] = [];
    let meetingCount = 0;
    let autoDraftCount = 0;
    let skippedCount = 0;
    
    for (const email of emails) {
      const result = await this.routeEmail(email, userId);
      results.push(result);
      
      // Count routing decisions
      switch (result.routingDecision.route) {
        case 'meeting':
          meetingCount++;
          break;
        case 'autodraft':
          autoDraftCount++;
          break;
        case 'skip':
          skippedCount++;
          break;
      }
      
      // Small delay to prevent overwhelming services
      await new Promise(resolve => setTimeout(resolve, 200));
    }
    
    
    logger.info({ userId: sanitizeUserId(userId), totalEmails: emails.length, meetingCount, autoDraftCount, skippedCount }, 'router.batch.completed');
    
    return results;
  }

  /**
   * Get routing statistics for analysis
   */
  getRoutingStats(results: RouterResult[]) {
    const total = results.length;
    const meetingRouted = results.filter(r => r.routingDecision.route === 'meeting').length;
    const autoDraftRouted = results.filter(r => r.routingDecision.route === 'autodraft').length;
    const skipped = results.filter(r => r.routingDecision.route === 'skip').length;
    const errors = results.filter(r => r.status === 'error').length;
    
    const avgProcessingTime = results.reduce((sum, r) => sum + r.totalProcessingTime, 0) / total;
    const avgConfidence = results.reduce((sum, r) => sum + r.routingDecision.confidence, 0) / total;
    
    return {
      total,
      routing: {
        meeting: meetingRouted,
        autoDraft: autoDraftRouted,
        skipped
      },
      routingPercentages: {
        meeting: Math.round((meetingRouted / total) * 100),
        autoDraft: Math.round((autoDraftRouted / total) * 100),
        skipped: Math.round((skipped / total) * 100)
      },
      performance: {
        successRate: Math.round(((total - errors) / total) * 100),
        avgProcessingTime: Math.round(avgProcessingTime),
        avgConfidence: Math.round(avgConfidence)
      }
    };
  }

  /**
   * Health check for the intelligent router
   */
  async healthCheck(): Promise<{
    status: string;
    openAIClassifier: boolean;
    meetingPipeline: boolean;
    responseService: boolean;
    autoDraftModel: boolean;
    overallHealth: string;
  }> {
    try {
      // Test OpenAI classifier
      const classifierHealth = await this.testClassifierHealth();
      
      // Test meeting pipeline
      const meetingHealth = await this.meetingPipeline.healthCheck();
      
      // Test response service (basic check)
      const responseHealth = await this.testResponseServiceHealth();
      
      // Test auto-draft model (basic check)  
      const autoDraftHealth = await this.testAutoDraftModelHealth();
      
      const allHealthy = classifierHealth && 
                        meetingHealth.status === 'healthy' && 
                        responseHealth && 
                        autoDraftHealth;
      
      return {
        status: allHealthy ? 'healthy' : 'degraded',
        openAIClassifier: classifierHealth,
        meetingPipeline: meetingHealth.status === 'healthy',
        responseService: responseHealth,
        autoDraftModel: autoDraftHealth,
        overallHealth: allHealthy ? 'All systems operational' : 'Some components degraded'
      };
      
    } catch (error) {
      return {
        status: 'error',
        openAIClassifier: false,
        meetingPipeline: false,
        responseService: false,
        autoDraftModel: false,
        overallHealth: `Health check failed: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  // Private health check methods
  private async testClassifierHealth(): Promise<boolean> {
    try {
      // Test with a simple email
      const testEmail: ParsedEmail = {
        id: 'health-check',
        from: 'test@example.com',
        to: 'user@example.com',
        subject: 'Health Check',
        body: 'This is a health check email',
        date: new Date(),
        threadId: 'health-thread',
        isRead: false
      };
      
      await this.openAIClassifier.classifyEmailType(testEmail);
      return true;
    } catch {
      return false;
    }
  }

  private async testResponseServiceHealth(): Promise<boolean> {
    try {
      // Basic availability check - we'll implement more thorough testing later
      return this.responseService !== null && typeof this.responseService.generateSmartResponse === 'function';
    } catch {
      return false;
    }
  }

  private async testAutoDraftModelHealth(): Promise<boolean> {
    try {
      // Basic availability check - we'll implement more thorough testing later
      return typeof this.autoGeneratedDraftModel.createDraftForUser === 'function';
    } catch {
      return false;
    }
  }
}