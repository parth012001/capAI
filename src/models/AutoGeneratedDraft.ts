import { pool } from '../database/connection';

export interface AutoGeneratedDraft {
  id: number;
  draft_id: string;
  original_email_id: number;
  subject: string;
  body: string;
  tone?: string;
  urgency_level?: string;
  context_used?: any;
  relationship_type?: string;
  status: 'pending' | 'reviewed' | 'edited' | 'sent' | 'deleted';
  created_at: Date;
  reviewed_at?: Date;
  sent_at?: Date;
  user_edited: boolean;
  edit_count: number;
  processing_time_ms?: number;
  user_id?: string; // Multi-user support
}

export interface CreateAutoGeneratedDraftData {
  draft_id: string;
  original_email_id: number;
  subject: string;
  body: string;
  tone?: string;
  urgency_level?: string;
  context_used?: any;
  relationship_type?: string;
  processing_time_ms?: number;
  user_id?: string; // NEW: For multi-user support
}

export class AutoGeneratedDraftModel {
  /**
   * NEW: Create draft for specific user (24/7 multi-user support)
   */
  async createDraftForUser(data: CreateAutoGeneratedDraftData): Promise<number> {
    try {
      const query = `
        INSERT INTO auto_generated_drafts (
          draft_id, original_email_id, subject, body, tone, 
          urgency_level, context_used, relationship_type, processing_time_ms, user_id
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING id
      `;
      
      const values = [
        data.draft_id,
        data.original_email_id,
        data.subject,
        data.body,
        data.tone,
        data.urgency_level,
        data.context_used ? JSON.stringify(data.context_used) : null,
        data.relationship_type,
        data.processing_time_ms,
        data.user_id
      ];
      
      const result = await pool.query(query, values);
      console.log(`✅ Auto-generated draft saved for user ${data.user_id} with ID: ${result.rows[0].id}`);
      return result.rows[0].id;
    } catch (error) {
      console.error('❌ Error saving auto-generated draft for user:', error);
      throw error;
    }
  }

  async createDraft(data: CreateAutoGeneratedDraftData): Promise<number> {
    try {
      const query = `
        INSERT INTO auto_generated_drafts (
          draft_id, original_email_id, subject, body, tone, 
          urgency_level, context_used, relationship_type, processing_time_ms
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        RETURNING id
      `;
      
      const values = [
        data.draft_id,
        data.original_email_id,
        data.subject,
        data.body,
        data.tone,
        data.urgency_level,
        data.context_used ? JSON.stringify(data.context_used) : null,
        data.relationship_type,
        data.processing_time_ms
      ];
      
      const result = await pool.query(query, values);
      console.log(`✅ Auto-generated draft saved with ID: ${result.rows[0].id}`);
      return result.rows[0].id;
    } catch (error) {
      console.error('❌ Error saving auto-generated draft:', error);
      throw error;
    }
  }

  async getPendingDrafts(limit: number = 20): Promise<AutoGeneratedDraft[]> {
    try {
      const query = `
        SELECT * FROM auto_generated_drafts 
        WHERE status = 'pending' 
        ORDER BY created_at DESC 
        LIMIT $1
      `;
      
      const result = await pool.query(query, [limit]);
      return result.rows;
    } catch (error) {
      console.error('❌ Error fetching pending auto-generated drafts:', error);
      return [];
    }
  }

  async updateDraftStatus(
    draftId: number, 
    status: AutoGeneratedDraft['status'], 
    additionalFields?: Partial<AutoGeneratedDraft>
  ): Promise<void> {
    try {
      let query = 'UPDATE auto_generated_drafts SET status = $1';
      const values: any[] = [status];
      let paramIndex = 2;

      if (status === 'reviewed') {
        query += ', reviewed_at = NOW()';
      }
      
      if (status === 'sent') {
        query += ', sent_at = NOW()';
      }
      
      if (additionalFields?.user_edited !== undefined) {
        query += `, user_edited = $${paramIndex}`;
        values.push(additionalFields.user_edited);
        paramIndex++;
      }
      
      if (additionalFields?.edit_count !== undefined) {
        query += `, edit_count = $${paramIndex}`;
        values.push(additionalFields.edit_count);
        paramIndex++;
      }

      query += ` WHERE id = $${paramIndex}`;
      values.push(draftId);

      await pool.query(query, values);
      console.log(`✅ Updated draft ${draftId} status to: ${status}`);
    } catch (error) {
      console.error('❌ Error updating auto-generated draft status:', error);
      throw error;
    }
  }

  async getDraftById(draftId: number): Promise<AutoGeneratedDraft | null> {
    try {
      const query = 'SELECT * FROM auto_generated_drafts WHERE id = $1';
      const result = await pool.query(query, [draftId]);
      return result.rows[0] || null;
    } catch (error) {
      console.error('❌ Error fetching auto-generated draft:', error);
      return null;
    }
  }

  async getDraftByIdWithEmail(draftId: number): Promise<any | null> {
    try {
      const query = `
        SELECT 
          d.*,
          e.from_email as original_from,
          e.to_email as original_to,
          e.thread_id as original_thread_id,
          e.gmail_id as original_gmail_id
        FROM auto_generated_drafts d
        INNER JOIN emails e ON d.original_email_id = e.id
        WHERE d.id = $1
      `;
      const result = await pool.query(query, [draftId]);
      return result.rows[0] || null;
    } catch (error) {
      console.error('❌ Error fetching auto-generated draft with email data:', error);
      return null;
    }
  }

  async getDraftsByEmailId(emailId: number): Promise<AutoGeneratedDraft[]> {
    try {
      const query = `
        SELECT * FROM auto_generated_drafts 
        WHERE original_email_id = $1 
        ORDER BY created_at DESC
      `;
      const result = await pool.query(query, [emailId]);
      return result.rows;
    } catch (error) {
      console.error('❌ Error fetching drafts by email ID:', error);
      return [];
    }
  }

  async getPendingDraftsWithEmails(limit: number = 20, userId?: string): Promise<any[]> {
    try {
      let query: string;
      let queryParams: any[];

      if (userId) {
        // Filter by user for multi-user security
        query = `
          SELECT 
            d.*,
            e.subject as original_subject,
            e.from_email as original_from,
            e.received_at as original_date,
            e.is_read as original_is_read,
            LEFT(e.body, 1500) as original_preview,
            e.gmail_id as original_gmail_id
          FROM auto_generated_drafts d
          INNER JOIN emails e ON d.original_email_id = e.id
          WHERE d.status = 'pending' AND d.user_id = $2
          ORDER BY d.created_at DESC 
          LIMIT $1
        `;
        queryParams = [limit, userId];
      } else {
        // Fallback for backward compatibility (should not be used in production)
        console.warn('⚠️ getPendingDraftsWithEmails called without userId - potential security issue');
        query = `
          SELECT 
            d.*,
            e.subject as original_subject,
            e.from_email as original_from,
            e.received_at as original_date,
            e.is_read as original_is_read,
            LEFT(e.body, 1500) as original_preview,
            e.gmail_id as original_gmail_id
          FROM auto_generated_drafts d
          INNER JOIN emails e ON d.original_email_id = e.id
          WHERE d.status = 'pending' 
          ORDER BY d.created_at DESC 
          LIMIT $1
        `;
        queryParams = [limit];
      }
      
      const result = await pool.query(query, queryParams);
      return result.rows;
    } catch (error) {
      console.error('❌ Error fetching pending drafts with email data:', error);
      return [];
    }
  }
}