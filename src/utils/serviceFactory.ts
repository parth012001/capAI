/**
 * Service Factory - Request-Scoped Service Container
 *
 * CRITICAL SECURITY FIX: Prevents data leakage between concurrent user requests
 * by providing isolated service instances per HTTP request.
 *
 * PROBLEM (before):
 * - Global singleton services shared mutable state (currentUserId, userTimezone)
 * - Concurrent Request A sets gmailService.currentUserId = 'alice'
 * - Concurrent Request B sets gmailService.currentUserId = 'bob'
 * - Request A continues and reads bob's emails instead of alice's ❌ DATA LEAK
 *
 * SOLUTION (now):
 * - Each HTTP request gets its own isolated ServiceContainer
 * - Request A has its own GmailService instance
 * - Request B has its own GmailService instance
 * - Complete isolation, zero data leakage ✅
 *
 * Usage in routes:
 * ```typescript
 * app.get('/emails', authMiddleware.authenticate, async (req, res) => {
 *   const services = ServiceFactory.createForRequest(req);
 *   const gmail = await services.getGmailService();
 *   const emails = await gmail.fetchEmails();
 *   res.json({ emails });
 * });
 * ```
 *
 * @author Chief AI Development Team
 * @since 2025-10-16
 * @version 1.0.0 - Production-Ready Security Fix
 */

import { GmailService } from '../services/gmail';
import { CalendarService } from '../services/calendar';
import { ComposioGmailService } from '../services/composio/gmail';
import { ComposioCalendarService } from '../services/composio/calendar';
import { ComposioClient } from '../services/composio/client';
import { AIService } from '../services/ai';
import { ContextService } from '../services/context';
import { ResponseService } from '../services/response';
import { LearningService } from '../services/learning';
import { MeetingDetectionService } from '../services/meetingDetection';
import { AutoSchedulingService } from '../services/autoScheduling';
import { MeetingPipelineService } from '../services/meetingPipeline';
import { MeetingConfirmationService } from '../services/meetingConfirmation';
import { TokenStorageService } from '../services/tokenStorage';
import { features } from '../config/environment';
import { logger, sanitizeUserId } from '../utils/pino-logger';

// Import models (these are stateless and can be shared safely)
// Note: Using capitalized paths to match actual file names (macOS case-insensitive but git tracks case)
import { EmailModel } from '../models/Email';
import { DraftModel } from '../models/Draft';
import { ContextModel } from '../models/Context';
import { CalendarModel } from '../models/Calendar';
import { AutoGeneratedDraftModel } from '../models/AutoGeneratedDraft';
import { PromotionalEmailModel } from '../models/PromotionalEmail';

/**
 * Request-Scoped Service Container
 *
 * Each HTTP request gets its own instance of this class, ensuring complete
 * isolation between concurrent user requests.
 *
 * Services are lazy-initialized (created on first access) and cached within
 * the request lifecycle for performance.
 */
export class ServiceContainer {
  private readonly userId: string;
  private readonly composioEntityId?: string;

  // Lazy-initialized services (created once per request)
  private _gmailService?: GmailService | ComposioGmailService;
  private _calendarService?: CalendarService | ComposioCalendarService;
  private _aiService?: AIService;
  private _contextService?: ContextService;
  private _responseService?: ResponseService;
  private _learningService?: LearningService;
  private _meetingDetectionService?: MeetingDetectionService;
  private _autoSchedulingService?: AutoSchedulingService;
  private _meetingPipelineService?: MeetingPipelineService;
  private _meetingConfirmationService?: MeetingConfirmationService;
  private _tokenStorageService?: TokenStorageService;

  // Shared stateless models (safe to reuse)
  private _emailModel?: EmailModel;
  private _draftModel?: DraftModel;
  private _contextModel?: ContextModel;
  private _calendarModel?: CalendarModel;
  private _autoGeneratedDraftModel?: AutoGeneratedDraftModel;
  private _promotionalEmailModel?: PromotionalEmailModel;

  constructor(userId: string, composioEntityId?: string) {
    if (!userId || typeof userId !== 'string') {
      throw new Error(`Invalid userId provided to ServiceContainer: ${userId}`);
    }
    this.userId = userId;
    this.composioEntityId = composioEntityId;
  }

  /**
   * Get Gmail service initialized for this user
   * CRITICAL: This service has user-specific OAuth credentials and state
   *
   * Feature Flag: Returns ComposioGmailService if USE_COMPOSIO=true, else legacy GmailService
   */
  async getGmailService(): Promise<GmailService | ComposioGmailService> {
    if (!this._gmailService) {
      if (features.useComposio) {
        // Use Composio integration
        if (!this.composioEntityId) {
          throw new Error('Composio entity ID required when USE_COMPOSIO=true');
        }
        logger.debug({
          userId: sanitizeUserId(this.userId),
          provider: 'composio'
        }, 'servicefactory.gmail.composio');

        this._gmailService = new ComposioGmailService(this.composioEntityId, this.userId);
      } else {
        // Use legacy Gmail service
        logger.debug({
          userId: sanitizeUserId(this.userId),
          provider: 'google_oauth'
        }, 'servicefactory.gmail.legacy');

        this._gmailService = new GmailService();
        await this._gmailService.initializeForUser(this.userId);
      }
    }
    return this._gmailService;
  }

  /**
   * Get Calendar service initialized for this user
   * CRITICAL: This service has user-specific OAuth credentials and timezone
   *
   * Feature Flag: Returns ComposioCalendarService if USE_COMPOSIO=true, else legacy CalendarService
   */
  async getCalendarService(): Promise<CalendarService | ComposioCalendarService> {
    if (!this._calendarService) {
      if (features.useComposio) {
        // Use Composio integration
        if (!this.composioEntityId) {
          throw new Error('Composio entity ID required when USE_COMPOSIO=true');
        }
        logger.debug({
          userId: sanitizeUserId(this.userId),
          provider: 'composio'
        }, 'servicefactory.calendar.composio');

        this._calendarService = new ComposioCalendarService(this.composioEntityId, this.userId);
        await this._calendarService.initializeForUser(this.userId);
      } else {
        // Use legacy Calendar service
        logger.debug({
          userId: sanitizeUserId(this.userId),
          provider: 'google_oauth'
        }, 'servicefactory.calendar.legacy');

        this._calendarService = new CalendarService();

        // Get user credentials and initialize
        const tokenStorage = this.getTokenStorageService();
        const credentials = await tokenStorage.getDecryptedCredentials(this.userId);

        if (credentials) {
          await this._calendarService.setStoredTokens(
            credentials.accessToken,
            credentials.refreshToken
          );
          await this._calendarService.initializeForUser(this.userId);
        }
      }
    }
    return this._calendarService;
  }

  /**
   * Get AI service (stateless, safe to reuse within request)
   */
  getAIService(): AIService {
    if (!this._aiService) {
      this._aiService = new AIService();
    }
    return this._aiService;
  }

  /**
   * Get Context service
   */
  getContextService(): ContextService {
    if (!this._contextService) {
      this._contextService = new ContextService();
    }
    return this._contextService;
  }

  /**
   * Get Response service (with dependencies)
   * Dependencies: AIService, ContextService, GmailService
   */
  async getResponseService(): Promise<ResponseService> {
    if (!this._responseService) {
      const aiService = this.getAIService();
      const contextService = this.getContextService();
      const gmailService = await this.getGmailService();
      // Cast to any to handle both GmailService and ComposioGmailService
      this._responseService = new ResponseService(aiService, contextService, gmailService as any);
    }
    return this._responseService;
  }

  /**
   * Get Learning service (with dependencies)
   * Dependencies: AIService
   */
  getLearningService(): LearningService {
    if (!this._learningService) {
      const aiService = this.getAIService();
      this._learningService = new LearningService(aiService);
    }
    return this._learningService;
  }

  /**
   * Get Meeting Detection service
   */
  getMeetingDetectionService(): MeetingDetectionService {
    if (!this._meetingDetectionService) {
      this._meetingDetectionService = new MeetingDetectionService();
    }
    return this._meetingDetectionService;
  }

  /**
   * Get Auto Scheduling service
   */
  getAutoSchedulingService(): AutoSchedulingService {
    if (!this._autoSchedulingService) {
      this._autoSchedulingService = new AutoSchedulingService();
    }
    return this._autoSchedulingService;
  }

  /**
   * Get Meeting Pipeline service
   */
  getMeetingPipelineService(): MeetingPipelineService {
    if (!this._meetingPipelineService) {
      this._meetingPipelineService = new MeetingPipelineService();
    }
    return this._meetingPipelineService;
  }

  /**
   * Get Meeting Confirmation service
   */
  getMeetingConfirmationService(): MeetingConfirmationService {
    if (!this._meetingConfirmationService) {
      this._meetingConfirmationService = new MeetingConfirmationService();
    }
    return this._meetingConfirmationService;
  }

  /**
   * Get Token Storage service (shared, stateless)
   */
  getTokenStorageService(): TokenStorageService {
    if (!this._tokenStorageService) {
      this._tokenStorageService = new TokenStorageService();
    }
    return this._tokenStorageService;
  }

  // === STATELESS MODELS (safe to share) ===

  getEmailModel(): EmailModel {
    if (!this._emailModel) {
      this._emailModel = new EmailModel();
    }
    return this._emailModel;
  }

  getDraftModel(): DraftModel {
    if (!this._draftModel) {
      this._draftModel = new DraftModel();
    }
    return this._draftModel;
  }

  getContextModel(): ContextModel {
    if (!this._contextModel) {
      this._contextModel = new ContextModel();
    }
    return this._contextModel;
  }

  getCalendarModel(): CalendarModel {
    if (!this._calendarModel) {
      this._calendarModel = new CalendarModel();
    }
    return this._calendarModel;
  }

  getAutoGeneratedDraftModel(): AutoGeneratedDraftModel {
    if (!this._autoGeneratedDraftModel) {
      this._autoGeneratedDraftModel = new AutoGeneratedDraftModel();
    }
    return this._autoGeneratedDraftModel;
  }

  getPromotionalEmailModel(): PromotionalEmailModel {
    if (!this._promotionalEmailModel) {
      this._promotionalEmailModel = new PromotionalEmailModel();
    }
    return this._promotionalEmailModel;
  }

  /**
   * Get the user ID for this service container
   */
  getUserId(): string {
    return this.userId;
  }
}

/**
 * Service Factory - Creates isolated service containers for requests
 *
 * This is the main entry point for route handlers to get services.
 */
export class ServiceFactory {
  /**
   * Create a new service container for a specific user
   *
   * @param userId - The user ID to create services for
   * @param composioEntityId - Optional Composio entity ID (required if USE_COMPOSIO=true)
   * @returns Isolated service container for this user
   */
  static createForUser(userId: string, composioEntityId?: string): ServiceContainer {
    return new ServiceContainer(userId, composioEntityId);
  }

  /**
   * Create services for an authenticated Express request
   *
   * Expects req.userId to be set by authentication middleware.
   * This is the primary method used in route handlers.
   *
   * @param req - Express request object with userId property (and optional composioEntityId)
   * @returns Isolated service container for the authenticated user
   * @throws Error if req.userId is not set (authentication middleware missing)
   */
  static async createFromRequest(req: any): Promise<ServiceContainer> {
    if (!req.userId) {
      throw new Error(
        'User ID not found in request. Ensure authentication middleware is applied to this route.'
      );
    }

    // If using Composio, fetch composio_entity_id from database
    let composioEntityId: string | undefined;

    if (features.useComposio) {
      const tokenStorage = new TokenStorageService();
      const userData = await tokenStorage.getUserTokens(req.userId);

      if (userData?.composioEntityId) {
        composioEntityId = userData.composioEntityId;
      } else {
        logger.warn({
          userId: sanitizeUserId(req.userId)
        }, 'servicefactory.composio.entity.missing');
      }
    }

    return new ServiceContainer(req.userId, composioEntityId);
  }
}
