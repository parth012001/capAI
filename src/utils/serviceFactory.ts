/**
 * Service Factory - Request-Scoped Service Container
 *
 * CRITICAL SECURITY FIX: Prevents data leakage between concurrent user requests
 * by providing isolated service instances per HTTP request.
 *
 * PROBLEM (before):
 * - Global singleton services shared mutable state (currentUserId, userTimezone)
 * - Concurrent Request A sets gmailService.currentUserId = 'alice'
 * - Concurrent Request B sets gmailService.currentUserId = 'bob'
 * - Request A continues and reads bob's emails instead of alice's ❌ DATA LEAK
 *
 * SOLUTION (now):
 * - Each HTTP request gets its own isolated ServiceContainer
 * - Request A has its own GmailService instance
 * - Request B has its own GmailService instance
 * - Complete isolation, zero data leakage ✅
 *
 * Usage in routes:
 * ```typescript
 * app.get('/emails', authMiddleware.authenticate, async (req, res) => {
 *   const services = ServiceFactory.createForRequest(req);
 *   const gmail = await services.getGmailService();
 *   const emails = await gmail.fetchEmails();
 *   res.json({ emails });
 * });
 * ```
 *
 * @author Chief AI Development Team
 * @since 2025-10-16
 * @version 1.0.0 - Production-Ready Security Fix
 */

import { GmailService } from '../services/gmail';
import { CalendarService } from '../services/calendar';
import { AIService } from '../services/ai';
import { ContextService } from '../services/context';
import { ResponseService } from '../services/response';
import { LearningService } from '../services/learning';
import { MeetingDetectionService } from '../services/meetingDetection';
import { AutoSchedulingService } from '../services/autoScheduling';
import { MeetingPipelineService } from '../services/meetingPipeline';
import { MeetingConfirmationService } from '../services/meetingConfirmation';
import { TokenStorageService } from '../services/tokenStorage';
import { ComposioService } from '../services/composio';

// Import providers
import {
  IEmailProvider,
  ICalendarProvider,
  ComposioEmailProvider,
  ComposioCalendarProvider
} from '../services/providers';

import { queryWithRetry } from '../database/connection';
import logger, { sanitizeUserId } from './pino-logger';

// Import models (these are stateless and can be shared safely)
// Note: Using capitalized paths to match actual file names (macOS case-insensitive but git tracks case)
import { EmailModel } from '../models/Email';
import { DraftModel } from '../models/Draft';
import { ContextModel } from '../models/Context';
import { CalendarModel } from '../models/Calendar';
import { AutoGeneratedDraftModel } from '../models/AutoGeneratedDraft';
import { PromotionalEmailModel } from '../models/PromotionalEmail';

/**
 * Request-Scoped Service Container
 *
 * Each HTTP request gets its own instance of this class, ensuring complete
 * isolation between concurrent user requests.
 *
 * Services are lazy-initialized (created on first access) and cached within
 * the request lifecycle for performance.
 */
export class ServiceContainer {
  private readonly userId: string;

  // Lazy-initialized services (created once per request)
  private _gmailService?: GmailService;
  private _calendarService?: CalendarService;
  private _aiService?: AIService;
  private _contextService?: ContextService;
  private _responseService?: ResponseService;
  private _learningService?: LearningService;
  private _meetingDetectionService?: MeetingDetectionService;
  private _autoSchedulingService?: AutoSchedulingService;
  private _meetingPipelineService?: MeetingPipelineService;
  private _meetingConfirmationService?: MeetingConfirmationService;
  private _tokenStorageService?: TokenStorageService;
  private _composioService?: ComposioService;

  // Provider layer (abstraction over Gmail/Calendar implementations)
  private _emailProvider?: IEmailProvider;
  private _calendarProvider?: ICalendarProvider;

  // Shared stateless models (safe to reuse)
  private _emailModel?: EmailModel;
  private _draftModel?: DraftModel;
  private _contextModel?: ContextModel;
  private _calendarModel?: CalendarModel;
  private _autoGeneratedDraftModel?: AutoGeneratedDraftModel;
  private _promotionalEmailModel?: PromotionalEmailModel;

  constructor(userId: string) {
    if (!userId || typeof userId !== 'string') {
      throw new Error(`Invalid userId provided to ServiceContainer: ${userId}`);
    }
    this.userId = userId;
  }

  /**
   * Get Gmail service initialized for this user
   * CRITICAL: This service has user-specific OAuth credentials and state
   */
  async getGmailService(): Promise<GmailService> {
    if (!this._gmailService) {
      this._gmailService = new GmailService();
      await this._gmailService.initializeForUser(this.userId);
    }
    return this._gmailService;
  }

  /**
   * Get Calendar service initialized for this user
   * CRITICAL: This service has user-specific OAuth credentials and timezone
   */
  async getCalendarService(): Promise<CalendarService> {
    if (!this._calendarService) {
      this._calendarService = new CalendarService();

      // Get user credentials and initialize
      const tokenStorage = this.getTokenStorageService();
      const credentials = await tokenStorage.getDecryptedCredentials(this.userId);

      if (credentials) {
        await this._calendarService.setStoredTokens(
          credentials.accessToken,
          credentials.refreshToken
        );
        await this._calendarService.initializeForUser(this.userId);
      }
    }
    return this._calendarService;
  }

  /**
   * Get AI service (stateless, safe to reuse within request)
   */
  getAIService(): AIService {
    if (!this._aiService) {
      this._aiService = new AIService();
    }
    return this._aiService;
  }

  /**
   * Get Context service
   */
  getContextService(): ContextService {
    if (!this._contextService) {
      this._contextService = new ContextService();
    }
    return this._contextService;
  }

  /**
   * Get Response service (with dependencies)
   * Dependencies: AIService, ContextService, GmailService
   */
  async getResponseService(): Promise<ResponseService> {
    if (!this._responseService) {
      const aiService = this.getAIService();
      const contextService = this.getContextService();
      const gmailService = await this.getGmailService();
      this._responseService = new ResponseService(aiService, contextService, gmailService);
    }
    return this._responseService;
  }

  /**
   * Get Learning service (with dependencies)
   * Dependencies: AIService
   */
  getLearningService(): LearningService {
    if (!this._learningService) {
      const aiService = this.getAIService();
      this._learningService = new LearningService(aiService);
    }
    return this._learningService;
  }

  /**
   * Get Meeting Detection service
   */
  getMeetingDetectionService(): MeetingDetectionService {
    if (!this._meetingDetectionService) {
      this._meetingDetectionService = new MeetingDetectionService();
    }
    return this._meetingDetectionService;
  }

  /**
   * Get Auto Scheduling service
   */
  getAutoSchedulingService(): AutoSchedulingService {
    if (!this._autoSchedulingService) {
      this._autoSchedulingService = new AutoSchedulingService();
    }
    return this._autoSchedulingService;
  }

  /**
   * Get Meeting Pipeline service
   */
  getMeetingPipelineService(): MeetingPipelineService {
    if (!this._meetingPipelineService) {
      this._meetingPipelineService = new MeetingPipelineService();
    }
    return this._meetingPipelineService;
  }

  /**
   * Get Meeting Confirmation service
   */
  getMeetingConfirmationService(): MeetingConfirmationService {
    if (!this._meetingConfirmationService) {
      this._meetingConfirmationService = new MeetingConfirmationService();
    }
    return this._meetingConfirmationService;
  }

  /**
   * Get Token Storage service (shared, stateless)
   */
  getTokenStorageService(): TokenStorageService {
    if (!this._tokenStorageService) {
      this._tokenStorageService = new TokenStorageService();
    }
    return this._tokenStorageService;
  }

  // === STATELESS MODELS (safe to share) ===

  getEmailModel(): EmailModel {
    if (!this._emailModel) {
      this._emailModel = new EmailModel();
    }
    return this._emailModel;
  }

  getDraftModel(): DraftModel {
    if (!this._draftModel) {
      this._draftModel = new DraftModel();
    }
    return this._draftModel;
  }

  getContextModel(): ContextModel {
    if (!this._contextModel) {
      this._contextModel = new ContextModel();
    }
    return this._contextModel;
  }

  getCalendarModel(): CalendarModel {
    if (!this._calendarModel) {
      this._calendarModel = new CalendarModel();
    }
    return this._calendarModel;
  }

  getAutoGeneratedDraftModel(): AutoGeneratedDraftModel {
    if (!this._autoGeneratedDraftModel) {
      this._autoGeneratedDraftModel = new AutoGeneratedDraftModel();
    }
    return this._autoGeneratedDraftModel;
  }

  getPromotionalEmailModel(): PromotionalEmailModel {
    if (!this._promotionalEmailModel) {
      this._promotionalEmailModel = new PromotionalEmailModel();
    }
    return this._promotionalEmailModel;
  }

  /**
   * Get Composio service
   */
  getComposioService(): ComposioService {
    if (!this._composioService) {
      this._composioService = new ComposioService();
    }
    return this._composioService;
  }

  /**
   * Get Email Provider (Composio-based)
   *
   * Returns the appropriate email provider based on user's auth_method.
   * Currently returns Composio provider for all users with composio_connected_account_id.
   */
  async getEmailProvider(): Promise<IEmailProvider> {
    if (!this._emailProvider) {
      // Check user's auth method from database
      const result = await queryWithRetry(
        'SELECT auth_method, composio_connected_account_id FROM user_gmail_tokens WHERE user_id = $1',
        [this.userId]
      );

      const authMethod = result.rows[0]?.auth_method;
      const composioConnected = result.rows[0]?.composio_connected_account_id;

      // Use Composio if user has connected via Composio
      if (composioConnected) {
        logger.info({
          userId: sanitizeUserId(this.userId),
          provider: 'Composio',
          authMethod
        }, 'service.provider.email.composio');

        const composioService = this.getComposioService();
        this._emailProvider = new ComposioEmailProvider(composioService);
      } else {
        // For now, throw error - all users should connect via Composio
        throw new Error(
          `User ${this.userId} has not connected via Composio. Please connect Gmail first.`
        );
      }
    }

    return this._emailProvider;
  }

  /**
   * Get Calendar Provider (Composio-based)
   *
   * Returns the appropriate calendar provider based on user's auth_method.
   * Currently returns Composio provider for all users with composio_connected_account_id.
   */
  async getCalendarProvider(): Promise<ICalendarProvider> {
    if (!this._calendarProvider) {
      // Check user's auth method from database
      const result = await queryWithRetry(
        'SELECT auth_method, composio_connected_account_id FROM user_gmail_tokens WHERE user_id = $1',
        [this.userId]
      );

      const authMethod = result.rows[0]?.auth_method;
      const composioConnected = result.rows[0]?.composio_connected_account_id;

      // Use Composio if user has connected via Composio
      if (composioConnected) {
        logger.info({
          userId: sanitizeUserId(this.userId),
          provider: 'Composio',
          authMethod
        }, 'service.provider.calendar.composio');

        const composioService = this.getComposioService();
        this._calendarProvider = new ComposioCalendarProvider(composioService);
      } else {
        // For now, throw error - all users should connect via Composio
        throw new Error(
          `User ${this.userId} has not connected via Composio. Please connect Calendar first.`
        );
      }
    }

    return this._calendarProvider;
  }

  /**
   * Get the user ID for this service container
   */
  getUserId(): string {
    return this.userId;
  }
}

/**
 * Service Factory - Creates isolated service containers for requests
 *
 * This is the main entry point for route handlers to get services.
 */
export class ServiceFactory {
  /**
   * Create a new service container for a specific user
   *
   * @param userId - The user ID to create services for
   * @returns Isolated service container for this user
   */
  static createForUser(userId: string): ServiceContainer {
    return new ServiceContainer(userId);
  }

  /**
   * Create services for an authenticated Express request
   *
   * Expects req.userId to be set by authentication middleware.
   * This is the primary method used in route handlers.
   *
   * @param req - Express request object with userId property
   * @returns Isolated service container for the authenticated user
   * @throws Error if req.userId is not set (authentication middleware missing)
   */
  static createFromRequest(req: any): ServiceContainer {
    if (!req.userId) {
      throw new Error(
        'User ID not found in request. Ensure authentication middleware is applied to this route.'
      );
    }
    return new ServiceContainer(req.userId);
  }
}
